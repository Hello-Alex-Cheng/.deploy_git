<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入浅出TypeScript</title>
    <link href="/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html"/>
    <url>/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="d-ts-和-declare-是干嘛用的"><a href="#d-ts-和-declare-是干嘛用的" class="headerlink" title=".d.ts 和 declare 是干嘛用的"></a>.d.ts 和 declare 是干嘛用的</h2><p>如果一个文件有扩展名 <code>.d.ts</code>，则表示它是一个声明文件，可以用来声明全局的类型定义和接口，或者是其它模块。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// global.d.ts</span><br><br><span class="hljs-comment">// 声明接口</span><br>declare interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-comment">// 声明类型 (别名)</span><br>declare type <span class="hljs-title class_">TName</span> = string;<br><br><span class="hljs-comment">// 声明模块</span><br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.css&#x27;</span>;<br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.less&#x27;</span>;<br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.png&#x27;</span>;<br><br><span class="hljs-comment">// 拓展 window 属性，在 window 对象上显式设置属性</span><br>declare interface <span class="hljs-title class_">Window</span> &#123;<br>  <span class="hljs-title class_">MyNameSpace</span>: any<br>&#125;<br></code></pre></td></tr></table></figure><p>但是也不是说创建了.d.ts文件，里面声明的东西就能生效了，毕竟归根到底也是.ts文件，需要预编译，所以需要在tsconfig.json文件里面的include数组里面添加 <code>global.d.ts</code> 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.d.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.tsx&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.vue&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><code>.d.ts</code> 文件中的顶级声明必须以 “declare” 或 “export” 修饰符开头。通过<code>declare</code>声明的类型或者变量或者模块，在<code>include</code>包含的文件范围内，都可以直接引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .vue setup / .ts</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">me</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alex.cheng&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong><br><code>.d.ts</code>文件顶级声明<code>declare</code>最好不要跟<code>export</code>同级使用，不然在其他<code>ts</code>文件引用这个<code>.d.ts</code>的内容的时候，就需要手动import导入了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">TName</span> = string;<br><br><span class="hljs-comment">// 这个时候，外部 ts 就无法直接使用 Person 了，需要引入 import &#123; Person &#125; from &#x27;../global.d.ts&#x27;</span><br><span class="hljs-keyword">export</span> declare interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="给对象分配动态（未知）属性"><a href="#给对象分配动态（未知）属性" class="headerlink" title="给对象分配动态（未知）属性"></a>给对象分配动态（未知）属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">o</span>: &#123; [<span class="hljs-attr">key</span>: string]: any &#125; = &#123;&#125;<br><br><span class="hljs-comment">// 使用 ts 内置工具 Record，效果同上</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">o</span>: <span class="hljs-title class_">Record</span>&lt;string, any&gt; = &#123;&#125;<br><br>interface <span class="hljs-title class_">IPerson</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;string, any&gt; &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  age?: number;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">me1</span>: <span class="hljs-title class_">IPerson</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alex&#x27;</span>,<br>  <span class="hljs-attr">hair</span>: <span class="hljs-string">&#x27;black&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="interface-和-type-有什么区别"><a href="#interface-和-type-有什么区别" class="headerlink" title="interface 和 type 有什么区别"></a>interface 和 type 有什么区别</h2><ol><li><p><code>接口</code>和<code>类型别名</code>都可以用来描述对象的形状或函数签名。</p></li><li><p>与<code>接口类型</code>不一样的是，<code>类型别名</code>可以用于一些其他类型，比如原始类型、联合类型（<code>|</code>）和元组。</p></li><li><p>接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。</p><p><code>interface</code> 扩展（接口、类型）使用 <code>extends</code> 关键字，类型别名扩展（接口、类型）使用的是 <code>交叉类型（&amp;）</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 接口扩展</span><br>interface <span class="hljs-title class_">IPerson</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>&#125;<br>interface <span class="hljs-title class_">IMe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPerson</span> &#123;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-comment">// 类型扩展</span><br>type <span class="hljs-title class_">TPerson</span> = &#123;<br>  <span class="hljs-attr">name</span>: string;<br>&#125;<br>type <span class="hljs-title class_">TMe</span> = <span class="hljs-title class_">TPerson</span> &amp; &#123;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类可以以相同的方式实现(<code>implements</code>)接口或类型别名，但类不能实现使用类型别名定义的联合类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Error:</span><br>type <span class="hljs-title class_">PartialPoint</span> = &#123; <span class="hljs-attr">x</span>: number; &#125; | &#123; <span class="hljs-attr">y</span>: number; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> implements <span class="hljs-title class_">PartialPoint</span> &#123; <span class="hljs-comment">// 类只能实现具有静态已知成员的对象类型或对象类型的交集。ts(2422)</span><br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// Success</span><br>type <span class="hljs-title class_">PartialPoint</span> = &#123; <span class="hljs-attr">x</span>: number; &#125; &amp; &#123; <span class="hljs-attr">y</span>: number; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> implements <span class="hljs-title class_">PartialPoint</span> &#123;<br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">IMerge</span> &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>;<br>&#125;<br>interface <span class="hljs-title class_">IMerge</span> &#123;<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">ab</span>: <span class="hljs-title class_">IMerge</span> = &#123;&#125;; <span class="hljs-comment">// 类型“&#123;&#125;”缺少类型“IMerge”中的以下属性: a, bts(2739)</span><br><br><br><span class="hljs-comment">// Error: 标识符“TOne”重复。ts(2300)</span><br>type <span class="hljs-title class_">TOne</span> = string;<br>type <span class="hljs-title class_">TOne</span> = number;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><ol><li>typeof</li><li>instanceof</li><li>in</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6872111128135073806">TS 学习指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解TypeScript</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端开发实践</title>
    <link href="/post/app-h5.html"/>
    <url>/post/app-h5.html</url>
    
    <content type="html"><![CDATA[<h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发，它具备开发周期短、灵活性好的优点，但是缺点也很明显，加载速度慢 &amp; 消耗流量。引起缺点的主要原因如下：</p><ol><li>js解析效率，以及手机硬件设备的性能</li><li>页面资源的下载（图片、js文件、css文件）</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903673697402887">Android Webview H5 秒开方案实现</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>RN H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何编写高标准的 JavaScript 代码</title>
    <link href="/post/js-advice.html"/>
    <url>/post/js-advice.html</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>你是否曾经为了提供一个简单的应用解决方案而彻夜地查看源代码？<br>你是否曾经为了理解某个框架而冥思苦想、阅览群书？<br>你是否曾经为了提升0.1s的DOM性能而对多种实现方案进行严格测试和对比？<br>你是否曾经为了避免兼容问题而遍寻高手共同“诊治”？</p><p>跟我一起，专注高质量 <code>JavaScript</code> 代码，少出 <code>Bug🐛</code>，早下班 !</p><blockquote><p>期望为读者带来如下帮助 📚：</p></blockquote><p>  ❑ 能写出简单、清晰、高效的代码。<br>  ❑ 能搭建一个稳定、健壮、快捷的应用框架。<br>  ❑ 能回答一个困扰很多人的技术问题。<br>  ❑ 能修复一个应用开发中遇到的大的Bug。<br>  ❑ 能非常熟悉某个开源产品。<br>  ❑ 能提升客户端应用性能。</p><h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><p>代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。</p><h3 id="减少全局变量"><a href="#减少全局变量" class="headerlink" title="减少全局变量"></a>减少全局变量</h3><ol><li><p>多个全局变量都追加在一个名称空间下，将显著降低与其他应用程序产生冲突的概率</p> <figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> namespace = &#123;&#125;<br><br>namespace.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;my namespace&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>使用闭包体将信息隐藏，它是另一种有效减少“全局污染”的方法。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sayName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;closure&#x27;</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(name)<br>  &#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>作用域控制着变量与参数的可见性及生命周期。</p><p> JavaScript支持函数作用域，定义在函数中的参数和变量在函数外部是不可见的，并且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。它不仅减少了名称冲突，并且提供了自动内存管理。</p></li><li><p>ES6 模块化编程中每个 js 文件内部定义的变量，外部无法获取。如果外部需要模块内部变量，通过 export 导出。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-keyword">var</span> windowA = <span class="hljs-string">&#x27;window a&#x27;</span><br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">windowA</span>) <span class="hljs-comment">// 输出 &#x27;window a&#x27;</span><br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">var</span> moduleA = <span class="hljs-string">&#x27;module a&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">moduleA</span>) <span class="hljs-comment">// 输出 undefined</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="谨慎JS数据类型"><a href="#谨慎JS数据类型" class="headerlink" title="谨慎JS数据类型"></a>谨慎JS数据类型</h3><p>在自动转换数据类型时，JavaScript一般遵循：如果某个类型的值被用于需要其他类型的值的环境中，JavaScript就自动将这个值转换成所需要的类型。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>慎用JavaScript类型自动转换，注意<code>自动转换规则</code>:</p><ol><li><p>如果把非空对象用在逻辑运算环境中，则对象被转换为true。此时的对象包括所有类型的对象，即使是值为false的包装对象也被转换为true。</p></li><li><p>果把对象用在数值运算环境中，则对象会被自动转换为数字，如果转换失败，则返回值为NaN。</p></li><li><p>当数组被用在数值运算环境中时，数组将根据包含的元素来决定转换的值。如果数组为空数组，则被转换为数值0。如果数组仅包含一个数字元素，则被转换为该数字的数值。如果数组包含多个元素，或者仅包含一个非数字元素，则返回NaN。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br>obj &amp;&amp; <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span><br>obj + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-string">&#x27;[object Object]1&#x27;</span><br><br>obj.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">99</span> &#125;<br>obj + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 数组自动转换规则</span><br>+[] &gt;&gt; <span class="hljs-number">0</span><br>+[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span><br>+[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ol><li><p><code>typeof</code><br>对于任何变量来说，使用typeof运算符总是以字符串的形式返回以下6种类型之一：<br>❑ “number”<br>❑ “string”<br>❑ “boolean”<br>❑ “object”<br>❑ “function”<br>❑ “undefined”</p><p>令人疑惑的是，在使用 <code>typeof</code> 检测null值时，返回的是“object”，而不是“null”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> &gt;&gt; <span class="hljs-string">&#x27;object&#x27;</span><br><br><span class="hljs-keyword">typeof</span> [] &gt;&gt; <span class="hljs-string">&#x27;object&#x27;</span><br><br><span class="hljs-keyword">typeof</span> &#123;&#125; &gt;&gt; <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><code>instanceof</code></p><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的<code>原型链</code>上。</p><p>这个在判断对象时存在一些不确定性，来看下例子：</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span> &gt;&gt; <span class="hljs-literal">true</span><br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &gt;&gt; <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再看一个🌰:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;hello child&#x27;</span>)<br><br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span> &gt;&gt; <span class="hljs-literal">true</span><br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &gt;&gt; <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果是判断数组呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> &gt;&gt; <span class="hljs-literal">true</span><br><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &gt;&gt; <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 当然这种方式存在不确定性，我们可以使用 Array.isArray() 方法来判断</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([]) &gt;&gt; <span class="hljs-literal">true</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(&#123;&#125;) &gt;&gt; <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>从上面例子可以看出，使用 <code>instanceof</code> 来判断时存在种种不确定性，只要出现在原型链上的对象都会返回 <code>true</code>，使用的时候还需要着重注意！</p><p>为什么会这样，想必大家应该想起来了！</p><p><strong>Object类是所有对象类型的的父类!</strong></p></li><li><p><code>toString() 方法</code></p><blockquote><p>每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。</p></blockquote><p>toString() 方法，它定义在 Object 的原型对象上，对象在调用时会返回一个表示该对象的字符串。</p><p>使用 <code>toString()</code> 方法检测对象类型是最安全、最准确的。调用toString()方法把对象转换为字符串，然后通过检测字符串中是否包含数组所特有的标志字符可以确定对象的类型。</p><p>为什么说 <code>toString</code> 方法用来检测对象类型是最安全、最准确的，我们慢慢来看吧~</p><p>先看看在对象上直接使用 <code>toString</code>会是什么结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br>obj.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br><br><span class="hljs-comment">// 如果是数组的话，则输出字符串</span><br>arr.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;1,2&#x27;</span><br><br><br><span class="hljs-comment">// 当然我们可以重写/覆盖原型链上的 toString 方法</span><br>obj.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overwrite&#x27;</span><br>&#125;<br>obj.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;overwrite&#x27;</span><br></code></pre></td></tr></table></figure><p>既然 toString 方法定义在原型对象上，我们看看如果单独调用它，会是什么结果呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure><p>如果通过 <code>call/apply</code> 方法，改变 <code>toString</code> 方法内部的 <code>this</code> 执行，又会是什么结果呢?</p><p>看到如下结果，我相信这绝对可以完美 cover 住项目里面所有的类型判断了！所以说它是最安全、最准确的类型判断，没有异议吧😏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;) &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]) &gt;&gt; <span class="hljs-string">&#x27;[object Array]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;) &gt;&gt; <span class="hljs-string">&#x27;[object Function]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) &gt;&gt; <span class="hljs-string">&#x27;[object String]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Number]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Boolean]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Null]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Undefined]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>() &gt;&gt; <span class="hljs-string">&#x27;[object Undefined]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) &gt;&gt; <span class="hljs-string">&#x27;[object Date]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-regexp">/at/</span>) &gt;&gt; <span class="hljs-string">&#x27;[object RegExp]&#x27;</span><br><br></code></pre></td></tr></table></figure><p>那么它是如何做到的呢，我们来扒一扒它的原理！在 <code>toString</code> 方法被调用时，会执行以下几个操作步骤:</p><ol><li>获取this指向的那个对象的<code>[[Class]]</code>属性的值。（<code>call/apply</code> 改变 this 指向）</li><li>计算出三个字符串”[object “、 第一步的操作结果、 以及 “]” 连接后的新字符串。</li><li>返回第二步的操作结果，也就是类似 <code>&#39;[object Type]&#39;</code> 这种格式字符串。</li></ol><p>需要注意的是，对象的<code>[[Class]]</code>属性是无法直接访问的，它一个内部属性，所有的对象(原生对象和宿主对象)都拥有该属性，且不能被任何人修改。在规范中，<code>[[Class]]</code>是这么定义的：<code>内部属性</code>描述。</p><p>如果要单独或者对象的 <code>[[Class]]</code>，我们可以这样做:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> targetObj = []<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(targetObj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-string">&#x27;Array&#x27;</span><br></code></pre></td></tr></table></figure><p>既然它如此好用，难道就没有缺点吗？</p><p>答案是当然有的，毕竟凡事都不可能那么绝对的嘛！</p><p>那么缺点是什么呢？<br>第一，<code>toString()</code> 会进行装箱操作，产生很多临时对象。（装箱就是将基本类型的数据，通过引用类型包装起来，从而可以使用引用类上的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 你肯定不能这样用</span><br><span class="hljs-number">1.</span><span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-title class_">SyntaxError</span>: <span class="hljs-title class_">Invalid</span> or unexpected token<br><br><span class="hljs-comment">// 你必须这样用</span><br>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>第二，无法区分自定义对象类型，用来判断这类对象时，返回的都是<code>Object</code>，这样我们就需要通过 <code>instanceof</code> 来判断了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(p) &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript解释器强制约定字符串在堆区存储的数据是不可变的，也就是说，JavaScript解释器强制约定字符串在堆区存储的数据是不可变的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript, ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks</title>
    <link href="/post/react-hooks.html"/>
    <url>/post/react-hooks.html</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="什么事-hooks"><a href="#什么事-hooks" class="headerlink" title="什么事 hooks ?"></a>什么事 hooks ?</h3><h3 id="为什么需要-hooks-它解决了什么问题"><a href="#为什么需要-hooks-它解决了什么问题" class="headerlink" title="为什么需要 hooks ? 它解决了什么问题 ?"></a>为什么需要 hooks ? 它解决了什么问题 ?</h3><h3 id="怎样设计自己的-hooks？"><a href="#怎样设计自己的-hooks？" class="headerlink" title="怎样设计自己的 hooks？"></a>怎样设计自己的 hooks？</h3>]]></content>
    
    
    
    <tags>
      
      <tag>React，Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello_AlexCc</title>
    <link href="/post/first-article.html"/>
    <url>/post/first-article.html</url>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><blockquote><p>This is my first Blog.</p></blockquote><h3 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello_AlexCc!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ヾ(◍°∇°◍)ﾉﾞ&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>One</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
