<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高性能渲染十万条数据(虚拟列表)</title>
    <link href="/post/virtual-list.html"/>
    <url>/post/virtual-list.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p><p><code>时间分片</code> 提到了可以使用时间分片的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用虚拟列表的方式，来同时加载大量数据。</p><p>当我们渲染10w条数据时，其实主要是的时间花费在 <code>Recalculate Style</code> 和 <code>Layout</code> 上</p><ul><li>Recalculate Style：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。</li><li>Layout：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。</li></ul><p><img src="/img/render-10w-data.jpg" alt=""></p><p>在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。</p><p>那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在<code>Recalculate Style</code>和<code>Layout</code>阶段消耗大量的时间。</p><p>而<code>虚拟列表</code>就是解决这一问题的一种实现。</p><h1 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h1><p>虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</p><p>假设有1万条记录需要同时渲染，我们屏幕的可见区域的高度为1000px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到20个列表项，那么在首次渲染的时候，我们只需加载20条即可。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e15195cf16a558~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><p>说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。</p><p>假设滚动发生，滚动条距顶部的位置为150px,则我们可得知在可见区域内的列表项为第4项至`第13项。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e15197c273cbd9~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>虚拟列表的实现，实际上是在首屏加载的时候，只加载 <code>可视区域</code> 内需要的列表项，当滚动发生时，通过计算动态获得可视区域内的列表项，并将非可视区域内存在的列表项删除。</p><ul><li>计算当前可视区域<code>起始数据</code>索引（startIndex）</li><li>计算当前可视区域<code>结束数据</code>索引（endIndex）</li><li>计算当前可视区域的数据，并渲染到页面中</li><li>计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e1519a393dee2c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><p>由于只是对可视区域内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-container&quot;</span> @<span class="hljs-attr">scroll</span>=<span class="hljs-string">&quot;scrollEvent($event)&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 所有数据的总高度 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-phantom&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 可视区区域，可以当做滑块看待 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; transform: getTransform &#125;&quot;</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- 每一项数据 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;items&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-item&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in visibleData&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot;</span></span><br><span class="hljs-tag">      &gt;</span><br>        &#123;&#123; item.value &#125;&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，监听infinite-list-container的 <code>scroll事件</code>，获取滚动位置 <code>scrollTop</code>。</p><ul><li>列表总高度 <code>listHeight = listData.length * itemSize</code></li><li>可显示的列表项数 <code>visibleCount = Math.ceil(screenHeight / itemSize)</code></li><li>数据的起始索引 <code>startIndex = Math.floor(scrollTop / itemSize)</code></li><li>数据的结束索引 <code>endIndex = startIndex + visibleCount</code></li><li>列表显示数据为 <code>visibleData = listData.slice(startIndex,endIndex)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">scrollEvent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//当前滚动位置</span><br>  <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span>;<br><br>  <span class="hljs-comment">//此时的开始索引（向下取整），itemSize 是 100</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>);<br><br>  <span class="hljs-comment">//此时的结束索引</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;<br><br>  <span class="hljs-comment">//此时的偏移量</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">startOffset</span> = scrollTop - (scrollTop % <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>);<br>&#125;,<br></code></pre></td></tr></table></figure><p>当滚动后，由于 <code>渲染区域</code> 相对于 <code>可视区域</code> 已经发生了偏移，此时我需要获取一个 <code>偏移量startOffset</code>，通过样式控制将渲染区域偏移至可视区域中，当用户在滑动时，渲染区域就会根据 <code>startOffset</code> 计算出偏移量，渲染区域就会一直在可视区域内呈现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">startOffset</span> = scrollTop - (scrollTop % <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>);<br><br><span class="hljs-comment">// computed</span><br><span class="hljs-comment">//偏移量对应的style</span><br><span class="hljs-title function_">getTransform</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`translate3d(0,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.startOffset&#125;</span>px,0)`</span>;<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">html</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-tag">body</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-id">#app</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">VirtualList</span> <span class="hljs-attr">:listData</span>=<span class="hljs-string">&quot;state.data&quot;</span> <span class="hljs-attr">:itemSize</span>=<span class="hljs-string">&quot;100&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>VirtualList comp.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;VirtualList&quot;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-comment">//所有列表数据</span><br>    <span class="hljs-attr">listData</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> [],<br>    &#125;,<br>    <span class="hljs-comment">//每项高度</span><br>    <span class="hljs-attr">itemSize</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-number">200</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//列表总高度</span><br>    <span class="hljs-title function_">listHeight</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">listData</span>.<span class="hljs-property">length</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>;<br>    &#125;,<br>    <span class="hljs-comment">//可显示的列表项数</span><br>    <span class="hljs-title function_">visibleCount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 向上取整: Math.ceil(13.06) =&gt; 14，表示整个屏幕，可以放 14 条数据</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenHeight</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>);<br>    &#125;,<br>    <span class="hljs-comment">//偏移量对应的style</span><br>    <span class="hljs-title function_">getTransform</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`translate3d(0,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.startOffset&#125;</span>px,0)`</span>;<br>    &#125;,<br>    <span class="hljs-comment">//获取真实显示列表数据</span><br>    <span class="hljs-title function_">visibleData</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">listData</span>.<span class="hljs-title function_">slice</span>(<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span>,<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listData</span>.<span class="hljs-property">length</span>)<br>      );<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.$el 表示当前组件的根节点，这里是 infinite-list-container</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenHeight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">clientHeight</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;<br>  &#125;,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-comment">//可视区域高度</span><br>      <span class="hljs-attr">screenHeight</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-comment">//偏移量</span><br>      <span class="hljs-attr">startOffset</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-comment">//起始索引</span><br>      <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-comment">//结束索引</span><br>      <span class="hljs-attr">end</span>: <span class="hljs-literal">null</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">scrollEvent</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">//当前滚动位置</span><br>      <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span>;<br><br>      <span class="hljs-comment">//此时的开始索引（向下取整），itemSize 是 100</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>);<br>      <span class="hljs-comment">//此时的结束索引</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;<br><br>      <span class="hljs-comment">//此时的偏移量</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">startOffset</span> = scrollTop - (scrollTop % <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemSize</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-container&quot;</span> @<span class="hljs-attr">scroll</span>=<span class="hljs-string">&quot;scrollEvent($event)&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 所有数据的总高度 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-phantom&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 可视区区域，可以当做滑块看待 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; transform: getTransform &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;items&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in visibleData&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        &#123;&#123; item.value &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.infinite-list-container</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">overflow</span>: auto;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">position</span>: relative;</span></span><br><span class="language-css"><span class="language-xml">  -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.infinite-list-phantom</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.infinite-list</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">text-align</span>: center;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.infinite-list-item</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">color</span>: <span class="hljs-number">#555</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">box-sizing</span>: border-box;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h1 id="列表项动态高度"><a href="#列表项动态高度" class="headerlink" title="列表项动态高度"></a>列表项动态高度</h1><p>在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。</p><p>而实际应用的时候，当列表中包含文本之类的可变内容，会导致 <code>列表项的高度并不相同</code>。</p><p>比如这样：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e1519f1e121be9~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><p>在虚拟列表中应用动态高度的解决方案一般有如下三种：</p><blockquote><p>1.对组件属性itemSize进行扩展，支持传递类型为数字、数组、函数</p></blockquote><ul><li>可以是一个固定值，如 100，此时列表项是固高的</li><li>可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, …]</li><li>可以是一个根据列表项索引返回其高度的函数：(index: number): number</li></ul><p>这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。</p><blockquote><p>2.将列表项 <code>渲染到屏幕外</code>，对其高度进行测量并缓存，然后再将其渲染至可视区域内。</p></blockquote><p>由于 <code>预先渲染至屏幕外</code>，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。</p><blockquote><p>3.以预估高度先行渲染，然后获取真实高度并缓存。</p></blockquote><p>这是可以选择的实现方式，可以避免前两种方案的不足。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能渲染十万条数据(时间分片)</title>
    <link href="/post/time-fragment.html"/>
    <url>/post/time-fragment.html</url>
    
    <content type="html"><![CDATA[<h1 id="最粗暴的做法（一次性渲染"><a href="#最粗暴的做法（一次性渲染" class="headerlink" title="最粗暴的做法（一次性渲染"></a>最粗暴的做法（一次性渲染</h1><p>JS的运行时间为<code>187ms</code>，还是蛮快的，但是最终渲染完成后的总时间确是<code>2844ms</code>，中间会白屏一段时间。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 记录任务开始时间</span><br><span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><span class="hljs-comment">// 插入十万条数据</span><br><span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>;<br><span class="hljs-comment">// 获取容器</span><br><span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>);<br><span class="hljs-comment">// 将数据插入容器中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;<br>  <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>  li.<span class="hljs-property">innerText</span> = i<br>  ul.<span class="hljs-title function_">appendChild</span>(li);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JS运行时间：&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - now);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;总运行时间：&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - now);<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h1><p>页面的卡顿是由于同时渲染大量DOM所引起的，所以考虑将渲染过程分批进行，这里用到的就是 <code>setTimeout</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>);<br><span class="hljs-comment">// 插入十万条数据</span><br><span class="hljs-keyword">let</span> total = <span class="hljs-number">100000</span>;<br><span class="hljs-comment">// 一次插入 20 条</span><br><span class="hljs-keyword">let</span> once = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//总页数</span><br><span class="hljs-keyword">let</span> page = total / once<br><span class="hljs-comment">//每条记录的索引</span><br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//循环加载数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">curTotal, curIndex</span>) &#123;<br>  <span class="hljs-keyword">if</span> (curTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//每页多少条</span><br>  <span class="hljs-keyword">let</span> pageCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(curTotal, once);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++) &#123;<br>      <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>      li.<span class="hljs-property">innerText</span> = curIndex + i + <span class="hljs-string">&#x27; : &#x27;</span> + ~~(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total)<br>      ul.<span class="hljs-title function_">appendChild</span>(li)<br>    &#125;<br>    <span class="hljs-title function_">loop</span>(curTotal - pageCount, curIndex + pageCount)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-title function_">loop</span>(total, index);<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/10/16d18aa76affbeb0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><p>页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象。</p><h2 id="为什么会出现闪屏现象呢"><a href="#为什么会出现闪屏现象呢" class="headerlink" title="为什么会出现闪屏现象呢"></a>为什么会出现闪屏现象呢</h2><p>首先，理清一些概念。FPS表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS是描述帧变化速度的物理量。</p><p>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，FPS为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。</p><p>因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。</p><p>为什么你感觉不到这个变化？</p><p>那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。</p><p>而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，<br>这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p><p>大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。<br>因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。</p><p>直观感受，不同帧率的体验：</p><ul><li>帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；</li><li>帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；</li><li>帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；</li><li>帧率波动很大的动画，亦会使人感觉到卡顿。</li></ul><h2 id="简单聊一下-setTimeout-和闪屏现象"><a href="#简单聊一下-setTimeout-和闪屏现象" class="headerlink" title="简单聊一下 setTimeout 和闪屏现象"></a>简单聊一下 setTimeout 和闪屏现象</h2><ul><li><p>setTimeout的执行时间并不是确定的。在JS中，setTimeout任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此setTimeout的实际执行时间可能会比其设定的时间晚一些。</p></li><li><p>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。</p></li></ul><p>以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。</p><p>在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。</p><h1 id="使用-requestAnimationFrame"><a href="#使用-requestAnimationFrame" class="headerlink" title="使用 requestAnimationFrame"></a>使用 requestAnimationFrame</h1><p>与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。</p><p>如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了<code>1000/75=13.3ms</code>，换句话说就是，<code>requestAnimationFrame</code> 的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。</p><p>将 setTimeout 替换成 requestAnimationFrame:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 其他 ...</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++)&#123;<br>    <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    li.<span class="hljs-property">innerText</span> = curIndex + i + <span class="hljs-string">&#x27; : &#x27;</span> + ~~(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total)<br>    ul.<span class="hljs-title function_">appendChild</span>(li)<br>  &#125;<br>  <span class="hljs-title function_">loop</span>(curTotal - pageCount,curIndex + pageCount)<br>&#125;)<br><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/10/16d18aa76abe9fe3~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p><h1 id="使用-DocumentFragment"><a href="#使用-DocumentFragment" class="headerlink" title="使用 DocumentFragment"></a>使用 DocumentFragment</h1><blockquote><p>DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。可以使用document.createDocumentFragment方法或者构造函数来创建一个空的DocumentFragment</p></blockquote><p>从MDN的说明中，我们得知DocumentFragments是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流（什么是回流? 回流是会导致页面重新渲染的一些元素,从而影响性能）。</p><p>当append元素到document中时，被append进去的元素的样式表的计算是同步发生的，此时调用 getComputedStyle 可以得到样式的计算值。</p><p>而append元素到 documentFragment 中时，是不会计算元素的样式表，所以documentFragment 性能更优。当然现在浏览器的优化已经做的很好了，</p><p>当append元素到document中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 其他 ...</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++)&#123;<br>    <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    li.<span class="hljs-property">innerText</span> = curIndex + i + <span class="hljs-string">&#x27; : &#x27;</span> + ~~(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * total)<br>    fragment.<span class="hljs-title function_">appendChild</span>(li)<br>  &#125;<br>  ul.<span class="hljs-title function_">appendChild</span>(fragment)<br>  <span class="hljs-title function_">loop</span>(curTotal - pageCount,curIndex + pageCount)<br>&#125;)<br><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESM/ESBuild</title>
    <link href="/post/ESM-ESBuild.html"/>
    <url>/post/ESM-ESBuild.html</url>
    
    <content type="html"><![CDATA[<h1 id="ESModule"><a href="#ESModule" class="headerlink" title="ESModule"></a>ESModule</h1><p>继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。</p><p>在浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 原生支持 ESM。</p><blockquote><p><a href="https://www.cnblogs.com/zhaojian-08/p/14385312.html">https://www.cnblogs.com/zhaojian-08/p/14385312.html</a></p></blockquote><h2 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入/导出"></a>导入/导出</h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// esm_index.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hello_world = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><br>&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;<br>  <span class="hljs-keyword">import</span> fn, &#123; hello_world &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./esm_index.js&#x27;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// dynamic-m.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic_value = <span class="hljs-string">&#x27;动态加载&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;default&#x27;</span>)<br>&#125;<br><br><br><span class="hljs-title function_">mport</span>(<span class="hljs-string">&#x27;./dynamic-m.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// module: &#123; default: fn, dynamic_value: &#x27;动态加载&#x27; &#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;动态&#x27;</span>, <span class="hljs-variable language_">module</span>)<br>  &#125;)<br></code></pre></td></tr></table></figure><h1 id="ESBuild"><a href="#ESBuild" class="headerlink" title="ESBuild"></a>ESBuild</h1><blockquote><p><a href="https://esbuild.github.io/api/">https://esbuild.github.io/api/</a></p></blockquote><blockquote><p>介绍: <a href="https://juejin.cn/post/6918927987056312327">https://juejin.cn/post/6918927987056312327</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>ESM ESModule ESBuild</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出TypeScript</title>
    <link href="/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html"/>
    <url>/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="d-ts-和-declare-是干嘛用的"><a href="#d-ts-和-declare-是干嘛用的" class="headerlink" title=".d.ts 和 declare 是干嘛用的"></a>.d.ts 和 declare 是干嘛用的</h2><p>如果一个文件有扩展名 <code>.d.ts</code>，则表示它是一个声明文件，可以用来声明全局的类型定义和接口，或者是其它模块。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// global.d.ts</span><br><br><span class="hljs-comment">// 声明接口</span><br>declare interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-comment">// 声明类型 (别名)</span><br>declare type <span class="hljs-title class_">TName</span> = string;<br><br><span class="hljs-comment">// 声明模块</span><br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.css&#x27;</span>;<br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.less&#x27;</span>;<br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.png&#x27;</span>;<br><br><span class="hljs-comment">// 拓展 window 属性，在 window 对象上显式设置属性</span><br>declare interface <span class="hljs-title class_">Window</span> &#123;<br>  <span class="hljs-title class_">MyNameSpace</span>: any<br>&#125;<br></code></pre></td></tr></table></figure><p>但是也不是说创建了.d.ts文件，里面声明的东西就能生效了，毕竟归根到底也是.ts文件，需要预编译，所以需要在tsconfig.json文件里面的include数组里面添加 <code>global.d.ts</code> 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.d.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.tsx&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.vue&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><code>.d.ts</code> 文件中的顶级声明必须以 “declare” 或 “export” 修饰符开头。通过<code>declare</code>声明的类型或者变量或者模块，在<code>include</code>包含的文件范围内，都可以直接引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .vue setup / .ts</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">me</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alex.cheng&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong><br><code>.d.ts</code>文件顶级声明<code>declare</code>最好不要跟<code>export</code>同级使用，不然在其他<code>ts</code>文件引用这个<code>.d.ts</code>的内容的时候，就需要手动import导入了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">TName</span> = string;<br><br><span class="hljs-comment">// 这个时候，外部 ts 就无法直接使用 Person 了，需要引入 import &#123; Person &#125; from &#x27;../global.d.ts&#x27;</span><br><span class="hljs-keyword">export</span> declare interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="给对象分配动态（未知）属性"><a href="#给对象分配动态（未知）属性" class="headerlink" title="给对象分配动态（未知）属性"></a>给对象分配动态（未知）属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">o</span>: &#123; [<span class="hljs-attr">key</span>: string]: any &#125; = &#123;&#125;<br><br><span class="hljs-comment">// 使用 ts 内置工具 Record，效果同上</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">o</span>: <span class="hljs-title class_">Record</span>&lt;string, any&gt; = &#123;&#125;<br><br>interface <span class="hljs-title class_">IPerson</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;string, any&gt; &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  age?: number;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">me1</span>: <span class="hljs-title class_">IPerson</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alex&#x27;</span>,<br>  <span class="hljs-attr">hair</span>: <span class="hljs-string">&#x27;black&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="interface-和-type-有什么区别"><a href="#interface-和-type-有什么区别" class="headerlink" title="interface 和 type 有什么区别"></a>interface 和 type 有什么区别</h2><ol><li><p><code>接口</code>和<code>类型别名</code>都可以用来描述对象的形状或函数签名。</p></li><li><p>与<code>接口类型</code>不一样的是，<code>类型别名</code>可以用于一些其他类型，比如原始类型、联合类型（<code>|</code>）和元组。</p></li><li><p>接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。</p><p><code>interface</code> 扩展（接口、类型）使用 <code>extends</code> 关键字，类型别名扩展（接口、类型）使用的是 <code>交叉类型（&amp;）</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 接口扩展</span><br>interface <span class="hljs-title class_">IPerson</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>&#125;<br>interface <span class="hljs-title class_">IMe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPerson</span> &#123;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-comment">// 类型扩展</span><br>type <span class="hljs-title class_">TPerson</span> = &#123;<br>  <span class="hljs-attr">name</span>: string;<br>&#125;<br>type <span class="hljs-title class_">TMe</span> = <span class="hljs-title class_">TPerson</span> &amp; &#123;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类可以以相同的方式实现(<code>implements</code>)接口或类型别名，但类不能实现使用类型别名定义的联合类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Error:</span><br>type <span class="hljs-title class_">PartialPoint</span> = &#123; <span class="hljs-attr">x</span>: number; &#125; | &#123; <span class="hljs-attr">y</span>: number; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> implements <span class="hljs-title class_">PartialPoint</span> &#123; <span class="hljs-comment">// 类只能实现具有静态已知成员的对象类型或对象类型的交集。ts(2422)</span><br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// Success</span><br>type <span class="hljs-title class_">PartialPoint</span> = &#123; <span class="hljs-attr">x</span>: number; &#125; &amp; &#123; <span class="hljs-attr">y</span>: number; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> implements <span class="hljs-title class_">PartialPoint</span> &#123;<br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">IMerge</span> &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>;<br>&#125;<br>interface <span class="hljs-title class_">IMerge</span> &#123;<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">ab</span>: <span class="hljs-title class_">IMerge</span> = &#123;&#125;; <span class="hljs-comment">// 类型“&#123;&#125;”缺少类型“IMerge”中的以下属性: a, bts(2739)</span><br><br><br><span class="hljs-comment">// Error: 标识符“TOne”重复。ts(2300)</span><br>type <span class="hljs-title class_">TOne</span> = string;<br>type <span class="hljs-title class_">TOne</span> = number;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><ol><li>typeof</li><li>instanceof</li><li>in</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6872111128135073806">TS 学习指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解TypeScript</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端开发实践</title>
    <link href="/post/app-h5.html"/>
    <url>/post/app-h5.html</url>
    
    <content type="html"><![CDATA[<h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发，它具备开发周期短、灵活性好的优点，但是缺点也很明显，加载速度慢 &amp; 消耗流量。引起缺点的主要原因如下：</p><ol><li>js解析效率，以及手机硬件设备的性能</li><li>页面资源的下载（图片、js文件、css文件）</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903673697402887">Android Webview H5 秒开方案实现</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>RN H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何编写高标准的 JavaScript 代码</title>
    <link href="/post/js-advice.html"/>
    <url>/post/js-advice.html</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>你是否曾经为了提供一个简单的应用解决方案而彻夜地查看源代码？<br>你是否曾经为了理解某个框架而冥思苦想、阅览群书？<br>你是否曾经为了提升0.1s的DOM性能而对多种实现方案进行严格测试和对比？<br>你是否曾经为了避免兼容问题而遍寻高手共同“诊治”？</p><p>跟我一起，专注高质量 <code>JavaScript</code> 代码，少出 <code>Bug🐛</code>，早下班 !</p><blockquote><p>期望为读者带来如下帮助 📚：</p></blockquote><p>  ❑ 能写出简单、清晰、高效的代码。<br>  ❑ 能搭建一个稳定、健壮、快捷的应用框架。<br>  ❑ 能回答一个困扰很多人的技术问题。<br>  ❑ 能修复一个应用开发中遇到的大的Bug。<br>  ❑ 能非常熟悉某个开源产品。<br>  ❑ 能提升客户端应用性能。</p><h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><p>代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。</p><h3 id="减少全局变量"><a href="#减少全局变量" class="headerlink" title="减少全局变量"></a>减少全局变量</h3><ol><li><p>多个全局变量都追加在一个名称空间下，将显著降低与其他应用程序产生冲突的概率</p> <figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> namespace = &#123;&#125;<br><br>namespace.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;my namespace&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>使用闭包体将信息隐藏，它是另一种有效减少“全局污染”的方法。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sayName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;closure&#x27;</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(name)<br>  &#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>作用域控制着变量与参数的可见性及生命周期。</p><p> JavaScript支持函数作用域，定义在函数中的参数和变量在函数外部是不可见的，并且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。它不仅减少了名称冲突，并且提供了自动内存管理。</p></li><li><p>ES6 模块化编程中每个 js 文件内部定义的变量，外部无法获取。如果外部需要模块内部变量，通过 export 导出。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-keyword">var</span> windowA = <span class="hljs-string">&#x27;window a&#x27;</span><br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">windowA</span>) <span class="hljs-comment">// 输出 &#x27;window a&#x27;</span><br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">var</span> moduleA = <span class="hljs-string">&#x27;module a&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">moduleA</span>) <span class="hljs-comment">// 输出 undefined</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="谨慎JS数据类型"><a href="#谨慎JS数据类型" class="headerlink" title="谨慎JS数据类型"></a>谨慎JS数据类型</h3><p>在自动转换数据类型时，JavaScript一般遵循：如果某个类型的值被用于需要其他类型的值的环境中，JavaScript就自动将这个值转换成所需要的类型。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>慎用JavaScript类型自动转换，注意<code>自动转换规则</code>:</p><ol><li><p>如果把非空对象用在逻辑运算环境中，则对象被转换为true。此时的对象包括所有类型的对象，即使是值为false的包装对象也被转换为true。</p></li><li><p>果把对象用在数值运算环境中，则对象会被自动转换为数字，如果转换失败，则返回值为NaN。</p></li><li><p>当数组被用在数值运算环境中时，数组将根据包含的元素来决定转换的值。如果数组为空数组，则被转换为数值0。如果数组仅包含一个数字元素，则被转换为该数字的数值。如果数组包含多个元素，或者仅包含一个非数字元素，则返回NaN。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br>obj &amp;&amp; <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span><br>obj + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-string">&#x27;[object Object]1&#x27;</span><br><br>obj.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">99</span> &#125;<br>obj + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 数组自动转换规则</span><br>+[] &gt;&gt; <span class="hljs-number">0</span><br>+[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span><br>+[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ol><li><p><code>typeof</code><br>对于任何变量来说，使用typeof运算符总是以字符串的形式返回以下6种类型之一：<br>❑ “number”<br>❑ “string”<br>❑ “boolean”<br>❑ “object”<br>❑ “function”<br>❑ “undefined”</p><p>令人疑惑的是，在使用 <code>typeof</code> 检测null值时，返回的是“object”，而不是“null”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> &gt;&gt; <span class="hljs-string">&#x27;object&#x27;</span><br><br><span class="hljs-keyword">typeof</span> [] &gt;&gt; <span class="hljs-string">&#x27;object&#x27;</span><br><br><span class="hljs-keyword">typeof</span> &#123;&#125; &gt;&gt; <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><code>instanceof</code></p><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的<code>原型链</code>上。</p><p>这个在判断对象时存在一些不确定性，来看下例子：</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span> &gt;&gt; <span class="hljs-literal">true</span><br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &gt;&gt; <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再看一个🌰:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;hello child&#x27;</span>)<br><br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span> &gt;&gt; <span class="hljs-literal">true</span><br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &gt;&gt; <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果是判断数组呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> &gt;&gt; <span class="hljs-literal">true</span><br><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &gt;&gt; <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 当然这种方式存在不确定性，我们可以使用 Array.isArray() 方法来判断</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([]) &gt;&gt; <span class="hljs-literal">true</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(&#123;&#125;) &gt;&gt; <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>从上面例子可以看出，使用 <code>instanceof</code> 来判断时存在种种不确定性，只要出现在原型链上的对象都会返回 <code>true</code>，使用的时候还需要着重注意！</p><p>为什么会这样，想必大家应该想起来了！</p><p><strong>Object类是所有对象类型的的父类!</strong></p></li><li><p><code>toString() 方法</code></p><blockquote><p>每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。</p></blockquote><p>toString() 方法，它定义在 Object 的原型对象上，对象在调用时会返回一个表示该对象的字符串。</p><p>使用 <code>toString()</code> 方法检测对象类型是最安全、最准确的。调用toString()方法把对象转换为字符串，然后通过检测字符串中是否包含数组所特有的标志字符可以确定对象的类型。</p><p>为什么说 <code>toString</code> 方法用来检测对象类型是最安全、最准确的，我们慢慢来看吧~</p><p>先看看在对象上直接使用 <code>toString</code>会是什么结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br>obj.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br><br><span class="hljs-comment">// 如果是数组的话，则输出字符串</span><br>arr.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;1,2&#x27;</span><br><br><br><span class="hljs-comment">// 当然我们可以重写/覆盖原型链上的 toString 方法</span><br>obj.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overwrite&#x27;</span><br>&#125;<br>obj.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;overwrite&#x27;</span><br></code></pre></td></tr></table></figure><p>既然 toString 方法定义在原型对象上，我们看看如果单独调用它，会是什么结果呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure><p>如果通过 <code>call/apply</code> 方法，改变 <code>toString</code> 方法内部的 <code>this</code> 执行，又会是什么结果呢?</p><p>看到如下结果，我相信这绝对可以完美 cover 住项目里面所有的类型判断了！所以说它是最安全、最准确的类型判断，没有异议吧😏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;) &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]) &gt;&gt; <span class="hljs-string">&#x27;[object Array]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;) &gt;&gt; <span class="hljs-string">&#x27;[object Function]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) &gt;&gt; <span class="hljs-string">&#x27;[object String]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Number]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Boolean]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Null]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) &gt;&gt; <span class="hljs-string">&#x27;[object Undefined]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>() &gt;&gt; <span class="hljs-string">&#x27;[object Undefined]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) &gt;&gt; <span class="hljs-string">&#x27;[object Date]&#x27;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-regexp">/at/</span>) &gt;&gt; <span class="hljs-string">&#x27;[object RegExp]&#x27;</span><br><br></code></pre></td></tr></table></figure><p>那么它是如何做到的呢，我们来扒一扒它的原理！在 <code>toString</code> 方法被调用时，会执行以下几个操作步骤:</p><ol><li>获取this指向的那个对象的<code>[[Class]]</code>属性的值。（<code>call/apply</code> 改变 this 指向）</li><li>计算出三个字符串”[object “、 第一步的操作结果、 以及 “]” 连接后的新字符串。</li><li>返回第二步的操作结果，也就是类似 <code>&#39;[object Type]&#39;</code> 这种格式字符串。</li></ol><p>需要注意的是，对象的<code>[[Class]]</code>属性是无法直接访问的，它一个内部属性，所有的对象(原生对象和宿主对象)都拥有该属性，且不能被任何人修改。在规范中，<code>[[Class]]</code>是这么定义的：<code>内部属性</code>描述。</p><p>如果要单独或者对象的 <code>[[Class]]</code>，我们可以这样做:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> targetObj = []<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(targetObj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-string">&#x27;Array&#x27;</span><br></code></pre></td></tr></table></figure><p>既然它如此好用，难道就没有缺点吗？</p><p>答案是当然有的，毕竟凡事都不可能那么绝对的嘛！</p><p>那么缺点是什么呢？<br>第一，<code>toString()</code> 会进行装箱操作，产生很多临时对象。（装箱就是将基本类型的数据，通过引用类型包装起来，从而可以使用引用类上的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 你肯定不能这样用</span><br><span class="hljs-number">1.</span><span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-title class_">SyntaxError</span>: <span class="hljs-title class_">Invalid</span> or unexpected token<br><br><span class="hljs-comment">// 你必须这样用</span><br>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>() &gt;&gt; <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>第二，无法区分自定义对象类型，用来判断这类对象时，返回的都是<code>Object</code>，这样我们就需要通过 <code>instanceof</code> 来判断了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(p) &gt;&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript解释器强制约定字符串在堆区存储的数据是不可变的，也就是说，JavaScript解释器强制约定字符串在堆区存储的数据是不可变的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript, ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks</title>
    <link href="/post/react-hooks.html"/>
    <url>/post/react-hooks.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p></blockquote><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><h1 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h1><ol><li>只在最顶层使用 Hook</li><li>只在 React 函数中调用 Hook。（或：在自定义 Hook 中调用其他 Hook）</li></ol><h1 id="使用-useCallback、useMemo、memo-做性能优化"><a href="#使用-useCallback、useMemo、memo-做性能优化" class="headerlink" title="使用 useCallback、useMemo、memo 做性能优化"></a>使用 useCallback、useMemo、memo 做性能优化</h1><p>尽可能的保证组件不去发生变化，发生变化的因素有：<code>state、props、context</code>。</p><p>那么 <code>React</code> 是如何比较这三者的呢？ 答案是 <code>内存地址</code>。</p><p>比如说，对比一个 <code>function</code>，对比的就是这个函数在内存中的地址，通过地址的判断，从而判断 props 是否发生了改变。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><blockquote><p><a href="https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate">https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate</a></p></blockquote><p>React.memo 包裹一个组件，来对它的 props 进行浅比较。等效于 PureComponent，但它只比较 props。（也可以通过第二个参数指定一个<code>自定义的比较函数</code>来比较新旧 props。如果函数返回 true，就会跳过更新。）</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不使用 memo，每一次 setCount，都会造成 Child 组件重新 render</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>Child component<span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Demo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count =&gt; count + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-comment">// 通过 memo 包裹后，Child 组件不会再重新 render了。</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>Child component<span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;)<br></code></pre></td></tr></table></figure><p>当 memo 感知 props 没有发生改变时，不会重新 render 组件。如果传入 count 进来，Child组件就会重新 render。</p><p>总结：</p><ol><li>如果我们将 setCount 当做 prop 传入进来，Child 不会重新render（<code>因为 setCount 在内存中的地址没有发生改变</code>）</li><li>如果传入我们自己定义的方法 (fn)进来，Child会重新 render，因为 Demo 组件每次更新 count 后，重新生成了 fn 函数。</li><li>只是传了个 fn ，不想让 Child 组件更新怎么办？那就要用到 <code>useCallback</code> 钩子了</li></ol><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只有当 count 发生变化时，才会重新计算</span><br><span class="hljs-keyword">const</span> computedCount = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> count * <span class="hljs-number">2</span><br>&#125;, [count])<br></code></pre></td></tr></table></figure><p><code>useMemo</code> 也允许你跳过一次子节点的昂贵的重新渲染，比如组件初始化时，需要一次大量的计算，后续就不会再改变了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">&#123; a, b &#125;</span>) &#123;<br>  <span class="hljs-comment">// Only re-rendered if `a` changes:</span><br>  <span class="hljs-keyword">const</span> child1 = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child1</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&#123;a&#125;</span> /&gt;</span></span>, [a]);<br>  <span class="hljs-comment">// Only re-rendered if `b` changes:</span><br>  <span class="hljs-keyword">const</span> child2 = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> <span class="hljs-attr">b</span>=<span class="hljs-string">&#123;b&#125;</span> /&gt;</span></span>, [b]);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      &#123;child1&#125;</span><br><span class="language-xml">      &#123;child2&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。</p><p>下面这个例子，即使我们用 <code>memo</code> 包裹了组件，因为 <code>setCount</code> 每次会引起 Demo 组件重新 render，<code>生成了新的 fn 函数</code>(内存地址发生了变化)，导致 Child 也会重新 render。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">IChild</span> &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">Dispatch</span>&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">SetStateAction</span>&lt;number&gt;&gt;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props: IChild</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>Child component<span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Demo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;is fn&#x27;</span>)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count =&gt; count + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">&#123;fn&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不想让 fn 函数的 <code>内存地址</code> 发生变化，怎么办呢？使用 <code>useCallback</code> 钩子将其包裹起来即可。</p><p><code>注意：useMemo 也可以这样用，缓存 fn，从而使得 Child 组件不会重复 render。</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 省略...</span><br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;is fn&#x27;</span>)<br>&#125;, [])<br><br><span class="hljs-comment">// 省略...</span><br></code></pre></td></tr></table></figure><p>这样 <code>fn</code> 函数就是一个缓存函数了，即使 count 不停的发生变化，也不会造成 Child 组件重复 render。</p><p><em>总结:</em></p><ol><li>当 Demo 组件内部 state 发生了改变引起 Demo 和 Child 组件重新 render</li><li>并且 Child 组件接受了一个来自 Demo 组件自定义的方法（fn）</li><li>如果不希望 Child 组件重新 render，那么就需要用 useCallback 钩子将自定义方法 <code>fn</code> 包裹起来</li><li>因为 Child 组件 props 里面的 fn 和 useCallback 返回的 fn 指向的是内存中的同一个地址，那么 Child 组件就不会更新</li><li>useCallback 返回新函数的条件是：依赖项（第二个参数）发生了改变。</li><li>如果说我们的 Child 组件，本身就是需要根据 count 变化而变化，那么就不需要加这个缓存 API了，反而增加其计算负担。</li></ol><h2 id="设计组件"><a href="#设计组件" class="headerlink" title="设计组件"></a>设计组件</h2><p>不要为了使用钩子，过渡的使用钩子，好的页面设计，也许用不上这些钩子。</p><p><code>把不变的组件和变化的组件抽离出来！</code></p><p>比如可以把 count 相关部分抽离成一个 Count 组件，使其和 Child 组件同层级排列，Count 组件和 Child 组件分开了，也不会引起 Child 组件做多余的 render。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">Count</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&#123;fn&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p>或者是通过 props.children 渲染 Child，也不会造成 Child 重新 render。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Count</span> = (<span class="hljs-params">props: any</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count =&gt; count + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;/* children 不会重新 render */&#125;</span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Demo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// fn 永远不会变化</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Count</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">&#123;fn&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Count</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useRef-createRef"><a href="#useRef-createRef" class="headerlink" title="useRef / createRef"></a>useRef / createRef</h2><blockquote><p>访问 DOM 节点</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> inputEle = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-keyword">const</span> inputEle = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br><br>inputEle.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br><br></code></pre></td></tr></table></figure><h3 id="测量-DOM节点？"><a href="#测量-DOM节点？" class="headerlink" title="测量 DOM节点？"></a>测量 DOM节点？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> getHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">node: HTMLObjectElement</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>      <span class="hljs-title function_">setHeight</span>(node.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">height</span>)<br>    &#125;<br>  &#125;<br>&#125;, [])<br><br><span class="hljs-comment">// 或者</span><br><br><span class="hljs-keyword">const</span> getHeight = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">node: HTMLObjectElement</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (node) &#123;<br>    <span class="hljs-title function_">setHeight</span>(node.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">height</span>)<br>  &#125;<br>&#125;, [])<br><br></code></pre></td></tr></table></figure><p><code>将 ref 逻辑抽离成一个 Hook</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// hook</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useClientRect</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [rect, setRect] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>      <span class="hljs-title function_">setRect</span>(node.<span class="hljs-title function_">getBoundingClientRect</span>())<br>    &#125;<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> [rect, ref]<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><br><span class="hljs-keyword">const</span> [rect, ref] = <span class="hljs-title function_">useClientRect</span>()<br><br>&lt;h1 ref=&#123;ref&#125;&gt;是 <span class="hljs-variable constant_">H1</span> 标签 &#123;count&#125;&lt;/h1&gt;<br>&#123;<br>  rect &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;rect.height&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h3><blockquote><p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span><br>))<br><br><span class="hljs-comment">// 这样可以拿到 input 元素了</span><br><span class="hljs-keyword">const</span> inputEle = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>&lt;<span class="hljs-title class_">FancyInput</span> ref=&#123;inputEle&#125; /&gt;<br><br></code></pre></td></tr></table></figure><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><blockquote><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br><br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;,<br>    alert () &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br>&#125;)<br><br><br><span class="hljs-keyword">const</span> inputEle = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>&lt;<span class="hljs-title class_">FancyInput</span> ref=&#123;inputEle&#125; /&gt;<br><br><br><span class="hljs-comment">// 通过 inputEle 获取到 useImperativeHandle 定义的方法</span><br>inputEle.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br><br>inputEle.<span class="hljs-property">current</span>.<span class="hljs-title function_">alert</span>()<br><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://ahooks.js.org/zh-CN/">ahooks 官网</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>React，Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello_AlexCc</title>
    <link href="/post/first-article.html"/>
    <url>/post/first-article.html</url>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><blockquote><p>This is my first Blog.</p></blockquote><h3 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello_AlexCc!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ヾ(◍°∇°◍)ﾉﾞ&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>One</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
