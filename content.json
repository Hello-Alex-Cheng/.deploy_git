{"meta":{"title":"Hello_AlexCc","subtitle":"No pains, no gains.","description":"Technology Blog","author":"Hello_AlexCc","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About ME","date":"2022-03-30T02:53:37.000Z","updated":"2022-03-31T02:37:39.820Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"StoryA long time ago … A cat is sleeping，very very deep sleeping… Suddently, He find a mouse … God damn it, a so cute mouse! He don’t want to eat he, play with he."},{"title":"","date":"2022-11-30T03:01:38.680Z","updated":"2022-11-23T08:23:21.958Z","comments":false,"path":"demo/ObserverMode.html","permalink":"http://yoursite.com/demo/ObserverMode.html","excerpt":"","text":"观察者模式 ul { background-color: antiquewhite; } li { background-color: aqua; margin-top: 12px; } 面包屑 1 2 3 // 目标 class Subject { constructor() { this.observers = [] } add(ob) { this.observers.push(ob) } notify(text) { this.observers.forEach(o => { o.update(text) }) } } // 观察者 class Observer { constructor(name) { this.ele = document.querySelector(name) } update(text) { this.ele.innerHTML = text } } const s = new Subject() const o1 = new Observer('.bread') s.add(o1) let oLi = document.querySelectorAll('.left li') for (let i = 0; i < oLi.length; i++) { oLi[i].onclick = function () { s.notify(this.innerHTML) } }"},{"title":"","date":"2022-11-30T03:01:38.694Z","updated":"2022-11-23T12:48:03.716Z","comments":false,"path":"demo/timeFragment.html","permalink":"http://yoursite.com/demo/timeFragment.html","excerpt":"","text":"时间分片 // 记录任务开始时间 let now = Date.now(); // 插入十万条数据 const total = 100000; // 获取容器 let ul = document.getElementById('container'); // 将数据插入容器中 for (let i = 0; i < total; i++) { let li = document.createElement('li'); li.innerText = i ul.appendChild(li); } console.log('JS运行时间：', Date.now() - now); setTimeout(() => { console.log('总运行时间：', Date.now() - now); }, 0) // // --------- 分批渲染 --------- // //需要插入的容器 // let ul = document.getElementById('container'); // // 插入十万条数据 // let total = 100000; // // 一次插入 20 条 // let once = 20; // //总页数 // let page = total / once // //每条记录的索引 // let index = 0; // //循环加载数据 // function loop(curTotal, curIndex) { // if (curTotal { // for (let i = 0; i < pageCount; i++) { // let li = document.createElement('li'); // li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total) // ul.appendChild(li) // } // loop(curTotal - pageCount, curIndex + pageCount) // }, 0) // } // loop(total, index);"},{"title":"","date":"2022-11-30T03:05:16.656Z","updated":"2022-11-30T03:05:16.656Z","comments":false,"path":"demo/resizeObserver.html","permalink":"http://yoursite.com/demo/resizeObserver.html","excerpt":"","text":"Resize observer text test html { height: 100%; font-family: 'helvetica neue', arial, sans-serif; } body { height: inherit; margin: 0; display: flex; justify-content: center; align-items: center; } body>div { background-color: #eee; border: 1px solid #ccc; padding: 20px; width: 50%; min-width: 320px; } h1 { margin: 0; } p { line-height: 1.5; } form { width: 100%; } form>div { display: flex; } form label { flex: 2; } form input { flex: 3; } input[type=\"checkbox\"] { height: 2rem; } So what happened? https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver 记住，不要做任何影响任何事情的事情，除非事实证明你应该这么做，那样的话，看在上帝的份上，不要不做！我的灵魂！我不想被救。你们不是圣诞老人！你们都不是机器人。我得想办法逃离年轻时可怕的摧残。突然间，我每三个小时就要上一次厕所。社保局的那些混蛋也不再给我寄支票了。现在我得付钱给他们！ Observer enabled: Adjust width: if (window.ResizeObserver) { const h1Elem = document.querySelector('h1'); const pElem = document.querySelector('p'); const divElem = document.querySelector('body > div'); const slider = document.querySelector('input[type=\"range\"]'); const checkbox = document.querySelector('input[type=\"checkbox\"]'); divElem.style.width = '600px'; slider.addEventListener('input', () => { divElem.style.width = slider.value + 'px'; }) const resizeObserver = new ResizeObserver(entries => { console.log('entries', entries) for (let entry of entries) { if (entry.contentBoxSize) { // The standard makes contentBoxSize an array... if (entry.contentBoxSize[0]) { h1Elem.style.fontSize = Math.max(1.5, entry.contentBoxSize[0].inlineSize / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentBoxSize[0].inlineSize / 600) + 'rem'; } else { // ...but old versions of Firefox treat it as a single item h1Elem.style.fontSize = Math.max(1.5, entry.contentBoxSize.inlineSize / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentBoxSize.inlineSize / 600) + 'rem'; } } else { h1Elem.style.fontSize = Math.max(1.5, entry.contentRect.width / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentRect.width / 600) + 'rem'; } } console.log('Size changed'); }); resizeObserver.observe(divElem); checkbox.addEventListener('change', () => { if (checkbox.checked) { resizeObserver.observe(divElem); } else { resizeObserver.unobserve(divElem); } }); } else { console.log('Resize observer not supported!'); }"},{"title":"","date":"2022-11-30T03:01:38.689Z","updated":"2022-11-23T09:03:02.974Z","comments":false,"path":"demo/PubSubMode.html","permalink":"http://yoursite.com/demo/PubSubMode.html","excerpt":"","text":"发布订阅者模式 ul { background-color: antiquewhite; } li { background-color: aqua; margin-top: 12px; } 面包屑 1 2 3 const PubSub = { message: {}, // 将事件存储数组，改成对象，key 表示事件类型，value 表示订阅的事件数组 publist(type, text) { if (!this.message[type]) return this.message[type].forEach(cb => { cb(text) }) }, subscribe(type, cb) { if (!this.message[type]) { this.message[type] = [cb] // 如果事件 type 不存在，我们就创建一个事件类型数组 } else { this.message[type].push(cb) } }, unsubscribe(type, cb) { // 取消订阅 if (!this.message[type]) return if (!cb) { // 取消所有订阅的事件 this.message[type] = [] } else { this.message[type] = this.message[type].filter(i => i !== cb) } } } PubSub.subscribe('updateBread', function (text) { const breadEle = document.querySelector('.bread') breadEle.innerHTML = text }) let oLi = document.querySelectorAll('.left li') for (let i = 0; i < oLi.length; i++) { oLi[i].onclick = function () { PubSub.publist('updateBread', this.innerHTML) } }"}],"posts":[{"title":"高性能渲染十万条数据(虚拟列表)","slug":"virtual-list","date":"2022-11-23T12:43:13.000Z","updated":"2022-11-28T03:19:11.257Z","comments":true,"path":"/post/virtual-list.html","link":"","permalink":"http://yoursite.com/post/virtual-list.html","excerpt":"使用虚拟列表的方式，来同时加载大量数据。","text":"前言在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。 时间分片 提到了可以使用时间分片的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用虚拟列表的方式，来同时加载大量数据。 当我们渲染10w条数据时，其实主要是的时间花费在 Recalculate Style 和 Layout 上 Recalculate Style：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。 Layout：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。 在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。 那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在Recalculate Style和Layout阶段消耗大量的时间。 而虚拟列表就是解决这一问题的一种实现。 什么是虚拟列表虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。 假设有1万条记录需要同时渲染，我们屏幕的可见区域的高度为1000px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到20个列表项，那么在首次渲染的时候，我们只需加载20条即可。 说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。 假设滚动发生，滚动条距顶部的位置为150px,则我们可得知在可见区域内的列表项为第4项至`第13项。 实现虚拟列表的实现，实际上是在首屏加载的时候，只加载 可视区域 内需要的列表项，当滚动发生时，通过计算动态获得可视区域内的列表项，并将非可视区域内存在的列表项删除。 计算当前可视区域起始数据索引（startIndex） 计算当前可视区域结束数据索引（endIndex） 计算当前可视区域的数据，并渲染到页面中 计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上 由于只是对可视区域内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构： 1234567891011121314151617181920&lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;!-- 所有数据的总高度 --&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 可视区区域，可以当做滑块看待 --&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;!-- 每一项数据 --&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.value &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 接着，监听infinite-list-container的 scroll事件，获取滚动位置 scrollTop。 列表总高度 listHeight = listData.length * itemSize 可显示的列表项数 visibleCount = Math.ceil(screenHeight / itemSize) 数据的起始索引 startIndex = Math.floor(scrollTop / itemSize) 数据的结束索引 endIndex = startIndex + visibleCount 列表显示数据为 visibleData = listData.slice(startIndex,endIndex) 12345678910111213scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引（向下取整），itemSize 是 100 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize);&#125;, 当滚动后，由于 渲染区域 相对于 可视区域 已经发生了偏移，此时我需要获取一个 偏移量startOffset，通过样式控制将渲染区域偏移至可视区域中，当用户在滑动时，渲染区域就会根据 startOffset 计算出偏移量，渲染区域就会一直在可视区域内呈现。 1234567this.startOffset = scrollTop - (scrollTop % this.itemSize);// computed//偏移量对应的stylegetTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`;&#125;, 完整代码12345678910111213141516&lt;style&gt; html&#123; height: 100%; &#125; body&#123; height: 100%; margin:0; &#125; #app&#123; height:100%; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;VirtualList :listData=&quot;state.data&quot; :itemSize=&quot;100&quot; /&gt;&lt;/div&gt; VirtualList comp. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;script&gt;export default &#123; name: &quot;VirtualList&quot;, props: &#123; //所有列表数据 listData: &#123; type: Array, default: () =&gt; [], &#125;, //每项高度 itemSize: &#123; type: Number, default: 200, &#125;, &#125;, computed: &#123; //列表总高度 listHeight() &#123; return this.listData.length * this.itemSize; &#125;, //可显示的列表项数 visibleCount() &#123; // 向上取整: Math.ceil(13.06) =&gt; 14，表示整个屏幕，可以放 14 条数据 return Math.ceil(this.screenHeight / this.itemSize); &#125;, //偏移量对应的style getTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`; &#125;, //获取真实显示列表数据 visibleData() &#123; return this.listData.slice( this.start, Math.min(this.end, this.listData.length) ); &#125;, &#125;, mounted() &#123; // this.$el 表示当前组件的根节点，这里是 infinite-list-container this.screenHeight = this.$el.clientHeight; this.start = 0; this.end = this.start + this.visibleCount; &#125;, data() &#123; return &#123; //可视区域高度 screenHeight: 0, //偏移量 startOffset: 0, //起始索引 start: 0, //结束索引 end: null, &#125;; &#125;, methods: &#123; scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引（向下取整），itemSize 是 100 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;!-- 所有数据的总高度 --&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 可视区区域，可以当做滑块看待 --&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.value &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.infinite-list-container &#123; height: 100%; overflow: auto; position: relative; -webkit-overflow-scrolling: touch;&#125;.infinite-list-phantom &#123; position: absolute; left: 0; top: 0; right: 0; z-index: -1;&#125;.infinite-list &#123; left: 0; right: 0; top: 0; position: absolute; text-align: center;&#125;.infinite-list-item &#123; padding: 10px; color: #555; box-sizing: border-box; border-bottom: 1px solid #999;&#125;&lt;/style&gt; 列表项动态高度在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。 而实际应用的时候，当列表中包含文本之类的可变内容，会导致 列表项的高度并不相同。 比如这样： 在虚拟列表中应用动态高度的解决方案一般有如下三种： 1.对组件属性itemSize进行扩展，支持传递类型为数字、数组、函数 可以是一个固定值，如 100，此时列表项是固高的 可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, …] 可以是一个根据列表项索引返回其高度的函数：(index: number): number 这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。 2.将列表项 渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内。 由于 预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。 3.以预估高度先行渲染，然后获取真实高度并缓存。 这是可以选择的实现方式，可以避免前两种方案的不足。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"高性能渲染十万条数据(时间分片)","slug":"time-fragment","date":"2022-11-23T11:53:52.000Z","updated":"2022-11-23T12:52:27.198Z","comments":true,"path":"/post/time-fragment.html","link":"","permalink":"http://yoursite.com/post/time-fragment.html","excerpt":"渲染大量数据。","text":"最粗暴的做法（一次性渲染JS的运行时间为187ms，还是蛮快的，但是最终渲染完成后的总时间确是2844ms，中间会白屏一段时间。 1234567891011121314151617// 记录任务开始时间let now = Date.now();// 插入十万条数据const total = 100000;// 获取容器let ul = document.getElementById(&#x27;container&#x27;);// 将数据插入容器中for (let i = 0; i &lt; total; i++) &#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = i ul.appendChild(li);&#125;console.log(&#x27;JS运行时间：&#x27;, Date.now() - now);setTimeout(() =&gt; &#123; console.log(&#x27;总运行时间：&#x27;, Date.now() - now);&#125;, 0) 使用定时器页面的卡顿是由于同时渲染大量DOM所引起的，所以考虑将渲染过程分批进行，这里用到的就是 setTimeout。 1234567891011121314151617181920212223242526let ul = document.getElementById(&#x27;container&#x27;);// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total / once//每条记录的索引let index = 0;//循环加载数据function loop(curTotal, curIndex) &#123; if (curTotal &lt;= 0) &#123; return false; &#125; //每页多少条 let pageCount = Math.min(curTotal, once); setTimeout(() =&gt; &#123; for (let i = 0; i &lt; pageCount; i++) &#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) ul.appendChild(li) &#125; loop(curTotal - pageCount, curIndex + pageCount) &#125;, 0)&#125;loop(total, index); 页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象。 为什么会出现闪屏现象呢首先，理清一些概念。FPS表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS是描述帧变化速度的物理量。 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，FPS为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。 因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。 为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。 而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。 大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 直观感受，不同帧率的体验： 帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适； 帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异； 帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感； 帧率波动很大的动画，亦会使人感觉到卡顿。 简单聊一下 setTimeout 和闪屏现象 setTimeout的执行时间并不是确定的。在JS中，setTimeout任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此setTimeout的实际执行时间可能会比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。 在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 使用 requestAnimationFrame与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。 如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame 的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。 将 setTimeout 替换成 requestAnimationFrame: 123456789101112// 其他 ...window.requestAnimationFrame(function()&#123; for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) ul.appendChild(li) &#125; loop(curTotal - pageCount,curIndex + pageCount)&#125;)// ... 使用 DocumentFragment DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。可以使用document.createDocumentFragment方法或者构造函数来创建一个空的DocumentFragment 从MDN的说明中，我们得知DocumentFragments是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流（什么是回流? 回流是会导致页面重新渲染的一些元素,从而影响性能）。 当append元素到document中时，被append进去的元素的样式表的计算是同步发生的，此时调用 getComputedStyle 可以得到样式的计算值。 而append元素到 documentFragment 中时，是不会计算元素的样式表，所以documentFragment 性能更优。当然现在浏览器的优化已经做的很好了， 当append元素到document中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后。 1234567891011121314// 其他 ...window.requestAnimationFrame(function()&#123; const fragment = document.createDocumentFragment() for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) loop(curTotal - pageCount,curIndex + pageCount)&#125;)// ...","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ESM/ESBuild","slug":"ESM-ESBuild","date":"2022-09-13T09:11:35.000Z","updated":"2022-09-16T08:40:53.050Z","comments":true,"path":"/post/ESM-ESBuild.html","link":"","permalink":"http://yoursite.com/post/ESM-ESBuild.html","excerpt":"继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。","text":"ESModule继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。 在浏览器中通过 &lt;script type=&quot;module&quot;&gt; 原生支持 ESM。 https://www.cnblogs.com/zhaojian-08/p/14385312.html 导入/导出12345678// esm_index.jsexport const hello_world = 1export default function() &#123;&#125;&lt;script type=&quot;module&quot;&gt; import fn, &#123; hello_world &#125; from &#x27;./esm_index.js&#x27;&lt;/script&gt; 动态加载123456789101112// dynamic-m.jsexport const dynamic_value = &#x27;动态加载&#x27;export default function() &#123; console.log(&#x27;default&#x27;)&#125;mport(&#x27;./dynamic-m.js&#x27;) .then(module =&gt; &#123; // module: &#123; default: fn, dynamic_value: &#x27;动态加载&#x27; &#125; console.log(&#x27;动态&#x27;, module) &#125;) ESBuild https://esbuild.github.io/api/ 介绍: https://juejin.cn/post/6918927987056312327","categories":[],"tags":[{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"}]},{"title":"深入浅出TypeScript","slug":"深入浅出TypeScript","date":"2022-09-09T02:35:36.000Z","updated":"2022-09-13T03:03:59.001Z","comments":true,"path":"/post/深入浅出TypeScript.html","link":"","permalink":"http://yoursite.com/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html","excerpt":"TypeScript","text":"TypeScript.d.ts 和 declare 是干嘛用的如果一个文件有扩展名 .d.ts，则表示它是一个声明文件，可以用来声明全局的类型定义和接口，或者是其它模块。比如： 1234567891011121314151617181920// global.d.ts// 声明接口declare interface Person &#123; name: string; age: number;&#125;// 声明类型 (别名)declare type TName = string;// 声明模块declare module &#x27;*.css&#x27;;declare module &#x27;*.less&#x27;;declare module &#x27;*.png&#x27;;// 拓展 window 属性，在 window 对象上显式设置属性declare interface Window &#123; MyNameSpace: any&#125; 但是也不是说创建了.d.ts文件，里面声明的东西就能生效了，毕竟归根到底也是.ts文件，需要预编译，所以需要在tsconfig.json文件里面的include数组里面添加 global.d.ts 文件。 1&quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;] .d.ts 文件中的顶级声明必须以 “declare” 或 “export” 修饰符开头。通过declare声明的类型或者变量或者模块，在include包含的文件范围内，都可以直接引用。 12345// .vue setup / .tsconst me: Person = &#123; name: &#x27;alex.cheng&#x27;, age: 18&#125; 注意.d.ts文件顶级声明declare最好不要跟export同级使用，不然在其他ts文件引用这个.d.ts的内容的时候，就需要手动import导入了。 12345678// global.d.tsexport type TName = string;// 这个时候，外部 ts 就无法直接使用 Person 了，需要引入 import &#123; Person &#125; from &#x27;../global.d.ts&#x27;export declare interface Person &#123; name: string; age: number;&#125; 给对象分配动态（未知）属性1234567891011121314const o: &#123; [key: string]: any &#125; = &#123;&#125;// 使用 ts 内置工具 Record，效果同上const o: Record&lt;string, any&gt; = &#123;&#125;interface IPerson extends Record&lt;string, any&gt; &#123; name: string; age?: number;&#125;const me1: IPerson = &#123; name: &#x27;alex&#x27;, hair: &#x27;black&#x27;&#125; interface 和 type 有什么区别 接口和类型别名都可以用来描述对象的形状或函数签名。 与接口类型不一样的是，类型别名可以用于一些其他类型，比如原始类型、联合类型（|）和元组。 接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。 interface 扩展（接口、类型）使用 extends 关键字，类型别名扩展（接口、类型）使用的是 交叉类型（&amp;）: 123456789101112131415// 接口扩展interface IPerson &#123; name: string;&#125;interface IMe extends IPerson &#123; age: number;&#125;// 类型扩展type TPerson = &#123; name: string;&#125;type TMe = TPerson &amp; &#123; age: number;&#125; 类可以以相同的方式实现(implements)接口或类型别名，但类不能实现使用类型别名定义的联合类型 12345678910111213// Error:type PartialPoint = &#123; x: number; &#125; | &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; // 类只能实现具有静态已知成员的对象类型或对象类型的交集。ts(2422) x = 1; y = 2;&#125;// Successtype PartialPoint = &#123; x: number; &#125; &amp; &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; x = 1; y = 2;&#125; 与类型别名不同，接口可以定义多次，会被自动合并为单个接口。 123456789101112interface IMerge &#123; a: 1;&#125;interface IMerge &#123; b: 2&#125;const ab: IMerge = &#123;&#125;; // 类型“&#123;&#125;”缺少类型“IMerge”中的以下属性: a, bts(2739)// Error: 标识符“TOne”重复。ts(2300)type TOne = string;type TOne = number; 类型保护 typeof instanceof in 参考资料TS 学习指南 ↩深入理解TypeScript ↩","categories":[],"tags":[{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"}]},{"title":"移动端开发实践","slug":"app-h5","date":"2022-06-09T06:26:40.000Z","updated":"2022-06-09T06:44:26.042Z","comments":true,"path":"/post/app-h5.html","link":"","permalink":"http://yoursite.com/post/app-h5.html","excerpt":"React Native 、H5移动端开发实践","text":"WebView现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发，它具备开发周期短、灵活性好的优点，但是缺点也很明显，加载速度慢 &amp; 消耗流量。引起缺点的主要原因如下： js解析效率，以及手机硬件设备的性能 页面资源的下载（图片、js文件、css文件） 参考资料Android Webview H5 秒开方案实现 ↩","categories":[],"tags":[{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"}]},{"title":"如何编写高标准的 JavaScript 代码","slug":"js-advice","date":"2022-03-31T02:12:23.000Z","updated":"2022-04-08T02:42:23.957Z","comments":true,"path":"/post/js-advice.html","link":"","permalink":"http://yoursite.com/post/js-advice.html","excerpt":"代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。","text":"概述你是否曾经为了提供一个简单的应用解决方案而彻夜地查看源代码？你是否曾经为了理解某个框架而冥思苦想、阅览群书？你是否曾经为了提升0.1s的DOM性能而对多种实现方案进行严格测试和对比？你是否曾经为了避免兼容问题而遍寻高手共同“诊治”？ 跟我一起，专注高质量 JavaScript 代码，少出 Bug🐛，早下班 ! 期望为读者带来如下帮助 📚： ❑ 能写出简单、清晰、高效的代码。 ❑ 能搭建一个稳定、健壮、快捷的应用框架。 ❑ 能回答一个困扰很多人的技术问题。 ❑ 能修复一个应用开发中遇到的大的Bug。 ❑ 能非常熟悉某个开源产品。 ❑ 能提升客户端应用性能。 JavaScript 基础代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。 减少全局变量 多个全局变量都追加在一个名称空间下，将显著降低与其他应用程序产生冲突的概率 123const namespace = &#123;&#125;namespace.name = &#x27;my namespace&#x27; 使用闭包体将信息隐藏，它是另一种有效减少“全局污染”的方法。 1234567const sayName = function() &#123; const name = &#x27;closure&#x27; return function() &#123; alert(name) &#125;&#125;() 作用域控制着变量与参数的可见性及生命周期。 JavaScript支持函数作用域，定义在函数中的参数和变量在函数外部是不可见的，并且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。它不仅减少了名称冲突，并且提供了自动内存管理。 ES6 模块化编程中每个 js 文件内部定义的变量，外部无法获取。如果外部需要模块内部变量，通过 export 导出。 1234567891011&lt;script&gt; var windowA = &#x27;window a&#x27; console.log(window.windowA) // 输出 &#x27;window a&#x27;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; var moduleA = &#x27;module a&#x27; console.log(window.moduleA) // 输出 undefined&lt;/script&gt; 谨慎JS数据类型在自动转换数据类型时，JavaScript一般遵循：如果某个类型的值被用于需要其他类型的值的环境中，JavaScript就自动将这个值转换成所需要的类型。 类型转换慎用JavaScript类型自动转换，注意自动转换规则: 如果把非空对象用在逻辑运算环境中，则对象被转换为true。此时的对象包括所有类型的对象，即使是值为false的包装对象也被转换为true。 果把对象用在数值运算环境中，则对象会被自动转换为数字，如果转换失败，则返回值为NaN。 当数组被用在数值运算环境中时，数组将根据包含的元素来决定转换的值。如果数组为空数组，则被转换为数值0。如果数组仅包含一个数字元素，则被转换为该数字的数值。如果数组包含多个元素，或者仅包含一个非数字元素，则返回NaN。 🌰 123456789101112// 对象const obj = &#123;&#125;obj &amp;&amp; 1 &gt;&gt; 1obj + 1 &gt;&gt; &#x27;[object Object]1&#x27;obj.valueOf = function() &#123; return 99 &#125;obj + 1 &gt;&gt; 100// 数组自动转换规则+[] &gt;&gt; 0+[1] &gt;&gt; 1+[1,2] &gt;&gt; NaN 类型判断 typeof对于任何变量来说，使用typeof运算符总是以字符串的形式返回以下6种类型之一：❑ “number”❑ “string”❑ “boolean”❑ “object”❑ “function”❑ “undefined” 令人疑惑的是，在使用 typeof 检测null值时，返回的是“object”，而不是“null”。 12345typeof null &gt;&gt; &#x27;object&#x27;typeof [] &gt;&gt; &#x27;object&#x27;typeof &#123;&#125; &gt;&gt; &#x27;object&#x27; instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 这个在判断对象时存在一些不确定性，来看下例子： 🌰 123456function Person(name) &#123; this.name = name&#125;const p = new Person(&#x27;hello&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 再看一个🌰: 123456789101112131415function Person(name) &#123; this.name = name&#125;function Child(name) &#123; this.name = name&#125;Child.prototype = Person.prototypeChild.prototype.constructor = Childconst p = new Child(&#x27;hello child&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 如果是判断数组呢? 1234567[] instanceof Array &gt;&gt; true[] instanceof Object &gt;&gt; true// 当然这种方式存在不确定性，我们可以使用 Array.isArray() 方法来判断Array.isArray([]) &gt;&gt; trueArray.isArray(&#123;&#125;) &gt;&gt; false 从上面例子可以看出，使用 instanceof 来判断时存在种种不确定性，只要出现在原型链上的对象都会返回 true，使用的时候还需要着重注意！ 为什么会这样，想必大家应该想起来了！ Object类是所有对象类型的的父类! toString() 方法 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 toString() 方法，它定义在 Object 的原型对象上，对象在调用时会返回一个表示该对象的字符串。 使用 toString() 方法检测对象类型是最安全、最准确的。调用toString()方法把对象转换为字符串，然后通过检测字符串中是否包含数组所特有的标志字符可以确定对象的类型。 为什么说 toString 方法用来检测对象类型是最安全、最准确的，我们慢慢来看吧~ 先看看在对象上直接使用 toString会是什么结果： 1234567891011121314const obj = &#123; a: 1 &#125;const arr = [1, 2]obj.toString() &gt;&gt; &#x27;[object Object]&#x27;// 如果是数组的话，则输出字符串arr.toString() &gt;&gt; &#x27;1,2&#x27;// 当然我们可以重写/覆盖原型链上的 toString 方法obj.toString = function() &#123; return &#x27;overwrite&#x27;&#125;obj.toString() &gt;&gt; &#x27;overwrite&#x27; 既然 toString 方法定义在原型对象上，我们看看如果单独调用它，会是什么结果呢? 1Object.prototype.toString() &gt;&gt; &#x27;[object Object]&#x27; 如果通过 call/apply 方法，改变 toString 方法内部的 this 执行，又会是什么结果呢? 看到如下结果，我相信这绝对可以完美 cover 住项目里面所有的类型判断了！所以说它是最安全、最准确的类型判断，没有异议吧😏 12345678910111213141516171819202122Object.prototype.toString.call(&#123;&#125;) &gt;&gt; &#x27;[object Object]&#x27;Object.prototype.toString.call([]) &gt;&gt; &#x27;[object Array]&#x27;Object.prototype.toString.call(function()&#123;&#125;) &gt;&gt; &#x27;[object Function]&#x27;Object.prototype.toString.call(&#x27;&#x27;) &gt;&gt; &#x27;[object String]&#x27;Object.prototype.toString.call(1) &gt;&gt; &#x27;[object Number]&#x27;Object.prototype.toString.call(true) &gt;&gt; &#x27;[object Boolean]&#x27;Object.prototype.toString.call(null) &gt;&gt; &#x27;[object Null]&#x27;Object.prototype.toString.call(undefined) &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call() &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call(new Date()) &gt;&gt; &#x27;[object Date]&#x27;Object.prototype.toString.call(/at/) &gt;&gt; &#x27;[object RegExp]&#x27; 那么它是如何做到的呢，我们来扒一扒它的原理！在 toString 方法被调用时，会执行以下几个操作步骤: 获取this指向的那个对象的[[Class]]属性的值。（call/apply 改变 this 指向） 计算出三个字符串”[object “、 第一步的操作结果、 以及 “]” 连接后的新字符串。 返回第二步的操作结果，也就是类似 &#39;[object Type]&#39; 这种格式字符串。 需要注意的是，对象的[[Class]]属性是无法直接访问的，它一个内部属性，所有的对象(原生对象和宿主对象)都拥有该属性，且不能被任何人修改。在规范中，[[Class]]是这么定义的：内部属性描述。 如果要单独或者对象的 [[Class]]，我们可以这样做: 12const targetObj = []Object.prototype.toString.call(targetObj).slice(8, -1) &gt;&gt; &#x27;Array&#x27; 既然它如此好用，难道就没有缺点吗？ 答案是当然有的，毕竟凡事都不可能那么绝对的嘛！ 那么缺点是什么呢？第一，toString() 会进行装箱操作，产生很多临时对象。（装箱就是将基本类型的数据，通过引用类型包装起来，从而可以使用引用类上的方法） 12345// 你肯定不能这样用1.toString() &gt;&gt; SyntaxError: Invalid or unexpected token// 你必须这样用(1).toString() &gt;&gt; &#x27;1&#x27; 第二，无法区分自定义对象类型，用来判断这类对象时，返回的都是Object，这样我们就需要通过 instanceof 来判断了。 1234function Person()&#123;&#125;const p = new Person()Object.prototype.toString.call(p) &gt;&gt; &#x27;[object Object]&#x27; 字符串JavaScript解释器强制约定字符串在堆区存储的数据是不可变的，也就是说，JavaScript解释器强制约定字符串在堆区存储的数据是不可变的。 参考资料参考资料 ↩参考资料2 ↩","categories":[],"tags":[{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"}]},{"title":"React Hooks","slug":"react-hooks","date":"2022-03-26T10:41:01.000Z","updated":"2022-09-16T08:22:44.579Z","comments":true,"path":"/post/react-hooks.html","link":"","permalink":"http://yoursite.com/post/react-hooks.html","excerpt":"什么是React Hooks，为什么需要它？如何高效的使用React Hooks？如何自定义 Hooks ？如何通过 Hooks 做性能优化？","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 动机Hook 规则 只在最顶层使用 Hook 只在 React 函数中调用 Hook。（或：在自定义 Hook 中调用其他 Hook） 使用 useCallback、useMemo、memo 做性能优化尽可能的保证组件不去发生变化，发生变化的因素有：state、props、context。 那么 React 是如何比较这三者的呢？ 答案是 内存地址。 比如说，对比一个 function，对比的就是这个函数在内存中的地址，通过地址的判断，从而判断 props 是否发生了改变。 React.memo https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate React.memo 包裹一个组件，来对它的 props 进行浅比较。等效于 PureComponent，但它只比较 props。（也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。） 123456789101112131415161718192021222324// 不使用 memo，每一次 setCount，都会造成 Child 组件重新 renderconst Child = () =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;const Demo = () =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child /&gt; &lt;/&gt; )&#125;// 通过 memo 包裹后，Child 组件不会再重新 render了。const Child = memo(() =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;) 当 memo 感知 props 没有发生改变时，不会重新 render 组件。如果传入 count 进来，Child组件就会重新 render。 总结： 如果我们将 setCount 当做 prop 传入进来，Child 不会重新render（因为 setCount 在内存中的地址没有发生改变） 如果传入我们自己定义的方法 (fn)进来，Child会重新 render，因为 Demo 组件每次更新 count 后，重新生成了 fn 函数。 只是传了个 fn ，不想让 Child 组件更新怎么办？那就要用到 useCallback 钩子了 useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算。 1234// 只有当 count 发生变化时，才会重新计算const computedCount = useMemo(() =&gt; &#123; return count * 2&#125;, [count]) useMemo 也允许你跳过一次子节点的昂贵的重新渲染，比如组件初始化时，需要一次大量的计算，后续就不会再改变了： 123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; )&#125; useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。 下面这个例子，即使我们用 memo 包裹了组件，因为 setCount 每次会引起 Demo 组件重新 render，生成了新的 fn 函数(内存地址发生了变化)，导致 Child 也会重新 render。 123456789101112131415161718192021interface IChild &#123; fn: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;&#125;const Child = memo((props: IChild) =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;)const Demo = () =&gt; &#123; const [count, setCount] = useState(0) const fn = () =&gt; console.log(&#x27;is fn&#x27;) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/&gt; )&#125; 我们不想让 fn 函数的 内存地址 发生变化，怎么办呢？使用 useCallback 钩子将其包裹起来即可。 注意：useMemo 也可以这样用，缓存 fn，从而使得 Child 组件不会重复 render。 1234567// 省略...const fn = useCallback(() =&gt; &#123; console.log(&#x27;is fn&#x27;)&#125;, [])// 省略... 这样 fn 函数就是一个缓存函数了，即使 count 不停的发生变化，也不会造成 Child 组件重复 render。 总结: 当 Demo 组件内部 state 发生了改变引起 Demo 和 Child 组件重新 render 并且 Child 组件接受了一个来自 Demo 组件自定义的方法（fn） 如果不希望 Child 组件重新 render，那么就需要用 useCallback 钩子将自定义方法 fn 包裹起来 因为 Child 组件 props 里面的 fn 和 useCallback 返回的 fn 指向的是内存中的同一个地址，那么 Child 组件就不会更新 useCallback 返回新函数的条件是：依赖项（第二个参数）发生了改变。 如果说我们的 Child 组件，本身就是需要根据 count 变化而变化，那么就不需要加这个缓存 API了，反而增加其计算负担。 设计组件不要为了使用钩子，过渡的使用钩子，好的页面设计，也许用不上这些钩子。 把不变的组件和变化的组件抽离出来！ 比如可以把 count 相关部分抽离成一个 Count 组件，使其和 Child 组件同层级排列，Count 组件和 Child 组件分开了，也不会引起 Child 组件做多余的 render。 12&lt;Count /&gt;&lt;Child prop=&#123;fn&#125; /&gt; 或者是通过 props.children 渲染 Child，也不会造成 Child 重新 render。 12345678910111213141516171819202122const Count = (props: any) =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &#123;/* children 不会重新 render */&#125; &#123;props.children&#125; &lt;/&gt; )&#125;const Demo = () =&gt; &#123; // fn 永远不会变化 const fn = () =&gt; &#123;&#125; return ( &lt;&gt; &lt;Count&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/Count&gt; &lt;/&gt; )&#125; useRef / createRef 访问 DOM 节点 123456const inputEle = useRef(null)const inputEle = React.createRef()inputEle.current.focus() 测量 DOM节点？1234567891011121314151617const getHeight = useMemo(() =&gt; &#123; return (node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125; &#125;&#125;, [])// 或者const getHeight = useCallback((node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125;&#125;, []) 将 ref 逻辑抽离成一个 Hook 1234567891011121314151617181920// hookconst useClientRect = () =&gt; &#123; const [rect, setRect] = useState(null) const ref = useCallback(node =&gt; &#123; if (node) &#123; setRect(node.getBoundingClientRect()) &#125; &#125;, []) return [rect, ref]&#125;// 使用const [rect, ref] = useClientRect()&lt;h1 ref=&#123;ref&#125;&gt;是 H1 标签 &#123;count&#125;&lt;/h1&gt;&#123; rect &amp;&amp; &lt;span&gt;&#123;rect.height&#125;&lt;/span&gt;&#125; React.forwardRef React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。 123456789const FancyInput = forwardRef((props, ref) =&gt; ( &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;))// 这样可以拿到 input 元素了const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt; useImperativeHandle useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 12345678910111213141516171819202122232425const FancyInput = forwardRef((props, ref) =&gt; &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125;, alert () &#123; alert(1) &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;;&#125;)const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt;// 通过 inputEle 获取到 useImperativeHandle 定义的方法inputEle.current.focus()inputEle.current.alert() 参考资料ahooks 官网 ↩","categories":[],"tags":[{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"}]},{"title":"Hello_AlexCc","slug":"first-article","date":"2019-07-29T15:37:50.000Z","updated":"2022-04-07T10:04:40.419Z","comments":true,"path":"/post/first-article.html","link":"","permalink":"http://yoursite.com/post/first-article.html","excerpt":"First Article","text":"What This is my first Blog. No.212345if (true) &#123; console.log(&quot;Hello_AlexCc!&quot;)&#125;return &quot;ヾ(◍°∇°◍)ﾉﾞ&quot;","categories":[],"tags":[{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}],"categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"},{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"},{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"},{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"},{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"},{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}