{"meta":{"title":"Hello_AlexCc","subtitle":"No pains, no gains.","description":"Technology Blog","author":"Hello_AlexCc","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About ME","date":"2022-03-30T02:53:37.000Z","updated":"2022-03-31T02:37:39.820Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"StoryA long time ago … A cat is sleeping，very very deep sleeping… Suddently, He find a mouse … God damn it, a so cute mouse! He don’t want to eat he, play with he."}],"posts":[{"title":"ESM/ESBuild","slug":"ESM-ESBuild","date":"2022-09-13T09:11:35.000Z","updated":"2022-09-16T08:40:53.050Z","comments":true,"path":"/post/ESM-ESBuild.html","link":"","permalink":"http://yoursite.com/post/ESM-ESBuild.html","excerpt":"继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。","text":"ESModule继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。 在浏览器中通过 &lt;script type=&quot;module&quot;&gt; 原生支持 ESM。 https://www.cnblogs.com/zhaojian-08/p/14385312.html 导入/导出12345678// esm_index.jsexport const hello_world = 1export default function() &#123;&#125;&lt;script type=&quot;module&quot;&gt; import fn, &#123; hello_world &#125; from &#x27;./esm_index.js&#x27;&lt;/script&gt; 动态加载123456789101112// dynamic-m.jsexport const dynamic_value = &#x27;动态加载&#x27;export default function() &#123; console.log(&#x27;default&#x27;)&#125;mport(&#x27;./dynamic-m.js&#x27;) .then(module =&gt; &#123; // module: &#123; default: fn, dynamic_value: &#x27;动态加载&#x27; &#125; console.log(&#x27;动态&#x27;, module) &#125;) ESBuild https://esbuild.github.io/api/ 介绍: https://juejin.cn/post/6918927987056312327","categories":[],"tags":[{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"}]},{"title":"深入浅出TypeScript","slug":"深入浅出TypeScript","date":"2022-09-09T02:35:36.000Z","updated":"2022-09-13T03:03:59.001Z","comments":true,"path":"/post/深入浅出TypeScript.html","link":"","permalink":"http://yoursite.com/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html","excerpt":"TypeScript","text":"TypeScript.d.ts 和 declare 是干嘛用的如果一个文件有扩展名 .d.ts，则表示它是一个声明文件，可以用来声明全局的类型定义和接口，或者是其它模块。比如： 1234567891011121314151617181920// global.d.ts// 声明接口declare interface Person &#123; name: string; age: number;&#125;// 声明类型 (别名)declare type TName = string;// 声明模块declare module &#x27;*.css&#x27;;declare module &#x27;*.less&#x27;;declare module &#x27;*.png&#x27;;// 拓展 window 属性，在 window 对象上显式设置属性declare interface Window &#123; MyNameSpace: any&#125; 但是也不是说创建了.d.ts文件，里面声明的东西就能生效了，毕竟归根到底也是.ts文件，需要预编译，所以需要在tsconfig.json文件里面的include数组里面添加 global.d.ts 文件。 1&quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;] .d.ts 文件中的顶级声明必须以 “declare” 或 “export” 修饰符开头。通过declare声明的类型或者变量或者模块，在include包含的文件范围内，都可以直接引用。 12345// .vue setup / .tsconst me: Person = &#123; name: &#x27;alex.cheng&#x27;, age: 18&#125; 注意.d.ts文件顶级声明declare最好不要跟export同级使用，不然在其他ts文件引用这个.d.ts的内容的时候，就需要手动import导入了。 12345678// global.d.tsexport type TName = string;// 这个时候，外部 ts 就无法直接使用 Person 了，需要引入 import &#123; Person &#125; from &#x27;../global.d.ts&#x27;export declare interface Person &#123; name: string; age: number;&#125; 给对象分配动态（未知）属性1234567891011121314const o: &#123; [key: string]: any &#125; = &#123;&#125;// 使用 ts 内置工具 Record，效果同上const o: Record&lt;string, any&gt; = &#123;&#125;interface IPerson extends Record&lt;string, any&gt; &#123; name: string; age?: number;&#125;const me1: IPerson = &#123; name: &#x27;alex&#x27;, hair: &#x27;black&#x27;&#125; interface 和 type 有什么区别 接口和类型别名都可以用来描述对象的形状或函数签名。 与接口类型不一样的是，类型别名可以用于一些其他类型，比如原始类型、联合类型（|）和元组。 接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。 interface 扩展（接口、类型）使用 extends 关键字，类型别名扩展（接口、类型）使用的是 交叉类型（&amp;）: 123456789101112131415// 接口扩展interface IPerson &#123; name: string;&#125;interface IMe extends IPerson &#123; age: number;&#125;// 类型扩展type TPerson = &#123; name: string;&#125;type TMe = TPerson &amp; &#123; age: number;&#125; 类可以以相同的方式实现(implements)接口或类型别名，但类不能实现使用类型别名定义的联合类型 12345678910111213// Error:type PartialPoint = &#123; x: number; &#125; | &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; // 类只能实现具有静态已知成员的对象类型或对象类型的交集。ts(2422) x = 1; y = 2;&#125;// Successtype PartialPoint = &#123; x: number; &#125; &amp; &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; x = 1; y = 2;&#125; 与类型别名不同，接口可以定义多次，会被自动合并为单个接口。 123456789101112interface IMerge &#123; a: 1;&#125;interface IMerge &#123; b: 2&#125;const ab: IMerge = &#123;&#125;; // 类型“&#123;&#125;”缺少类型“IMerge”中的以下属性: a, bts(2739)// Error: 标识符“TOne”重复。ts(2300)type TOne = string;type TOne = number; 类型保护 typeof instanceof in 参考资料TS 学习指南 ↩深入理解TypeScript ↩","categories":[],"tags":[{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"}]},{"title":"移动端开发实践","slug":"app-h5","date":"2022-06-09T06:26:40.000Z","updated":"2022-06-09T06:44:26.042Z","comments":true,"path":"/post/app-h5.html","link":"","permalink":"http://yoursite.com/post/app-h5.html","excerpt":"React Native 、H5移动端开发实践","text":"WebView现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发，它具备开发周期短、灵活性好的优点，但是缺点也很明显，加载速度慢 &amp; 消耗流量。引起缺点的主要原因如下： js解析效率，以及手机硬件设备的性能 页面资源的下载（图片、js文件、css文件） 参考资料Android Webview H5 秒开方案实现 ↩","categories":[],"tags":[{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"}]},{"title":"如何编写高标准的 JavaScript 代码","slug":"js-advice","date":"2022-03-31T02:12:23.000Z","updated":"2022-04-08T02:42:23.957Z","comments":true,"path":"/post/js-advice.html","link":"","permalink":"http://yoursite.com/post/js-advice.html","excerpt":"代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。","text":"概述你是否曾经为了提供一个简单的应用解决方案而彻夜地查看源代码？你是否曾经为了理解某个框架而冥思苦想、阅览群书？你是否曾经为了提升0.1s的DOM性能而对多种实现方案进行严格测试和对比？你是否曾经为了避免兼容问题而遍寻高手共同“诊治”？ 跟我一起，专注高质量 JavaScript 代码，少出 Bug🐛，早下班 ! 期望为读者带来如下帮助 📚： ❑ 能写出简单、清晰、高效的代码。 ❑ 能搭建一个稳定、健壮、快捷的应用框架。 ❑ 能回答一个困扰很多人的技术问题。 ❑ 能修复一个应用开发中遇到的大的Bug。 ❑ 能非常熟悉某个开源产品。 ❑ 能提升客户端应用性能。 JavaScript 基础代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。 减少全局变量 多个全局变量都追加在一个名称空间下，将显著降低与其他应用程序产生冲突的概率 123const namespace = &#123;&#125;namespace.name = &#x27;my namespace&#x27; 使用闭包体将信息隐藏，它是另一种有效减少“全局污染”的方法。 1234567const sayName = function() &#123; const name = &#x27;closure&#x27; return function() &#123; alert(name) &#125;&#125;() 作用域控制着变量与参数的可见性及生命周期。 JavaScript支持函数作用域，定义在函数中的参数和变量在函数外部是不可见的，并且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。它不仅减少了名称冲突，并且提供了自动内存管理。 ES6 模块化编程中每个 js 文件内部定义的变量，外部无法获取。如果外部需要模块内部变量，通过 export 导出。 1234567891011&lt;script&gt; var windowA = &#x27;window a&#x27; console.log(window.windowA) // 输出 &#x27;window a&#x27;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; var moduleA = &#x27;module a&#x27; console.log(window.moduleA) // 输出 undefined&lt;/script&gt; 谨慎JS数据类型在自动转换数据类型时，JavaScript一般遵循：如果某个类型的值被用于需要其他类型的值的环境中，JavaScript就自动将这个值转换成所需要的类型。 类型转换慎用JavaScript类型自动转换，注意自动转换规则: 如果把非空对象用在逻辑运算环境中，则对象被转换为true。此时的对象包括所有类型的对象，即使是值为false的包装对象也被转换为true。 果把对象用在数值运算环境中，则对象会被自动转换为数字，如果转换失败，则返回值为NaN。 当数组被用在数值运算环境中时，数组将根据包含的元素来决定转换的值。如果数组为空数组，则被转换为数值0。如果数组仅包含一个数字元素，则被转换为该数字的数值。如果数组包含多个元素，或者仅包含一个非数字元素，则返回NaN。 🌰 123456789101112// 对象const obj = &#123;&#125;obj &amp;&amp; 1 &gt;&gt; 1obj + 1 &gt;&gt; &#x27;[object Object]1&#x27;obj.valueOf = function() &#123; return 99 &#125;obj + 1 &gt;&gt; 100// 数组自动转换规则+[] &gt;&gt; 0+[1] &gt;&gt; 1+[1,2] &gt;&gt; NaN 类型判断 typeof对于任何变量来说，使用typeof运算符总是以字符串的形式返回以下6种类型之一：❑ “number”❑ “string”❑ “boolean”❑ “object”❑ “function”❑ “undefined” 令人疑惑的是，在使用 typeof 检测null值时，返回的是“object”，而不是“null”。 12345typeof null &gt;&gt; &#x27;object&#x27;typeof [] &gt;&gt; &#x27;object&#x27;typeof &#123;&#125; &gt;&gt; &#x27;object&#x27; instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 这个在判断对象时存在一些不确定性，来看下例子： 🌰 123456function Person(name) &#123; this.name = name&#125;const p = new Person(&#x27;hello&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 再看一个🌰: 123456789101112131415function Person(name) &#123; this.name = name&#125;function Child(name) &#123; this.name = name&#125;Child.prototype = Person.prototypeChild.prototype.constructor = Childconst p = new Child(&#x27;hello child&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 如果是判断数组呢? 1234567[] instanceof Array &gt;&gt; true[] instanceof Object &gt;&gt; true// 当然这种方式存在不确定性，我们可以使用 Array.isArray() 方法来判断Array.isArray([]) &gt;&gt; trueArray.isArray(&#123;&#125;) &gt;&gt; false 从上面例子可以看出，使用 instanceof 来判断时存在种种不确定性，只要出现在原型链上的对象都会返回 true，使用的时候还需要着重注意！ 为什么会这样，想必大家应该想起来了！ Object类是所有对象类型的的父类! toString() 方法 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 toString() 方法，它定义在 Object 的原型对象上，对象在调用时会返回一个表示该对象的字符串。 使用 toString() 方法检测对象类型是最安全、最准确的。调用toString()方法把对象转换为字符串，然后通过检测字符串中是否包含数组所特有的标志字符可以确定对象的类型。 为什么说 toString 方法用来检测对象类型是最安全、最准确的，我们慢慢来看吧~ 先看看在对象上直接使用 toString会是什么结果： 1234567891011121314const obj = &#123; a: 1 &#125;const arr = [1, 2]obj.toString() &gt;&gt; &#x27;[object Object]&#x27;// 如果是数组的话，则输出字符串arr.toString() &gt;&gt; &#x27;1,2&#x27;// 当然我们可以重写/覆盖原型链上的 toString 方法obj.toString = function() &#123; return &#x27;overwrite&#x27;&#125;obj.toString() &gt;&gt; &#x27;overwrite&#x27; 既然 toString 方法定义在原型对象上，我们看看如果单独调用它，会是什么结果呢? 1Object.prototype.toString() &gt;&gt; &#x27;[object Object]&#x27; 如果通过 call/apply 方法，改变 toString 方法内部的 this 执行，又会是什么结果呢? 看到如下结果，我相信这绝对可以完美 cover 住项目里面所有的类型判断了！所以说它是最安全、最准确的类型判断，没有异议吧😏 12345678910111213141516171819202122Object.prototype.toString.call(&#123;&#125;) &gt;&gt; &#x27;[object Object]&#x27;Object.prototype.toString.call([]) &gt;&gt; &#x27;[object Array]&#x27;Object.prototype.toString.call(function()&#123;&#125;) &gt;&gt; &#x27;[object Function]&#x27;Object.prototype.toString.call(&#x27;&#x27;) &gt;&gt; &#x27;[object String]&#x27;Object.prototype.toString.call(1) &gt;&gt; &#x27;[object Number]&#x27;Object.prototype.toString.call(true) &gt;&gt; &#x27;[object Boolean]&#x27;Object.prototype.toString.call(null) &gt;&gt; &#x27;[object Null]&#x27;Object.prototype.toString.call(undefined) &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call() &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call(new Date()) &gt;&gt; &#x27;[object Date]&#x27;Object.prototype.toString.call(/at/) &gt;&gt; &#x27;[object RegExp]&#x27; 那么它是如何做到的呢，我们来扒一扒它的原理！在 toString 方法被调用时，会执行以下几个操作步骤: 获取this指向的那个对象的[[Class]]属性的值。（call/apply 改变 this 指向） 计算出三个字符串”[object “、 第一步的操作结果、 以及 “]” 连接后的新字符串。 返回第二步的操作结果，也就是类似 &#39;[object Type]&#39; 这种格式字符串。 需要注意的是，对象的[[Class]]属性是无法直接访问的，它一个内部属性，所有的对象(原生对象和宿主对象)都拥有该属性，且不能被任何人修改。在规范中，[[Class]]是这么定义的：内部属性描述。 如果要单独或者对象的 [[Class]]，我们可以这样做: 12const targetObj = []Object.prototype.toString.call(targetObj).slice(8, -1) &gt;&gt; &#x27;Array&#x27; 既然它如此好用，难道就没有缺点吗？ 答案是当然有的，毕竟凡事都不可能那么绝对的嘛！ 那么缺点是什么呢？第一，toString() 会进行装箱操作，产生很多临时对象。（装箱就是将基本类型的数据，通过引用类型包装起来，从而可以使用引用类上的方法） 12345// 你肯定不能这样用1.toString() &gt;&gt; SyntaxError: Invalid or unexpected token// 你必须这样用(1).toString() &gt;&gt; &#x27;1&#x27; 第二，无法区分自定义对象类型，用来判断这类对象时，返回的都是Object，这样我们就需要通过 instanceof 来判断了。 1234function Person()&#123;&#125;const p = new Person()Object.prototype.toString.call(p) &gt;&gt; &#x27;[object Object]&#x27; 字符串JavaScript解释器强制约定字符串在堆区存储的数据是不可变的，也就是说，JavaScript解释器强制约定字符串在堆区存储的数据是不可变的。 参考资料参考资料 ↩参考资料2 ↩","categories":[],"tags":[{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"}]},{"title":"React Hooks","slug":"react-hooks","date":"2022-03-26T10:41:01.000Z","updated":"2022-09-16T08:22:44.579Z","comments":true,"path":"/post/react-hooks.html","link":"","permalink":"http://yoursite.com/post/react-hooks.html","excerpt":"什么是React Hooks，为什么需要它？如何高效的使用React Hooks？如何自定义 Hooks ？如何通过 Hooks 做性能优化？","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 动机Hook 规则 只在最顶层使用 Hook 只在 React 函数中调用 Hook。（或：在自定义 Hook 中调用其他 Hook） 使用 useCallback、useMemo、memo 做性能优化尽可能的保证组件不去发生变化，发生变化的因素有：state、props、context。 那么 React 是如何比较这三者的呢？ 答案是 内存地址。 比如说，对比一个 function，对比的就是这个函数在内存中的地址，通过地址的判断，从而判断 props 是否发生了改变。 React.memo https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate React.memo 包裹一个组件，来对它的 props 进行浅比较。等效于 PureComponent，但它只比较 props。（也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。） 123456789101112131415161718192021222324// 不使用 memo，每一次 setCount，都会造成 Child 组件重新 renderconst Child = () =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;const Demo = () =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child /&gt; &lt;/&gt; )&#125;// 通过 memo 包裹后，Child 组件不会再重新 render了。const Child = memo(() =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;) 当 memo 感知 props 没有发生改变时，不会重新 render 组件。如果传入 count 进来，Child组件就会重新 render。 总结： 如果我们将 setCount 当做 prop 传入进来，Child 不会重新render（因为 setCount 在内存中的地址没有发生改变） 如果传入我们自己定义的方法 (fn)进来，Child会重新 render，因为 Demo 组件每次更新 count 后，重新生成了 fn 函数。 只是传了个 fn ，不想让 Child 组件更新怎么办？那就要用到 useCallback 钩子了 useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算。 1234// 只有当 count 发生变化时，才会重新计算const computedCount = useMemo(() =&gt; &#123; return count * 2&#125;, [count]) useMemo 也允许你跳过一次子节点的昂贵的重新渲染，比如组件初始化时，需要一次大量的计算，后续就不会再改变了： 123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; )&#125; useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。 下面这个例子，即使我们用 memo 包裹了组件，因为 setCount 每次会引起 Demo 组件重新 render，生成了新的 fn 函数(内存地址发生了变化)，导致 Child 也会重新 render。 123456789101112131415161718192021interface IChild &#123; fn: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;&#125;const Child = memo((props: IChild) =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;)const Demo = () =&gt; &#123; const [count, setCount] = useState(0) const fn = () =&gt; console.log(&#x27;is fn&#x27;) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/&gt; )&#125; 我们不想让 fn 函数的 内存地址 发生变化，怎么办呢？使用 useCallback 钩子将其包裹起来即可。 注意：useMemo 也可以这样用，缓存 fn，从而使得 Child 组件不会重复 render。 1234567// 省略...const fn = useCallback(() =&gt; &#123; console.log(&#x27;is fn&#x27;)&#125;, [])// 省略... 这样 fn 函数就是一个缓存函数了，即使 count 不停的发生变化，也不会造成 Child 组件重复 render。 总结: 当 Demo 组件内部 state 发生了改变引起 Demo 和 Child 组件重新 render 并且 Child 组件接受了一个来自 Demo 组件自定义的方法（fn） 如果不希望 Child 组件重新 render，那么就需要用 useCallback 钩子将自定义方法 fn 包裹起来 因为 Child 组件 props 里面的 fn 和 useCallback 返回的 fn 指向的是内存中的同一个地址，那么 Child 组件就不会更新 useCallback 返回新函数的条件是：依赖项（第二个参数）发生了改变。 如果说我们的 Child 组件，本身就是需要根据 count 变化而变化，那么就不需要加这个缓存 API了，反而增加其计算负担。 设计组件不要为了使用钩子，过渡的使用钩子，好的页面设计，也许用不上这些钩子。 把不变的组件和变化的组件抽离出来！ 比如可以把 count 相关部分抽离成一个 Count 组件，使其和 Child 组件同层级排列，Count 组件和 Child 组件分开了，也不会引起 Child 组件做多余的 render。 12&lt;Count /&gt;&lt;Child prop=&#123;fn&#125; /&gt; 或者是通过 props.children 渲染 Child，也不会造成 Child 重新 render。 12345678910111213141516171819202122const Count = (props: any) =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &#123;/* children 不会重新 render */&#125; &#123;props.children&#125; &lt;/&gt; )&#125;const Demo = () =&gt; &#123; // fn 永远不会变化 const fn = () =&gt; &#123;&#125; return ( &lt;&gt; &lt;Count&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/Count&gt; &lt;/&gt; )&#125; useRef / createRef 访问 DOM 节点 123456const inputEle = useRef(null)const inputEle = React.createRef()inputEle.current.focus() 测量 DOM节点？1234567891011121314151617const getHeight = useMemo(() =&gt; &#123; return (node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125; &#125;&#125;, [])// 或者const getHeight = useCallback((node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125;&#125;, []) 将 ref 逻辑抽离成一个 Hook 1234567891011121314151617181920// hookconst useClientRect = () =&gt; &#123; const [rect, setRect] = useState(null) const ref = useCallback(node =&gt; &#123; if (node) &#123; setRect(node.getBoundingClientRect()) &#125; &#125;, []) return [rect, ref]&#125;// 使用const [rect, ref] = useClientRect()&lt;h1 ref=&#123;ref&#125;&gt;是 H1 标签 &#123;count&#125;&lt;/h1&gt;&#123; rect &amp;&amp; &lt;span&gt;&#123;rect.height&#125;&lt;/span&gt;&#125; React.forwardRef React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。 123456789const FancyInput = forwardRef((props, ref) =&gt; ( &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;))// 这样可以拿到 input 元素了const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt; useImperativeHandle useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 12345678910111213141516171819202122232425const FancyInput = forwardRef((props, ref) =&gt; &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125;, alert () &#123; alert(1) &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;;&#125;)const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt;// 通过 inputEle 获取到 useImperativeHandle 定义的方法inputEle.current.focus()inputEle.current.alert() 参考资料ahooks 官网 ↩","categories":[],"tags":[{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"}]},{"title":"Hello_AlexCc","slug":"first-article","date":"2019-07-29T15:37:50.000Z","updated":"2022-04-07T10:04:40.419Z","comments":true,"path":"/post/first-article.html","link":"","permalink":"http://yoursite.com/post/first-article.html","excerpt":"First Article","text":"What This is my first Blog. No.212345if (true) &#123; console.log(&quot;Hello_AlexCc!&quot;)&#125;return &quot;ヾ(◍°∇°◍)ﾉﾞ&quot;","categories":[],"tags":[{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}],"categories":[],"tags":[{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"},{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"},{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"},{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"},{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"},{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}