{"meta":{"title":"Hello_AlexCc","subtitle":"No pains, no gains.","description":"Technology Blog","author":"Hello_AlexCc","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About ME","date":"2022-03-30T02:53:37.000Z","updated":"2022-03-31T02:37:39.820Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"StoryA long time ago … A cat is sleeping，very very deep sleeping… Suddently, He find a mouse … God damn it, a so cute mouse! He don’t want to eat he, play with he."},{"title":"","date":"2022-11-30T03:01:38.680Z","updated":"2022-11-23T08:23:21.958Z","comments":false,"path":"demo/ObserverMode.html","permalink":"http://yoursite.com/demo/ObserverMode.html","excerpt":"","text":"观察者模式 ul { background-color: antiquewhite; } li { background-color: aqua; margin-top: 12px; } 面包屑 1 2 3 // 目标 class Subject { constructor() { this.observers = [] } add(ob) { this.observers.push(ob) } notify(text) { this.observers.forEach(o => { o.update(text) }) } } // 观察者 class Observer { constructor(name) { this.ele = document.querySelector(name) } update(text) { this.ele.innerHTML = text } } const s = new Subject() const o1 = new Observer('.bread') s.add(o1) let oLi = document.querySelectorAll('.left li') for (let i = 0; i < oLi.length; i++) { oLi[i].onclick = function () { s.notify(this.innerHTML) } }"},{"title":"","date":"2022-11-30T03:01:38.694Z","updated":"2022-11-23T12:48:03.716Z","comments":false,"path":"demo/timeFragment.html","permalink":"http://yoursite.com/demo/timeFragment.html","excerpt":"","text":"时间分片 // 记录任务开始时间 let now = Date.now(); // 插入十万条数据 const total = 100000; // 获取容器 let ul = document.getElementById('container'); // 将数据插入容器中 for (let i = 0; i < total; i++) { let li = document.createElement('li'); li.innerText = i ul.appendChild(li); } console.log('JS运行时间：', Date.now() - now); setTimeout(() => { console.log('总运行时间：', Date.now() - now); }, 0) // // --------- 分批渲染 --------- // //需要插入的容器 // let ul = document.getElementById('container'); // // 插入十万条数据 // let total = 100000; // // 一次插入 20 条 // let once = 20; // //总页数 // let page = total / once // //每条记录的索引 // let index = 0; // //循环加载数据 // function loop(curTotal, curIndex) { // if (curTotal { // for (let i = 0; i < pageCount; i++) { // let li = document.createElement('li'); // li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total) // ul.appendChild(li) // } // loop(curTotal - pageCount, curIndex + pageCount) // }, 0) // } // loop(total, index);"},{"title":"","date":"2022-11-30T03:05:16.656Z","updated":"2022-11-30T03:05:16.656Z","comments":false,"path":"demo/resizeObserver.html","permalink":"http://yoursite.com/demo/resizeObserver.html","excerpt":"","text":"Resize observer text test html { height: 100%; font-family: 'helvetica neue', arial, sans-serif; } body { height: inherit; margin: 0; display: flex; justify-content: center; align-items: center; } body>div { background-color: #eee; border: 1px solid #ccc; padding: 20px; width: 50%; min-width: 320px; } h1 { margin: 0; } p { line-height: 1.5; } form { width: 100%; } form>div { display: flex; } form label { flex: 2; } form input { flex: 3; } input[type=\"checkbox\"] { height: 2rem; } So what happened? https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver 记住，不要做任何影响任何事情的事情，除非事实证明你应该这么做，那样的话，看在上帝的份上，不要不做！我的灵魂！我不想被救。你们不是圣诞老人！你们都不是机器人。我得想办法逃离年轻时可怕的摧残。突然间，我每三个小时就要上一次厕所。社保局的那些混蛋也不再给我寄支票了。现在我得付钱给他们！ Observer enabled: Adjust width: if (window.ResizeObserver) { const h1Elem = document.querySelector('h1'); const pElem = document.querySelector('p'); const divElem = document.querySelector('body > div'); const slider = document.querySelector('input[type=\"range\"]'); const checkbox = document.querySelector('input[type=\"checkbox\"]'); divElem.style.width = '600px'; slider.addEventListener('input', () => { divElem.style.width = slider.value + 'px'; }) const resizeObserver = new ResizeObserver(entries => { console.log('entries', entries) for (let entry of entries) { if (entry.contentBoxSize) { // The standard makes contentBoxSize an array... if (entry.contentBoxSize[0]) { h1Elem.style.fontSize = Math.max(1.5, entry.contentBoxSize[0].inlineSize / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentBoxSize[0].inlineSize / 600) + 'rem'; } else { // ...but old versions of Firefox treat it as a single item h1Elem.style.fontSize = Math.max(1.5, entry.contentBoxSize.inlineSize / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentBoxSize.inlineSize / 600) + 'rem'; } } else { h1Elem.style.fontSize = Math.max(1.5, entry.contentRect.width / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentRect.width / 600) + 'rem'; } } console.log('Size changed'); }); resizeObserver.observe(divElem); checkbox.addEventListener('change', () => { if (checkbox.checked) { resizeObserver.observe(divElem); } else { resizeObserver.unobserve(divElem); } }); } else { console.log('Resize observer not supported!'); }"},{"title":"","date":"2022-11-30T03:01:38.689Z","updated":"2022-11-23T09:03:02.974Z","comments":false,"path":"demo/PubSubMode.html","permalink":"http://yoursite.com/demo/PubSubMode.html","excerpt":"","text":"发布订阅者模式 ul { background-color: antiquewhite; } li { background-color: aqua; margin-top: 12px; } 面包屑 1 2 3 const PubSub = { message: {}, // 将事件存储数组，改成对象，key 表示事件类型，value 表示订阅的事件数组 publist(type, text) { if (!this.message[type]) return this.message[type].forEach(cb => { cb(text) }) }, subscribe(type, cb) { if (!this.message[type]) { this.message[type] = [cb] // 如果事件 type 不存在，我们就创建一个事件类型数组 } else { this.message[type].push(cb) } }, unsubscribe(type, cb) { // 取消订阅 if (!this.message[type]) return if (!cb) { // 取消所有订阅的事件 this.message[type] = [] } else { this.message[type] = this.message[type].filter(i => i !== cb) } } } PubSub.subscribe('updateBread', function (text) { const breadEle = document.querySelector('.bread') breadEle.innerHTML = text }) let oLi = document.querySelectorAll('.left li') for (let i = 0; i < oLi.length; i++) { oLi[i].onclick = function () { PubSub.publist('updateBread', this.innerHTML) } }"}],"posts":[{"title":"Nginx 实战","slug":"nginx","date":"2022-12-17T03:30:00.000Z","updated":"2022-12-17T03:46:00.578Z","comments":true,"path":"/post/nginx.html","link":"","permalink":"http://yoursite.com/post/nginx.html","excerpt":"Never too old to learn.","text":"查看 Nginx 命令查看安装目录 whereis nginx nginx: /usr/bin/nginx 查看 nginx 进程 ps -ef | grep nginx 查看 nginx 可执行文件 ps -ef | grep nginx /www/server/nginx/conf/nginx.conf 表示配置文件 或者也可以通过 nginx -t 来查看配置文件在哪，虽然这个命令是检测 nginx 配置文件是否有语法错误： 12nginx: the configuration file /www/server/nginx/conf/nginx.conf syntax is oknginx: configuration file /www/server/nginx/conf/nginx.conf test is successful 配置文件 nginx.conf 全局模块worker_processes auto; // 进程数量error_log /www/wwwlogs/nginx_error.log crit; // 错误日志存放路径pid /www/server/nginx/logs/nginx.pid; // 存放 pid 文件 eventsworker_connections 51200; // 单个进程最大的连接数（最大连接数：连接数+进程数） http 块 include 引入其他的配置文件 default_type 文件类型 解决跨域问题首先启动 nginx 服务，输入命令 nginx，修改根路径下的 index.html 文件 1234567891011121314151617181920212223242526// nginx 配置，访问 localhost:8080/ 时，会打开 index.htmllocation / &#123; root html; index index.html index.htm;&#125;// 修改index.html&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;button id=&quot;btn&quot;&gt;send&lt;/button&gt;&lt;script&gt; btn.onclick = () =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;GET&#x27;, &#x27;http://localhost:9999/list&#x27;) xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(&#x27;返回结果&#x27;, xhr.responseText) &#125; &#125; xhr.send(null) &#125;&lt;/script&gt;&lt;/body&gt; 起一个本地 node 服务 9999 123456789101112const express = require(&#x27;express&#x27;);const app = express()app.get(&#x27;/list&#x27;, (req, res) =&gt; &#123; res.json(&#123; code: 0, msg: &quot;hello server&quot; &#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;server site an port 9999 ...&#x27;)&#125;) 当我们点击发送按钮时，会出现跨域问题，这是因为浏览器 同源策略限制，协议、域名、端口号不同，会形成跨域。 这里是端口不同。 我们可以利用 nginx 来解决。 打开 nginx.conf，新增一条转发规则，表示遇到 api 开头的，都将转发到某个服务下 比如 xhr.open(&#39;GET&#39;, &#39;/api/list&#39;), 会将 api 替换成 http://localhost:9999/ 12345// 添加location /api/ &#123; proxy_pass http://localhost:9999/;&#125; 修改调用接口的地方: 1xhr.open(&#x27;GET&#x27;, &#x27;/api/list&#x27;) 此时，再次点击 发送,不会再出现跨域了。 Vue Router History 模式 404 问题Vue 项目，采用 history 的路由模式，打包后放到 nginx 上部署，切换路由时出现 404 现象。 解决方案：try_files $uri $uri/ /index.html; 123456location / &#123; root html; index index.html index.htm; try_files $uri $uri/ /index.html;&#125; 负载均衡我们可以建 3 个（或者更多）node 服务来模拟实现，可以通过 count 计数，来查看每个服务被分配到的请求数 server1 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const app = express()let count = 1app.get(&#x27;/list&#x27;, (req, res) =&gt; &#123; res.json(&#123; code: 0, msg: &quot;hello server 9999&quot; &#125;) console.log(`server 9999 ------ $&#123;count&#125;`) count++&#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;server site an port 9999 ...&#x27;)&#125;) 通过 pm2 log 查看日志 1234567// package.json&quot;start&quot;: &quot;pm2 start index.js index2.js index3.js --watch&quot;,&quot;stop&quot;: &quot;pm2 stop index.js&quot;,&quot;allList&quot;: &quot;pm2 list&quot;,&quot;monit&quot;: &quot;pm2 monit&quot;,&quot;log&quot;: &quot;pm2 log&quot; server2、server3 只是端口不一样 修改 nginx 配置配置根路径，代理到本地服务，当我们启动 nginx，访问 http://localhost:8080/ 时，服务会代理到我们配置的 upstream node 服务上，访问 http://localhost:8080/list 即可调用咱们写好的 node 接口。 1234567891011upstream node &#123;server 127.0.0.1:9997;server 127.0.0.1:9998;server 127.0.0.1:9999;&#125;server &#123; location / &#123; proxy_pass http://node; // node 是 upstream 指定的 name &#125;&#125; 最后我们可以通过 postman 或 apifox 来进行压测了。 1接口：http://localhost:8080/list 这里设置的接口循环次数是 33，意味着我们将要调用 33 次接口，运行之后，33次均可以成功跑通。 来看下结果： 每个 server 分配均匀，33次，每个服务分配了 11 次请求。 权重还可以给服务设置权重 weight，数值越大，权重越高，请求数越多。 123server 127.0.0.1:9997 weight=3;server 127.0.0.1:9998 weight=2;server 127.0.0.1:9999 weight=1; 修改完配置后，重启 nginx nginx -s reload，继续运行 apifox 压测接口： 权重最高的 9997 请求被分配了 17 次，权重最低的 9999 只分配了 5 次请求。 超时设置超时备用模式，如果存在超时，就会选用备用的服务 9003，如果不存在超时请求，则不会有请求打到 9999 服务上。 12345upstream node &#123; server 127.0.0.1:9997 fail_timeout=60; server 127.0.0.1:9998 fail_timeout=20; server 127.0.0.1:9999 backup;&#125; 参考资料小满介绍Nginx ↩安装Nginx ↩Nginx相关 ↩","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"在Linux上部署 Node 接口","slug":"nodejs","date":"2022-12-16T06:00:00.000Z","updated":"2022-12-16T13:55:24.244Z","comments":true,"path":"/post/nodejs.html","link":"","permalink":"http://yoursite.com/post/nodejs.html","excerpt":"Never too old to learn.","text":"连接远程服务器打开 mac 终端: 123ssh root@124.221.230.105 (公网IP)// 接着输入密码，即可登录远程服务器 登录进去，输入 pwd，会输出 /root，这时我们切到 ‘/‘ 目录下: cd .. 在远程安装 nodejs1wget https://cdn.npmmirror.com/binaries/node/v14.19.1/node-v14.19.1-linux-x64.tar.xz 解压压缩包使用 tar 命令 -c 压缩 -x 解压 -t 查看内容 -r 想压缩归档文件末尾追加文件 -v 显示所有过程 -f 使用档案名字，切记，这是最后一个参数，最后只能接档案名 1tar -xvf node-v14.19.1-linux-x64.tar.xz 配置环境变量找到根目录 ‘/‘ 下的 etc文件夹，进去里面，打开 profile 文件，打开，执行命令： 12345// &#x27;/&#x27;cd etcvim profile 在最后一行加上如下这句： 1export PATH=$PATH:/node-v14.19.1-linux-x64/bin 最后，使文件生效 12// /etcsource profile 查看 node 版本 123node -vnpm -v 安装 pm21npm install -g pm2 部署 node 接口在根目录下 /，创建 node-server 文件夹 可以通过 express 建立一个 node 服务 123456789101112131415const express = require(&quot;express&quot;);const app = express()app.get(&#x27;/list&#x27;, (req, res) =&gt; &#123; console.log(&#x27;current IP&#x27;, req.ip) res.json(&#123; code: 200, msg: &#x27;linux node server&#x27; &#125;)&#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;node server at port 9999...&#x27;)&#125;) 通过 pm2 启动node服务12// node-serverpm2 start index.js --watch 通过 pm2 monit 查看 node 服务的打印日志 注意访问接口，如果打不开，大概率是因为没有放开防火墙。 http://124.221.230.105:9999/list 找到服务器地址，放开 node 服务对应的端口号 此时依然无法打开对应的接口 登录服务器，查看防火墙所有的端口 firewall-cmd –zone=public –list-ports 添加新的端口 firewall-cmd –zone=public –add-port=9999/tcp –permanent 删除 firewall-cmd –zone=public –remove-port=9999/tcp –permanent 表示永久有效 重启防火墙 firewall-cmd –reload 至此，就可以访问服务器上 node 服务的接口了。 参考资料小满Linux介绍 ↩","categories":[],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"Vue Router 4+","slug":"vue-router4","date":"2022-12-16T04:22:00.000Z","updated":"2022-12-16T04:39:36.629Z","comments":true,"path":"/post/vue-router4.html","link":"","permalink":"http://yoursite.com/post/vue-router4.html","excerpt":"富有表现力的路由语法、细致的导航控制、基于组件的配置方法、支持历史模式、 支持滚动控制、支持自动编码","text":"Vue Routerhistory1234const router = VueRouter.createRouter(&#123; history: VueRouter.createWebHashHistory(), // hash 模式 routes,&#125;) hash 模式底层是通过 hashchange 监听的： 1window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123; ... &#125;) history 模式 (createWebHistory)，底层是通过 popstate 监听的: 1window.addEventListener(&#x27;popstate&#x27;, () =&gt; &#123; ... &#125;) 在 setup 中访问路由和当前路由因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route。 1234567891011121314151617import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const route = useRoute() function pushWithQuery(query) &#123; router.push(&#123; name: &#x27;search&#x27;, query: &#123; ...route.query, &#125;, &#125;) &#125; &#125;,&#125; route 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该避免监听整个 route 对象。在大多数情况下，你应该直接监听你期望改变的参数。 请注意，在模板中我们仍然可以访问 $router 和 $route，所以不需要在 setup 中返回 router 或 route。","categories":[],"tags":[{"name":"JS,Vue-Router,Vue3,","slug":"JS-Vue-Router-Vue3","permalink":"http://yoursite.com/tags/JS-Vue-Router-Vue3/"}]},{"title":"深入浅出Vue3","slug":"vue3","date":"2022-12-01T10:09:04.000Z","updated":"2022-12-15T08:43:49.375Z","comments":true,"path":"/post/vue3.html","link":"","permalink":"http://yoursite.com/post/vue3.html","excerpt":"渐进式 JavaScript 框架。易学易用，性能出色，适用场景丰富的 Web 前端框架","text":"ref 和 reactive 使用上有什么区别? ref 支持所有的类型，reactive 只接收引用类型（Array/Object/Map/Set） ref 取值和赋值都需要加 .value，reactive 不需要 .value reactive 不能直接赋值，否则会破坏响应式（proxy） 如果要改变数组，可以通过 push 方法，将要 push 的数组结构 (xx.push(…arr)) defineProps 如何定义默认值？ 针对类型的 defineProps 声明的不足之处在于，它没有可以给 props 提供默认值的方式。 使用TS 特有的默认值方式 withDefaults 函数，无须引入开箱即用，接受一个props函数第二个参数是一个对象设置默认值。 123456789export interface Props &#123; msg?: string labels?: string[]&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123; msg: &#x27;hello&#x27;, labels: () =&gt; [&#x27;one&#x27;, &#x27;two&#x27;]&#125;) 动态组件 component 要渲染的实际组件由 is prop 决定。 当 is 是字符串，它既可以是 HTML 标签名也可以是组件的注册名。 或者，is 也可以直接绑定组件。 按注册名渲染组件 1234567891011121314151617&lt;script&gt;import Foo from &#x27;./Foo.vue&#x27;import Bar from &#x27;./Bar.vue&#x27;export default &#123; components: &#123; Foo, Bar &#125;, data() &#123; return &#123; view: &#x27;Foo&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;component :is=&quot;view&quot; /&gt;&lt;/template&gt; 按定义渲染组件 &lt;script setup&gt; 组合式 API： 1&lt;component :is=&quot;Math.random() &gt; 0.5 ? Foo : Bar&quot; /&gt; 渲染 HTML 元素 1&lt;component :is=&quot;href ? &#x27;a&#x27; : &#x27;span&#x27;&quot;&gt;&lt;/component&gt; 插槽默认插槽、具名插槽。 作用域插槽：:headerName=&quot;&#39;我是头部&#39;&quot;，父组件可以通过 v-slot=&quot;&#123; headerName &#125;&quot; 拿到组件内部暴露出来的数据 1234567891011121314// SlotComp.vue&lt;template&gt; &lt;div class=&quot;slot-wrapper&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;slot name=&quot;header&quot; :headerName=&quot;&#x27;我是头部&#x27;&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main class=&quot;content&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt; 使用具有插槽的组件，headerName 是作用域插槽从内部提供的 12345&lt;SlotComp&gt; &lt;template v-slot:header=&quot;&#123; headerName &#125;&quot;&gt;&#123;&#123; headerName &#125;&#125;&lt;/template&gt; &lt;template v-slot&gt;default slot&lt;/template&gt; &lt;template v-slot:footer&gt;footer&lt;/template&gt;&lt;/SlotComp&gt; 插槽简写方式 # 12345&lt;SlotComp&gt; &lt;template #header=&quot;&#123; headerName &#125;&quot;&gt;&#123;&#123; headerName &#125;&#125;&lt;/template&gt; &lt;template #default&gt;default slot&lt;/template&gt; &lt;template #footer&gt;footer&lt;/template&gt;&lt;/SlotComp&gt; 动态插槽 1234567&lt;SlotComp&gt; &lt;template #[slotName]&gt;动态插槽&lt;/template&gt;&lt;/SlotComp&gt;// jsconst slotName = ref(&#x27;header&#x27;) 异步组件官方描述 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能： 12345678import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // ...从服务器获取组件 resolve(/* 获取到的组件 */) &#125;)&#125;) ES 模块动态导入 也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点 分包、性能优化) 12345import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; import(&#x27;./components/MyComponent.vue&#x27;)) 最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时 才会调用加载内部实际组件的函数。 顶层 await&lt;script setup&gt; 中可以使用顶层 await。结果代码会被编译成 async setup()： 123&lt;script setup&gt;const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())&lt;/script&gt; 搭配 Suspense 组件使用 定义异步组件 Sync.vue 123456789101112131415&lt;template&gt; &lt;div&gt; Name: &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;ref, reactive&#125; from &#x27;vue&#x27;import iTools from &#x27;@/utils/Tools&#x27;const name = ref(&#x27;&#x27;)const &#123; data &#125; = await iTools.Axios.get(&#x27;./sync-data.json&#x27;) // 定义在 public 下的json文件name.value = data.name&lt;/script&gt; 通过 defineAsyncComponent 动态导入 Sync.vue 组件 1const Sync = defineAsyncComponent(() =&gt; import(&#x27;@/components/Sync.vue&#x27;)) 使用 Suspense 内置组件 在请求过程中，会一直显示 loading… 状态，真实项目中我们可以替换成骨架屏。当接口请求成功，才会显示 Sync.vue 的内容。 123456789&lt;Suspense&gt; &lt;template #default&gt; &lt;Sync /&gt; &lt;/template&gt; &lt;template #fallback&gt; Loading... &lt;/template&gt;&lt;/Suspense&gt; 性能优化当我们使用了 defineAsyncComponent 动态导入组件，build 项目时，会单独将 Sync.vue 的 js 包拎出来，不会将其打包到index.js 中，通过拆包的方式，减少入口文件的大小，从而减少白屏的时间。 Teleport 传送门将其插槽内容渲染到 DOM 中的另一个位置。 12345678910111213141516171819interface TeleportProps &#123; /** * 必填项。指定目标容器。 * 可以是选择器或实际元素。 */ to: string | HTMLElement /** * 当值为 `true` 时，内容将保留在其原始位置 * 而不是移动到目标容器中。 * 可以动态更改。 */ disabled?: boolean&#125;// examples&lt;teleport to=&quot;#some-id&quot; /&gt;&lt;teleport to=&quot;.some-class&quot; /&gt;&lt;teleport to=&quot;[data-teleport]&quot; /&gt;&lt;teleport to=&quot;body&quot; /&gt; MittVue 2可以支持$on，$off来实现event bus，但是 Vue3 已经不支持这些属性，不过Vue 3可以支持第三方event bus来实现事件通信， 这里使用 mitt，官方地址：https://github.com/developit/mitt 1234import mitt from &#x27;mitt&#x27;// vue3挂载到全局app.config.globalProperties.$mitt = mitt() tsx 安装插件 npm install @vitejs/plugin-vue-jsx -D 安装如果失败，将 node 版本切换至 v14.16.0 使用插件 123456import vueJsx from &quot;@vitejs/plugin-vue-jsx&quot;;export default defineConfig(&#123; plugins: [vue(), vueJsx()], // ...&#125;) 但是导入 .tsx 文件，TypeScript 会报错： 12345// 找不到模块“@/components/Foo”或其相应的类型声明。import Foo from &#x27;@/components/Foo&#x27; // 省略了 .tsx 后缀// 导入路径不能以“.tsx”扩展名结束。考虑改为导入“@/components/Bar.js”。import Bar from &#x27;@/components/Bar.tsx&#x27; 配置 tsconfig.json: 12345678&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125;, &#125;&#125; 之后我们导入 tsx 类型的组件，就不要带上后缀了。 编写 tsx 组件的3中方式 函数模式 12345export default function() &#123; return ( &lt;h1&gt;TSX componen111t&lt;/h1&gt; )&#125; options API 模式 1234567891011121314import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123; data() &#123; return &#123; compname: &#x27;jsx comp&#x27; &#125; &#125;, render() &#123; return ( &lt;div&gt;&#123;this.compname&#125;&lt;/div&gt; ) &#125;&#125;) setup 函数模式 1234567891011121314151617181920interface IProps &#123; name?: string;&#125;export default defineComponent(&#123; props: &#123; name: String, &#125;, emits: [&#x27;on-click&#x27;], setup(props: IProps) &#123; const is = true // 返回渲染函数 return () =&gt; &#123; return ( &lt;h1 v-show=&#123;is&#125;&gt;setup 渲染函数 &#123;props?.name&#125;&lt;/h1&gt; ) &#125; &#125;&#125;) tsx slot 使用12345678910111213141516171819const Foo = (_, &#123; slots &#125;) =&gt; &#123; return (&lt;&gt; &lt;p&gt;&#123; slots?.header?.()&#125;&lt;/p&gt; &lt;h3&gt;slot comp&lt;/h3&gt; &lt;p&gt;&#123; slots.default ? slots.default() : &#x27;默认插槽&#x27; &#125;&lt;/p&gt; &lt;/&gt;)&#125;&lt;Foo v-slots=&#123;&#123; default() &#123; return &#x27;setup default slot&#x27; &#125;, header() &#123; return &#x27;header&#x27; &#125;&#125;&#125; /&gt; 自动引入 安装插件 unplugin-auto-import/vite https://github.com/antfu/unplugin-auto-import 注册完 plugin 之后，不再引入 ref, reactive 等等方法了，直接使用即可。 v-model 官网：https://cn.vuejs.org/guide/components/events.html v-model 在原生元素上的用法： 12345678&lt;input v-model=&quot;searchText&quot; /&gt;// 等价于&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot;/&gt; 而当使用在一个组件上时，v-model 会被展开为如下的形式： 123456789101112131415161718&lt;CustomInput :modelValue=&quot;searchText&quot; @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;/&gt;// 内部定义 props 和 方法const props = defineProps&lt;&#123; modelValue: boolean&#125;&gt;()const emits = defineEmits([&#x27;update:modelValue&#x27;])// 调用emits(&#x27;update:modelValue&#x27;, !props.modelValue) 当然，我们也可以给 v-model 指定一个参数，不使用默认的 modelValue: 12345&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;// 定义 propsdefineProps([&#x27;title&#x27;])defineEmits([&#x27;update:title&#x27;]) 我们还可以绑定多个 v-model: 1234&lt;UserName v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot;/&gt; 自定义指令 https://cn.vuejs.org/guide/reusability/custom-directives.html 12345678910111213141516171819const myDirective = &#123; // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode, prevVnode) &#123;&#125;, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode, prevVnode) &#123;&#125;, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode, prevVnode) &#123;&#125;, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) &#123;&#125;, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125; 123456789&lt;div v-example:foo.bar=&quot;baz&quot;&gt;// binding 参数会是一个这样的对象：&#123; arg: &#x27;foo&#x27;, modifiers: &#123; bar: true &#125;, value: /* `baz` 的值 */, oldValue: /* 上一次更新时 `baz` 的值 */&#125; 全局函数或变量在 Vue2 中，我们经常将全局用到的函数定义在 Vue 的 prototype 上，在 Vue3 中已经不这样使用了: 123456789const app = createApp(App)app.config.globalProperties.$env = &#x27;dev&#x27;app.config.globalProperties.$filters = &#123; format&lt;T&gt;(str: T): string &#123; return str.trim() &#125;&#125; 我们使用的时候，不需要导入什么，直接在 .vue 文件使用即可: 12345678&lt;div&gt;env &#123;&#123;$env&#125;&#125;&lt;/div&gt;&lt;script setup lang=&quot;ts&quot;&gt; const app = getCurrentInstance() console.log(app?.proxy?.$filters.format(&#x27;getCurrentInstance&#x27;))&lt;/script&gt; 在组件中使用全局的变量或者函数时，会出现 ts 报错，这时我们需要去声明它的类型: 12345678declare module &#x27;vue&#x27; &#123; export interface ComponentCustomProperties &#123; $filters: &#123; format&lt;T&gt;(str: T): string, &#125;, $env: string, &#125;&#125; 自定义插件 一个插件可以是一个拥有 install() 方法的对象，也可以直接是一个安装函数本身。 插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种： 通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令。 通过 app.provide() 使一个资源可被注入进整个应用。 向 app.config.globalProperties 中添加一些全局实例属性或方法 以一个全局的 Loading 组件为例： 12345678910111213141516171819202122// Loading/index.tsimport type &#123; App, VNode &#125; from &#x27;vue&#x27;import &#123; createVNode, render &#125; from &#x27;vue&#x27;import Loading from &#x27;./index.vue&#x27;export default &#123; install (app: App) &#123; // Loading 需要转成 VNode const VNode: VNode = createVNode(Loading) // 将组件挂在到某个元素下 render(VNode, document.body) // Loading 组件通过 defineExpose 方法，暴露内部方法会在 exposed 字段上 app.config.globalProperties.$loading = &#123; onShow: VNode.component?.exposed?.onShow, onHide: VNode.component?.exposed?.onHide &#125; &#125;&#125; Loading 组件内部实现 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;loading&quot; v-if=&quot;show&quot; @click=&quot;onHide&quot;&gt; &lt;img src=&quot;../../assets/imgs/loading.gif&quot; alt=&quot;&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;ref, reactive&#125; from &#x27;vue&#x27;const show = ref(false)const onShow = () =&gt; show.value = trueconst onHide = () =&gt; show.value = false// 暴露内部方法供外部调用defineExpose(&#123; onShow, onHide,&#125;)&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.loading &#123; width: 100%; height: 100%; background-color: #1f2123; position: absolute; top: 0; left: 0; text-align: center;&#125;&lt;/style&gt; 这样我们就可以在任何地方使用 全局 Loading 了。 123456789// setupconst instance = getCurrentInstance()const showLoading = () =&gt; &#123; instance?.proxy?.$loading.onShow()&#125;// or 直接在 template 中使用&lt;button @click=&quot;$loading.onShow&quot;&gt;show loading&lt;/button&gt; 如果调用 $loading 报ts错误，我们可以声明全局类型 12345678declare module &#x27;vue&#x27; &#123; export interface ComponentCustomProperties &#123; $loading: &#123; onShow(): void; onHide(): void; &#125; &#125;&#125; Scoped原理 &amp; 样式穿透 给 HTML DOM节点加一个不重复的 data 属性（形如: data-v-xxxxx），来表示它的唯一性 在每句 CSS 选择器的末尾，加一个当前组件的 data 属性选择器，来私有化样式 如果组件内部包含其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性. 想要直接修改开源组件的样式，大概率是失败的，解决方案就是要使用样式穿透 123456789/deep/ .input &#123; ...&#125;// or:deep(.input) &#123; ...&#125; css新特性插槽选择器我们在使用插槽时，如何在子组件中修改插槽内容的样式 123:slotted(.p-footer) &#123; color: red;&#125; 定义全局样式123:global(div) &#123; color: red;&#125; 动态 css123456789101112// jsconst color = ref(&#x27;red&#x27;)const font = ref(&#123; fontSize: &#x27;24px&#x27;, fontWeight: &#x27;bold&#x27;,&#125;)// css.box &#123; color: v-bind(color); font-size: v-bind(&#x27;font.fontSize&#x27;);&#125; 模块化 css给 style 标签加上 module 属性 123456789101112// template// 如果有多个，就写成数组形式&lt;div :class=&quot;[$style.box]&quot;&gt; 模块 css&lt;/div&gt;// css&lt;style module&gt;.box &#123; color: red&#125;&lt;/style&gt; $style 是固定的写法，如果不想用这个变量，我们可以指定 module=&quot;myStyle&quot; 。 我们还可以通过 useCssModule 获取当前组件下的样式类名 123456// 默认const class = useCssModule()const class = useCssModule(&#x27;$style&#x27;)// 如果指定了 moduleconst class = useCssModule(&#x27;myStyle&#x27;) 集成 Tailwind CSS https://blog.csdn.net/qq1195566313/article/details/124951311?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167109189716782427434983%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=167109189716782427434983&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-124951311-null-null.nonecase&amp;utm_term=tailwind&amp;spm=1018.2226.3001.4450 安装 vscode 提示插件 Tailwind CSS IntelliSense h函数1234567891011import &#123; h &#125; from &#x27;vue&#x27;const Btn = (props, ctx) =&gt; &#123; return h(&#x27;div&#x27;, &#123; class: [...], onClick: () =&gt; &#123; ctx.emit(&#x27;on-click&#x27;, &#x27;hello world&#x27;) &#125;, &#125;, ctx.slots.default())&#125; 参考资料Vue3+Vite+Ts 项目实战 01 Vite 创建项目、ESLint+TS+GitCommit配置、Vue3新特性介绍 ↩","categories":[],"tags":[{"name":"JS,Vue3","slug":"JS-Vue3","permalink":"http://yoursite.com/tags/JS-Vue3/"}]},{"title":"高性能渲染十万条数据(虚拟列表)","slug":"virtual-list","date":"2022-11-23T12:43:13.000Z","updated":"2022-11-28T03:19:11.257Z","comments":true,"path":"/post/virtual-list.html","link":"","permalink":"http://yoursite.com/post/virtual-list.html","excerpt":"使用虚拟列表的方式，来同时加载大量数据。","text":"前言在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。 时间分片 提到了可以使用时间分片的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用虚拟列表的方式，来同时加载大量数据。 当我们渲染10w条数据时，其实主要是的时间花费在 Recalculate Style 和 Layout 上 Recalculate Style：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。 Layout：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。 在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。 那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在Recalculate Style和Layout阶段消耗大量的时间。 而虚拟列表就是解决这一问题的一种实现。 什么是虚拟列表虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。 假设有1万条记录需要同时渲染，我们屏幕的可见区域的高度为1000px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到20个列表项，那么在首次渲染的时候，我们只需加载20条即可。 说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。 假设滚动发生，滚动条距顶部的位置为150px,则我们可得知在可见区域内的列表项为第4项至`第13项。 实现虚拟列表的实现，实际上是在首屏加载的时候，只加载 可视区域 内需要的列表项，当滚动发生时，通过计算动态获得可视区域内的列表项，并将非可视区域内存在的列表项删除。 计算当前可视区域起始数据索引（startIndex） 计算当前可视区域结束数据索引（endIndex） 计算当前可视区域的数据，并渲染到页面中 计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上 由于只是对可视区域内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构： 1234567891011121314151617181920&lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;!-- 所有数据的总高度 --&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 可视区区域，可以当做滑块看待 --&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;!-- 每一项数据 --&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.value &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 接着，监听infinite-list-container的 scroll事件，获取滚动位置 scrollTop。 列表总高度 listHeight = listData.length * itemSize 可显示的列表项数 visibleCount = Math.ceil(screenHeight / itemSize) 数据的起始索引 startIndex = Math.floor(scrollTop / itemSize) 数据的结束索引 endIndex = startIndex + visibleCount 列表显示数据为 visibleData = listData.slice(startIndex,endIndex) 12345678910111213scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引（向下取整），itemSize 是 100 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize);&#125;, 当滚动后，由于 渲染区域 相对于 可视区域 已经发生了偏移，此时我需要获取一个 偏移量startOffset，通过样式控制将渲染区域偏移至可视区域中，当用户在滑动时，渲染区域就会根据 startOffset 计算出偏移量，渲染区域就会一直在可视区域内呈现。 1234567this.startOffset = scrollTop - (scrollTop % this.itemSize);// computed//偏移量对应的stylegetTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`;&#125;, 完整代码12345678910111213141516&lt;style&gt; html&#123; height: 100%; &#125; body&#123; height: 100%; margin:0; &#125; #app&#123; height:100%; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;VirtualList :listData=&quot;state.data&quot; :itemSize=&quot;100&quot; /&gt;&lt;/div&gt; VirtualList comp. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;script&gt;export default &#123; name: &quot;VirtualList&quot;, props: &#123; //所有列表数据 listData: &#123; type: Array, default: () =&gt; [], &#125;, //每项高度 itemSize: &#123; type: Number, default: 200, &#125;, &#125;, computed: &#123; //列表总高度 listHeight() &#123; return this.listData.length * this.itemSize; &#125;, //可显示的列表项数 visibleCount() &#123; // 向上取整: Math.ceil(13.06) =&gt; 14，表示整个屏幕，可以放 14 条数据 return Math.ceil(this.screenHeight / this.itemSize); &#125;, //偏移量对应的style getTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`; &#125;, //获取真实显示列表数据 visibleData() &#123; return this.listData.slice( this.start, Math.min(this.end, this.listData.length) ); &#125;, &#125;, mounted() &#123; // this.$el 表示当前组件的根节点，这里是 infinite-list-container this.screenHeight = this.$el.clientHeight; this.start = 0; this.end = this.start + this.visibleCount; &#125;, data() &#123; return &#123; //可视区域高度 screenHeight: 0, //偏移量 startOffset: 0, //起始索引 start: 0, //结束索引 end: null, &#125;; &#125;, methods: &#123; scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引（向下取整），itemSize 是 100 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;!-- 所有数据的总高度 --&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 可视区区域，可以当做滑块看待 --&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.value &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.infinite-list-container &#123; height: 100%; overflow: auto; position: relative; -webkit-overflow-scrolling: touch;&#125;.infinite-list-phantom &#123; position: absolute; left: 0; top: 0; right: 0; z-index: -1;&#125;.infinite-list &#123; left: 0; right: 0; top: 0; position: absolute; text-align: center;&#125;.infinite-list-item &#123; padding: 10px; color: #555; box-sizing: border-box; border-bottom: 1px solid #999;&#125;&lt;/style&gt; 列表项动态高度在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。 而实际应用的时候，当列表中包含文本之类的可变内容，会导致 列表项的高度并不相同。 比如这样： 在虚拟列表中应用动态高度的解决方案一般有如下三种： 1.对组件属性itemSize进行扩展，支持传递类型为数字、数组、函数 可以是一个固定值，如 100，此时列表项是固高的 可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, …] 可以是一个根据列表项索引返回其高度的函数：(index: number): number 这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。 2.将列表项 渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内。 由于 预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。 3.以预估高度先行渲染，然后获取真实高度并缓存。 这是可以选择的实现方式，可以避免前两种方案的不足。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"高性能渲染十万条数据(时间分片)","slug":"time-fragment","date":"2022-11-23T11:53:52.000Z","updated":"2022-11-23T12:52:27.198Z","comments":true,"path":"/post/time-fragment.html","link":"","permalink":"http://yoursite.com/post/time-fragment.html","excerpt":"渲染大量数据。","text":"最粗暴的做法（一次性渲染JS的运行时间为187ms，还是蛮快的，但是最终渲染完成后的总时间确是2844ms，中间会白屏一段时间。 1234567891011121314151617// 记录任务开始时间let now = Date.now();// 插入十万条数据const total = 100000;// 获取容器let ul = document.getElementById(&#x27;container&#x27;);// 将数据插入容器中for (let i = 0; i &lt; total; i++) &#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = i ul.appendChild(li);&#125;console.log(&#x27;JS运行时间：&#x27;, Date.now() - now);setTimeout(() =&gt; &#123; console.log(&#x27;总运行时间：&#x27;, Date.now() - now);&#125;, 0) 使用定时器页面的卡顿是由于同时渲染大量DOM所引起的，所以考虑将渲染过程分批进行，这里用到的就是 setTimeout。 1234567891011121314151617181920212223242526let ul = document.getElementById(&#x27;container&#x27;);// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total / once//每条记录的索引let index = 0;//循环加载数据function loop(curTotal, curIndex) &#123; if (curTotal &lt;= 0) &#123; return false; &#125; //每页多少条 let pageCount = Math.min(curTotal, once); setTimeout(() =&gt; &#123; for (let i = 0; i &lt; pageCount; i++) &#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) ul.appendChild(li) &#125; loop(curTotal - pageCount, curIndex + pageCount) &#125;, 0)&#125;loop(total, index); 页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象。 为什么会出现闪屏现象呢首先，理清一些概念。FPS表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS是描述帧变化速度的物理量。 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，FPS为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。 因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。 为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。 而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。 大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 直观感受，不同帧率的体验： 帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适； 帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异； 帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感； 帧率波动很大的动画，亦会使人感觉到卡顿。 简单聊一下 setTimeout 和闪屏现象 setTimeout的执行时间并不是确定的。在JS中，setTimeout任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此setTimeout的实际执行时间可能会比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。 在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 使用 requestAnimationFrame与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。 如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame 的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。 将 setTimeout 替换成 requestAnimationFrame: 123456789101112// 其他 ...window.requestAnimationFrame(function()&#123; for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) ul.appendChild(li) &#125; loop(curTotal - pageCount,curIndex + pageCount)&#125;)// ... 使用 DocumentFragment DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。可以使用document.createDocumentFragment方法或者构造函数来创建一个空的DocumentFragment 从MDN的说明中，我们得知DocumentFragments是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流（什么是回流? 回流是会导致页面重新渲染的一些元素,从而影响性能）。 当append元素到document中时，被append进去的元素的样式表的计算是同步发生的，此时调用 getComputedStyle 可以得到样式的计算值。 而append元素到 documentFragment 中时，是不会计算元素的样式表，所以documentFragment 性能更优。当然现在浏览器的优化已经做的很好了， 当append元素到document中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后。 1234567891011121314// 其他 ...window.requestAnimationFrame(function()&#123; const fragment = document.createDocumentFragment() for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) loop(curTotal - pageCount,curIndex + pageCount)&#125;)// ...","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ESM/ESBuild","slug":"ESM-ESBuild","date":"2022-09-13T09:11:35.000Z","updated":"2022-09-16T08:40:53.050Z","comments":true,"path":"/post/ESM-ESBuild.html","link":"","permalink":"http://yoursite.com/post/ESM-ESBuild.html","excerpt":"继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。","text":"ESModule继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。 在浏览器中通过 &lt;script type=&quot;module&quot;&gt; 原生支持 ESM。 https://www.cnblogs.com/zhaojian-08/p/14385312.html 导入/导出12345678// esm_index.jsexport const hello_world = 1export default function() &#123;&#125;&lt;script type=&quot;module&quot;&gt; import fn, &#123; hello_world &#125; from &#x27;./esm_index.js&#x27;&lt;/script&gt; 动态加载123456789101112// dynamic-m.jsexport const dynamic_value = &#x27;动态加载&#x27;export default function() &#123; console.log(&#x27;default&#x27;)&#125;mport(&#x27;./dynamic-m.js&#x27;) .then(module =&gt; &#123; // module: &#123; default: fn, dynamic_value: &#x27;动态加载&#x27; &#125; console.log(&#x27;动态&#x27;, module) &#125;) ESBuild https://esbuild.github.io/api/ 介绍: https://juejin.cn/post/6918927987056312327","categories":[],"tags":[{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"}]},{"title":"深入浅出TypeScript","slug":"深入浅出TypeScript","date":"2022-09-09T02:35:36.000Z","updated":"2022-09-13T03:03:59.001Z","comments":true,"path":"/post/深入浅出TypeScript.html","link":"","permalink":"http://yoursite.com/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html","excerpt":"TypeScript","text":"TypeScript.d.ts 和 declare 是干嘛用的如果一个文件有扩展名 .d.ts，则表示它是一个声明文件，可以用来声明全局的类型定义和接口，或者是其它模块。比如： 1234567891011121314151617181920// global.d.ts// 声明接口declare interface Person &#123; name: string; age: number;&#125;// 声明类型 (别名)declare type TName = string;// 声明模块declare module &#x27;*.css&#x27;;declare module &#x27;*.less&#x27;;declare module &#x27;*.png&#x27;;// 拓展 window 属性，在 window 对象上显式设置属性declare interface Window &#123; MyNameSpace: any&#125; 但是也不是说创建了.d.ts文件，里面声明的东西就能生效了，毕竟归根到底也是.ts文件，需要预编译，所以需要在tsconfig.json文件里面的include数组里面添加 global.d.ts 文件。 1&quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;] .d.ts 文件中的顶级声明必须以 “declare” 或 “export” 修饰符开头。通过declare声明的类型或者变量或者模块，在include包含的文件范围内，都可以直接引用。 12345// .vue setup / .tsconst me: Person = &#123; name: &#x27;alex.cheng&#x27;, age: 18&#125; 注意.d.ts文件顶级声明declare最好不要跟export同级使用，不然在其他ts文件引用这个.d.ts的内容的时候，就需要手动import导入了。 12345678// global.d.tsexport type TName = string;// 这个时候，外部 ts 就无法直接使用 Person 了，需要引入 import &#123; Person &#125; from &#x27;../global.d.ts&#x27;export declare interface Person &#123; name: string; age: number;&#125; 给对象分配动态（未知）属性1234567891011121314const o: &#123; [key: string]: any &#125; = &#123;&#125;// 使用 ts 内置工具 Record，效果同上const o: Record&lt;string, any&gt; = &#123;&#125;interface IPerson extends Record&lt;string, any&gt; &#123; name: string; age?: number;&#125;const me1: IPerson = &#123; name: &#x27;alex&#x27;, hair: &#x27;black&#x27;&#125; interface 和 type 有什么区别 接口和类型别名都可以用来描述对象的形状或函数签名。 与接口类型不一样的是，类型别名可以用于一些其他类型，比如原始类型、联合类型（|）和元组。 接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。 interface 扩展（接口、类型）使用 extends 关键字，类型别名扩展（接口、类型）使用的是 交叉类型（&amp;）: 123456789101112131415// 接口扩展interface IPerson &#123; name: string;&#125;interface IMe extends IPerson &#123; age: number;&#125;// 类型扩展type TPerson = &#123; name: string;&#125;type TMe = TPerson &amp; &#123; age: number;&#125; 类可以以相同的方式实现(implements)接口或类型别名，但类不能实现使用类型别名定义的联合类型 12345678910111213// Error:type PartialPoint = &#123; x: number; &#125; | &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; // 类只能实现具有静态已知成员的对象类型或对象类型的交集。ts(2422) x = 1; y = 2;&#125;// Successtype PartialPoint = &#123; x: number; &#125; &amp; &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; x = 1; y = 2;&#125; 与类型别名不同，接口可以定义多次，会被自动合并为单个接口。 123456789101112interface IMerge &#123; a: 1;&#125;interface IMerge &#123; b: 2&#125;const ab: IMerge = &#123;&#125;; // 类型“&#123;&#125;”缺少类型“IMerge”中的以下属性: a, bts(2739)// Error: 标识符“TOne”重复。ts(2300)type TOne = string;type TOne = number; 类型保护 typeof instanceof in 参考资料TS 学习指南 ↩深入理解TypeScript ↩","categories":[],"tags":[{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"}]},{"title":"移动端开发实践","slug":"app-h5","date":"2022-06-09T06:26:40.000Z","updated":"2022-06-09T06:44:26.042Z","comments":true,"path":"/post/app-h5.html","link":"","permalink":"http://yoursite.com/post/app-h5.html","excerpt":"React Native 、H5移动端开发实践","text":"WebView现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发，它具备开发周期短、灵活性好的优点，但是缺点也很明显，加载速度慢 &amp; 消耗流量。引起缺点的主要原因如下： js解析效率，以及手机硬件设备的性能 页面资源的下载（图片、js文件、css文件） 参考资料Android Webview H5 秒开方案实现 ↩","categories":[],"tags":[{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"}]},{"title":"如何编写高标准的 JavaScript 代码","slug":"js-advice","date":"2022-03-31T02:12:23.000Z","updated":"2022-04-08T02:42:23.957Z","comments":true,"path":"/post/js-advice.html","link":"","permalink":"http://yoursite.com/post/js-advice.html","excerpt":"代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。","text":"概述你是否曾经为了提供一个简单的应用解决方案而彻夜地查看源代码？你是否曾经为了理解某个框架而冥思苦想、阅览群书？你是否曾经为了提升0.1s的DOM性能而对多种实现方案进行严格测试和对比？你是否曾经为了避免兼容问题而遍寻高手共同“诊治”？ 跟我一起，专注高质量 JavaScript 代码，少出 Bug🐛，早下班 ! 期望为读者带来如下帮助 📚： ❑ 能写出简单、清晰、高效的代码。 ❑ 能搭建一个稳定、健壮、快捷的应用框架。 ❑ 能回答一个困扰很多人的技术问题。 ❑ 能修复一个应用开发中遇到的大的Bug。 ❑ 能非常熟悉某个开源产品。 ❑ 能提升客户端应用性能。 JavaScript 基础代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。 减少全局变量 多个全局变量都追加在一个名称空间下，将显著降低与其他应用程序产生冲突的概率 123const namespace = &#123;&#125;namespace.name = &#x27;my namespace&#x27; 使用闭包体将信息隐藏，它是另一种有效减少“全局污染”的方法。 1234567const sayName = function() &#123; const name = &#x27;closure&#x27; return function() &#123; alert(name) &#125;&#125;() 作用域控制着变量与参数的可见性及生命周期。 JavaScript支持函数作用域，定义在函数中的参数和变量在函数外部是不可见的，并且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。它不仅减少了名称冲突，并且提供了自动内存管理。 ES6 模块化编程中每个 js 文件内部定义的变量，外部无法获取。如果外部需要模块内部变量，通过 export 导出。 1234567891011&lt;script&gt; var windowA = &#x27;window a&#x27; console.log(window.windowA) // 输出 &#x27;window a&#x27;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; var moduleA = &#x27;module a&#x27; console.log(window.moduleA) // 输出 undefined&lt;/script&gt; 谨慎JS数据类型在自动转换数据类型时，JavaScript一般遵循：如果某个类型的值被用于需要其他类型的值的环境中，JavaScript就自动将这个值转换成所需要的类型。 类型转换慎用JavaScript类型自动转换，注意自动转换规则: 如果把非空对象用在逻辑运算环境中，则对象被转换为true。此时的对象包括所有类型的对象，即使是值为false的包装对象也被转换为true。 果把对象用在数值运算环境中，则对象会被自动转换为数字，如果转换失败，则返回值为NaN。 当数组被用在数值运算环境中时，数组将根据包含的元素来决定转换的值。如果数组为空数组，则被转换为数值0。如果数组仅包含一个数字元素，则被转换为该数字的数值。如果数组包含多个元素，或者仅包含一个非数字元素，则返回NaN。 🌰 123456789101112// 对象const obj = &#123;&#125;obj &amp;&amp; 1 &gt;&gt; 1obj + 1 &gt;&gt; &#x27;[object Object]1&#x27;obj.valueOf = function() &#123; return 99 &#125;obj + 1 &gt;&gt; 100// 数组自动转换规则+[] &gt;&gt; 0+[1] &gt;&gt; 1+[1,2] &gt;&gt; NaN 类型判断 typeof对于任何变量来说，使用typeof运算符总是以字符串的形式返回以下6种类型之一：❑ “number”❑ “string”❑ “boolean”❑ “object”❑ “function”❑ “undefined” 令人疑惑的是，在使用 typeof 检测null值时，返回的是“object”，而不是“null”。 12345typeof null &gt;&gt; &#x27;object&#x27;typeof [] &gt;&gt; &#x27;object&#x27;typeof &#123;&#125; &gt;&gt; &#x27;object&#x27; instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 这个在判断对象时存在一些不确定性，来看下例子： 🌰 123456function Person(name) &#123; this.name = name&#125;const p = new Person(&#x27;hello&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 再看一个🌰: 123456789101112131415function Person(name) &#123; this.name = name&#125;function Child(name) &#123; this.name = name&#125;Child.prototype = Person.prototypeChild.prototype.constructor = Childconst p = new Child(&#x27;hello child&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 如果是判断数组呢? 1234567[] instanceof Array &gt;&gt; true[] instanceof Object &gt;&gt; true// 当然这种方式存在不确定性，我们可以使用 Array.isArray() 方法来判断Array.isArray([]) &gt;&gt; trueArray.isArray(&#123;&#125;) &gt;&gt; false 从上面例子可以看出，使用 instanceof 来判断时存在种种不确定性，只要出现在原型链上的对象都会返回 true，使用的时候还需要着重注意！ 为什么会这样，想必大家应该想起来了！ Object类是所有对象类型的的父类! toString() 方法 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 toString() 方法，它定义在 Object 的原型对象上，对象在调用时会返回一个表示该对象的字符串。 使用 toString() 方法检测对象类型是最安全、最准确的。调用toString()方法把对象转换为字符串，然后通过检测字符串中是否包含数组所特有的标志字符可以确定对象的类型。 为什么说 toString 方法用来检测对象类型是最安全、最准确的，我们慢慢来看吧~ 先看看在对象上直接使用 toString会是什么结果： 1234567891011121314const obj = &#123; a: 1 &#125;const arr = [1, 2]obj.toString() &gt;&gt; &#x27;[object Object]&#x27;// 如果是数组的话，则输出字符串arr.toString() &gt;&gt; &#x27;1,2&#x27;// 当然我们可以重写/覆盖原型链上的 toString 方法obj.toString = function() &#123; return &#x27;overwrite&#x27;&#125;obj.toString() &gt;&gt; &#x27;overwrite&#x27; 既然 toString 方法定义在原型对象上，我们看看如果单独调用它，会是什么结果呢? 1Object.prototype.toString() &gt;&gt; &#x27;[object Object]&#x27; 如果通过 call/apply 方法，改变 toString 方法内部的 this 执行，又会是什么结果呢? 看到如下结果，我相信这绝对可以完美 cover 住项目里面所有的类型判断了！所以说它是最安全、最准确的类型判断，没有异议吧😏 12345678910111213141516171819202122Object.prototype.toString.call(&#123;&#125;) &gt;&gt; &#x27;[object Object]&#x27;Object.prototype.toString.call([]) &gt;&gt; &#x27;[object Array]&#x27;Object.prototype.toString.call(function()&#123;&#125;) &gt;&gt; &#x27;[object Function]&#x27;Object.prototype.toString.call(&#x27;&#x27;) &gt;&gt; &#x27;[object String]&#x27;Object.prototype.toString.call(1) &gt;&gt; &#x27;[object Number]&#x27;Object.prototype.toString.call(true) &gt;&gt; &#x27;[object Boolean]&#x27;Object.prototype.toString.call(null) &gt;&gt; &#x27;[object Null]&#x27;Object.prototype.toString.call(undefined) &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call() &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call(new Date()) &gt;&gt; &#x27;[object Date]&#x27;Object.prototype.toString.call(/at/) &gt;&gt; &#x27;[object RegExp]&#x27; 那么它是如何做到的呢，我们来扒一扒它的原理！在 toString 方法被调用时，会执行以下几个操作步骤: 获取this指向的那个对象的[[Class]]属性的值。（call/apply 改变 this 指向） 计算出三个字符串”[object “、 第一步的操作结果、 以及 “]” 连接后的新字符串。 返回第二步的操作结果，也就是类似 &#39;[object Type]&#39; 这种格式字符串。 需要注意的是，对象的[[Class]]属性是无法直接访问的，它一个内部属性，所有的对象(原生对象和宿主对象)都拥有该属性，且不能被任何人修改。在规范中，[[Class]]是这么定义的：内部属性描述。 如果要单独或者对象的 [[Class]]，我们可以这样做: 12const targetObj = []Object.prototype.toString.call(targetObj).slice(8, -1) &gt;&gt; &#x27;Array&#x27; 既然它如此好用，难道就没有缺点吗？ 答案是当然有的，毕竟凡事都不可能那么绝对的嘛！ 那么缺点是什么呢？第一，toString() 会进行装箱操作，产生很多临时对象。（装箱就是将基本类型的数据，通过引用类型包装起来，从而可以使用引用类上的方法） 12345// 你肯定不能这样用1.toString() &gt;&gt; SyntaxError: Invalid or unexpected token// 你必须这样用(1).toString() &gt;&gt; &#x27;1&#x27; 第二，无法区分自定义对象类型，用来判断这类对象时，返回的都是Object，这样我们就需要通过 instanceof 来判断了。 1234function Person()&#123;&#125;const p = new Person()Object.prototype.toString.call(p) &gt;&gt; &#x27;[object Object]&#x27; 字符串JavaScript解释器强制约定字符串在堆区存储的数据是不可变的，也就是说，JavaScript解释器强制约定字符串在堆区存储的数据是不可变的。 参考资料参考资料 ↩参考资料2 ↩","categories":[],"tags":[{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"}]},{"title":"React Hooks","slug":"react-hooks","date":"2022-03-26T10:41:01.000Z","updated":"2022-09-16T08:22:44.579Z","comments":true,"path":"/post/react-hooks.html","link":"","permalink":"http://yoursite.com/post/react-hooks.html","excerpt":"什么是React Hooks，为什么需要它？如何高效的使用React Hooks？如何自定义 Hooks ？如何通过 Hooks 做性能优化？","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 动机Hook 规则 只在最顶层使用 Hook 只在 React 函数中调用 Hook。（或：在自定义 Hook 中调用其他 Hook） 使用 useCallback、useMemo、memo 做性能优化尽可能的保证组件不去发生变化，发生变化的因素有：state、props、context。 那么 React 是如何比较这三者的呢？ 答案是 内存地址。 比如说，对比一个 function，对比的就是这个函数在内存中的地址，通过地址的判断，从而判断 props 是否发生了改变。 React.memo https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate React.memo 包裹一个组件，来对它的 props 进行浅比较。等效于 PureComponent，但它只比较 props。（也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。） 123456789101112131415161718192021222324// 不使用 memo，每一次 setCount，都会造成 Child 组件重新 renderconst Child = () =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;const Demo = () =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child /&gt; &lt;/&gt; )&#125;// 通过 memo 包裹后，Child 组件不会再重新 render了。const Child = memo(() =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;) 当 memo 感知 props 没有发生改变时，不会重新 render 组件。如果传入 count 进来，Child组件就会重新 render。 总结： 如果我们将 setCount 当做 prop 传入进来，Child 不会重新render（因为 setCount 在内存中的地址没有发生改变） 如果传入我们自己定义的方法 (fn)进来，Child会重新 render，因为 Demo 组件每次更新 count 后，重新生成了 fn 函数。 只是传了个 fn ，不想让 Child 组件更新怎么办？那就要用到 useCallback 钩子了 useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算。 1234// 只有当 count 发生变化时，才会重新计算const computedCount = useMemo(() =&gt; &#123; return count * 2&#125;, [count]) useMemo 也允许你跳过一次子节点的昂贵的重新渲染，比如组件初始化时，需要一次大量的计算，后续就不会再改变了： 123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; )&#125; useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。 下面这个例子，即使我们用 memo 包裹了组件，因为 setCount 每次会引起 Demo 组件重新 render，生成了新的 fn 函数(内存地址发生了变化)，导致 Child 也会重新 render。 123456789101112131415161718192021interface IChild &#123; fn: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;&#125;const Child = memo((props: IChild) =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;)const Demo = () =&gt; &#123; const [count, setCount] = useState(0) const fn = () =&gt; console.log(&#x27;is fn&#x27;) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/&gt; )&#125; 我们不想让 fn 函数的 内存地址 发生变化，怎么办呢？使用 useCallback 钩子将其包裹起来即可。 注意：useMemo 也可以这样用，缓存 fn，从而使得 Child 组件不会重复 render。 1234567// 省略...const fn = useCallback(() =&gt; &#123; console.log(&#x27;is fn&#x27;)&#125;, [])// 省略... 这样 fn 函数就是一个缓存函数了，即使 count 不停的发生变化，也不会造成 Child 组件重复 render。 总结: 当 Demo 组件内部 state 发生了改变引起 Demo 和 Child 组件重新 render 并且 Child 组件接受了一个来自 Demo 组件自定义的方法（fn） 如果不希望 Child 组件重新 render，那么就需要用 useCallback 钩子将自定义方法 fn 包裹起来 因为 Child 组件 props 里面的 fn 和 useCallback 返回的 fn 指向的是内存中的同一个地址，那么 Child 组件就不会更新 useCallback 返回新函数的条件是：依赖项（第二个参数）发生了改变。 如果说我们的 Child 组件，本身就是需要根据 count 变化而变化，那么就不需要加这个缓存 API了，反而增加其计算负担。 设计组件不要为了使用钩子，过渡的使用钩子，好的页面设计，也许用不上这些钩子。 把不变的组件和变化的组件抽离出来！ 比如可以把 count 相关部分抽离成一个 Count 组件，使其和 Child 组件同层级排列，Count 组件和 Child 组件分开了，也不会引起 Child 组件做多余的 render。 12&lt;Count /&gt;&lt;Child prop=&#123;fn&#125; /&gt; 或者是通过 props.children 渲染 Child，也不会造成 Child 重新 render。 12345678910111213141516171819202122const Count = (props: any) =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &#123;/* children 不会重新 render */&#125; &#123;props.children&#125; &lt;/&gt; )&#125;const Demo = () =&gt; &#123; // fn 永远不会变化 const fn = () =&gt; &#123;&#125; return ( &lt;&gt; &lt;Count&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/Count&gt; &lt;/&gt; )&#125; useRef / createRef 访问 DOM 节点 123456const inputEle = useRef(null)const inputEle = React.createRef()inputEle.current.focus() 测量 DOM节点？1234567891011121314151617const getHeight = useMemo(() =&gt; &#123; return (node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125; &#125;&#125;, [])// 或者const getHeight = useCallback((node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125;&#125;, []) 将 ref 逻辑抽离成一个 Hook 1234567891011121314151617181920// hookconst useClientRect = () =&gt; &#123; const [rect, setRect] = useState(null) const ref = useCallback(node =&gt; &#123; if (node) &#123; setRect(node.getBoundingClientRect()) &#125; &#125;, []) return [rect, ref]&#125;// 使用const [rect, ref] = useClientRect()&lt;h1 ref=&#123;ref&#125;&gt;是 H1 标签 &#123;count&#125;&lt;/h1&gt;&#123; rect &amp;&amp; &lt;span&gt;&#123;rect.height&#125;&lt;/span&gt;&#125; React.forwardRef React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。 123456789const FancyInput = forwardRef((props, ref) =&gt; ( &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;))// 这样可以拿到 input 元素了const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt; useImperativeHandle useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 12345678910111213141516171819202122232425const FancyInput = forwardRef((props, ref) =&gt; &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125;, alert () &#123; alert(1) &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;;&#125;)const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt;// 通过 inputEle 获取到 useImperativeHandle 定义的方法inputEle.current.focus()inputEle.current.alert() 参考资料ahooks 官网 ↩","categories":[],"tags":[{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"}]},{"title":"Hello_AlexCc","slug":"first-article","date":"2019-07-29T15:37:50.000Z","updated":"2022-04-07T10:04:40.419Z","comments":true,"path":"/post/first-article.html","link":"","permalink":"http://yoursite.com/post/first-article.html","excerpt":"First Article","text":"What This is my first Blog. No.212345if (true) &#123; console.log(&quot;Hello_AlexCc!&quot;)&#125;return &quot;ヾ(◍°∇°◍)ﾉﾞ&quot;","categories":[],"tags":[{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}],"categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"},{"name":"JS,Vue-Router,Vue3,","slug":"JS-Vue-Router-Vue3","permalink":"http://yoursite.com/tags/JS-Vue-Router-Vue3/"},{"name":"JS,Vue3","slug":"JS-Vue3","permalink":"http://yoursite.com/tags/JS-Vue3/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"},{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"},{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"},{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"},{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"},{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}