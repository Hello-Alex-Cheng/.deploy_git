{"meta":{"title":"Hello_AlexCc","subtitle":"No pains, no gains.","description":"Technology Blog","author":"Hello_AlexCc","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About ME","date":"2022-03-30T02:53:37.000Z","updated":"2022-03-31T02:37:39.820Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"StoryA long time ago … A cat is sleeping，very very deep sleeping… Suddently, He find a mouse … God damn it, a so cute mouse! He don’t want to eat he, play with he."},{"title":"","date":"2022-11-30T03:01:38.680Z","updated":"2022-11-23T08:23:21.958Z","comments":false,"path":"demo/ObserverMode.html","permalink":"http://yoursite.com/demo/ObserverMode.html","excerpt":"","text":"观察者模式 ul { background-color: antiquewhite; } li { background-color: aqua; margin-top: 12px; } 面包屑 1 2 3 // 目标 class Subject { constructor() { this.observers = [] } add(ob) { this.observers.push(ob) } notify(text) { this.observers.forEach(o => { o.update(text) }) } } // 观察者 class Observer { constructor(name) { this.ele = document.querySelector(name) } update(text) { this.ele.innerHTML = text } } const s = new Subject() const o1 = new Observer('.bread') s.add(o1) let oLi = document.querySelectorAll('.left li') for (let i = 0; i < oLi.length; i++) { oLi[i].onclick = function () { s.notify(this.innerHTML) } }"},{"title":"","date":"2022-11-30T03:01:38.694Z","updated":"2022-11-23T12:48:03.716Z","comments":false,"path":"demo/timeFragment.html","permalink":"http://yoursite.com/demo/timeFragment.html","excerpt":"","text":"时间分片 // 记录任务开始时间 let now = Date.now(); // 插入十万条数据 const total = 100000; // 获取容器 let ul = document.getElementById('container'); // 将数据插入容器中 for (let i = 0; i < total; i++) { let li = document.createElement('li'); li.innerText = i ul.appendChild(li); } console.log('JS运行时间：', Date.now() - now); setTimeout(() => { console.log('总运行时间：', Date.now() - now); }, 0) // // --------- 分批渲染 --------- // //需要插入的容器 // let ul = document.getElementById('container'); // // 插入十万条数据 // let total = 100000; // // 一次插入 20 条 // let once = 20; // //总页数 // let page = total / once // //每条记录的索引 // let index = 0; // //循环加载数据 // function loop(curTotal, curIndex) { // if (curTotal { // for (let i = 0; i < pageCount; i++) { // let li = document.createElement('li'); // li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total) // ul.appendChild(li) // } // loop(curTotal - pageCount, curIndex + pageCount) // }, 0) // } // loop(total, index);"},{"title":"","date":"2022-11-30T03:05:16.656Z","updated":"2022-11-30T03:05:16.656Z","comments":false,"path":"demo/resizeObserver.html","permalink":"http://yoursite.com/demo/resizeObserver.html","excerpt":"","text":"Resize observer text test html { height: 100%; font-family: 'helvetica neue', arial, sans-serif; } body { height: inherit; margin: 0; display: flex; justify-content: center; align-items: center; } body>div { background-color: #eee; border: 1px solid #ccc; padding: 20px; width: 50%; min-width: 320px; } h1 { margin: 0; } p { line-height: 1.5; } form { width: 100%; } form>div { display: flex; } form label { flex: 2; } form input { flex: 3; } input[type=\"checkbox\"] { height: 2rem; } So what happened? https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver 记住，不要做任何影响任何事情的事情，除非事实证明你应该这么做，那样的话，看在上帝的份上，不要不做！我的灵魂！我不想被救。你们不是圣诞老人！你们都不是机器人。我得想办法逃离年轻时可怕的摧残。突然间，我每三个小时就要上一次厕所。社保局的那些混蛋也不再给我寄支票了。现在我得付钱给他们！ Observer enabled: Adjust width: if (window.ResizeObserver) { const h1Elem = document.querySelector('h1'); const pElem = document.querySelector('p'); const divElem = document.querySelector('body > div'); const slider = document.querySelector('input[type=\"range\"]'); const checkbox = document.querySelector('input[type=\"checkbox\"]'); divElem.style.width = '600px'; slider.addEventListener('input', () => { divElem.style.width = slider.value + 'px'; }) const resizeObserver = new ResizeObserver(entries => { console.log('entries', entries) for (let entry of entries) { if (entry.contentBoxSize) { // The standard makes contentBoxSize an array... if (entry.contentBoxSize[0]) { h1Elem.style.fontSize = Math.max(1.5, entry.contentBoxSize[0].inlineSize / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentBoxSize[0].inlineSize / 600) + 'rem'; } else { // ...but old versions of Firefox treat it as a single item h1Elem.style.fontSize = Math.max(1.5, entry.contentBoxSize.inlineSize / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentBoxSize.inlineSize / 600) + 'rem'; } } else { h1Elem.style.fontSize = Math.max(1.5, entry.contentRect.width / 200) + 'rem'; pElem.style.fontSize = Math.max(1, entry.contentRect.width / 600) + 'rem'; } } console.log('Size changed'); }); resizeObserver.observe(divElem); checkbox.addEventListener('change', () => { if (checkbox.checked) { resizeObserver.observe(divElem); } else { resizeObserver.unobserve(divElem); } }); } else { console.log('Resize observer not supported!'); }"},{"title":"","date":"2022-11-30T03:01:38.689Z","updated":"2022-11-23T09:03:02.974Z","comments":false,"path":"demo/PubSubMode.html","permalink":"http://yoursite.com/demo/PubSubMode.html","excerpt":"","text":"发布订阅者模式 ul { background-color: antiquewhite; } li { background-color: aqua; margin-top: 12px; } 面包屑 1 2 3 const PubSub = { message: {}, // 将事件存储数组，改成对象，key 表示事件类型，value 表示订阅的事件数组 publist(type, text) { if (!this.message[type]) return this.message[type].forEach(cb => { cb(text) }) }, subscribe(type, cb) { if (!this.message[type]) { this.message[type] = [cb] // 如果事件 type 不存在，我们就创建一个事件类型数组 } else { this.message[type].push(cb) } }, unsubscribe(type, cb) { // 取消订阅 if (!this.message[type]) return if (!cb) { // 取消所有订阅的事件 this.message[type] = [] } else { this.message[type] = this.message[type].filter(i => i !== cb) } } } PubSub.subscribe('updateBread', function (text) { const breadEle = document.querySelector('.bread') breadEle.innerHTML = text }) let oLi = document.querySelectorAll('.left li') for (let i = 0; i < oLi.length; i++) { oLi[i].onclick = function () { PubSub.publist('updateBread', this.innerHTML) } }"},{"title":"","date":"2022-12-25T13:17:28.022Z","updated":"2022-12-25T13:17:28.022Z","comments":false,"path":"demo/Vue3Reactive.html","permalink":"http://yoursite.com/demo/Vue3Reactive.html","excerpt":"","text":"Vue3 响应式原理 // 定义一个存储副作用函数的集合，每次设置对象时，我们就会取出集合里面的副作用函数，并执行 const bucket = new Set() const data = { text: 'helloworld' } const obj = new Proxy(data, { get(target, key) { // 添加副作用函数 // 每一次触发 get 方法，都会向 集合 中添加一次 effect 方法 // 但是集合是不会存储相同的值的（包括相同的内存地址） // 所以这里每一次执行 bucket.add 方法，因为 effect 地址没变，所以里面一直只会有一个副作用函数。 bucket.add(effect) return target[key] }, set(target, key, val) { target[key] = val // 批量执行副作用函数 bucket.forEach(fn => fn()) return true } }) // 执行副作用函数，会触发代理对象的 get 方法，从而收集到副作用函数 const effect = () => { document.body.innerHTML = obj.text } effect() // 一秒钟后，我们执行 代理对象的 set 操作，出发 set 方法 setTimeout(() => { obj.text = 'update obj text' console.log('??',bucket) }, 1000);"},{"title":"","date":"2022-12-25T13:17:28.037Z","updated":"2022-12-25T13:17:28.036Z","comments":false,"path":"demo/Vue3Reactive1.html","permalink":"http://yoursite.com/demo/Vue3Reactive1.html","excerpt":"","text":"Document let activeEffect = undefined const data = { text: 'hello world @.@' } function effect(fn) { activeEffect = fn fn() } const bucket = new WeakMap() // target => Map const obj = new Proxy(data, { get(target, key) { if (!activeEffect) return target[key] let depsMap = bucket.get(target) if (!depsMap) { // 关联 target 和 Map bucket.set(target, depsMap = new Map()) } let deps = depsMap.get(key) if (!deps) { // 依赖集合 depsMap.set(key, deps = new Set()) } deps.add(activeEffect) return target[key] }, set(target, key, val) { target[key] = val const depsMap = bucket.get(target) console.log('depsMap ', depsMap) if (!depsMap) return let effects = depsMap.get(key) effects && effects.forEach(fn => fn()) } }) // 注册副作用函数 effect(() => { console.log('text effect') document.body.innerHTML = obj.text // 读取 }) // effect(() => { // console.log('title effect') // obj.title = '标题123' // // document.title = obj.title // 读取 // }) setTimeout(() => { obj.notExist = 'hello vue3' }, 1000)"},{"title":"","date":"2022-12-25T13:17:28.044Z","updated":"2022-12-25T13:17:28.044Z","comments":false,"path":"demo/Vue3Reactive2.html","permalink":"http://yoursite.com/demo/Vue3Reactive2.html","excerpt":"","text":"收集 key 的依赖 // 存储被注册的副作用函数 let activeEffect; const data = { ok: true, text: 'hello world' } const bucket = new WeakMap() // target => Map const obj = new Proxy(data, { get(target, key) { // 追踪依赖 track(target, key) return target[key] }, set(target, key, value) { target[key] = value // 触发依赖 trigger(target, key) } }) function track(target, key) { if (!activeEffect) return target[key] let depsMap = bucket.get(target) if (!depsMap) { bucket.set(target, depsMap = new Map()) } let deps = depsMap.get(key) if (!deps) { depsMap.set(key, deps = new Set()) } // 添加副作用函数 deps.add(activeEffect) // deps 存储与该副作用函数相关联的依赖集合 // 将来在 cleanup 中通过 activeEffect.deps[i] delete effectFn 时，其实，就是将 deps 中的副作用函数删除了 activeEffect.deps.push(deps) } function trigger(target, key) { const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) const effectsToRun = new Set(effects) // effects && effects.forEach(fn => fn()) effectsToRun && effectsToRun.forEach(fn => fn()) } function effect(fn) { function effectFn() { activeEffect = effectFn cleanup(effectFn) fn() } effectFn.deps = [] // 存储所有包含当前副作用函数的依赖 集合，在 get 拦截函数中处理 deps effectFn() } function cleanup(effectFn) { console.log('effectFn ', effectFn.deps) // 我们删除 effectFn.deps[i] 中的 effectFn，其实就是删除了 'xxx'(key) 中对应的依赖集合的副作用函数 // effectFn.deps[i] 中，存放的依赖集合，和 Map key 对应的依赖集合，是同一个集合，删除某一项，自然会影响到另一个 // 当我们在 trigger 中执行 effects 时，就是执行副作用函数 // 这个时候，会执行 cleanup，删除所有的 key 对应的副作用函数，最后执行 fn，重新走 属性的读取逻辑，触发 get 方法，重新收集依赖 // 当我们设置 obj.ok = false 后，不会再读取 obj.text 了，从而不会对其 key 收集依赖。 for(let i = 0; i < effectFn.deps.length; i++) { const deps = effectFn.deps[i] deps.delete(effectFn) } effectFn.deps.length = 0 } effect(() => { console.log(' obj.ok', obj.ok) // obj.ok = true 会触发 obj 的 get拦截方法，并且通过 track 函数收集到了副作用函数，并且将其存储在 deps 中 document.body.innerHTML = obj.ok ? obj.text : 'ok not' }) setTimeout(() => { // obj.text = 'Vue3 Reactive' obj.ok = false console.log('bucket ', bucket) }, 1000) // setTimeout(() => { // console.log('执行了') // obj.text = 'Vue3 Reactive' // }, 3000)"},{"title":"","date":"2022-12-25T13:39:01.826Z","updated":"2022-12-25T13:39:01.826Z","comments":false,"path":"demo/Vue3Reactive3.html","permalink":"http://yoursite.com/demo/Vue3Reactive3.html","excerpt":"","text":"收集 key 的依赖 reactive let temp1, temp2; effect(function effect1() { console.log('effect1 执行') effect(function effect2() { console.log('effect2 执行') temp2 = obj.bar }) temp1 = obj.foo }) console.log('???', bucket) obj.foo = false // obj.bar = false"},{"title":"","date":"2022-12-25T14:13:05.830Z","updated":"2022-12-25T14:13:05.830Z","comments":false,"path":"demo/Vue3Reactive4.html","permalink":"http://yoursite.com/demo/Vue3Reactive4.html","excerpt":"","text":"收集 key 的依赖 reactive const data = { foo: 1 } const obj = handleProxy(data) // 控制次数 const jobQueue = new Set() const p = Promise.resolve() let isFlushing = false function flushJob() { if (isFlushing) return isFlushing = true p.then(() => { jobQueue.forEach(job => job()) }).finally(() => { isFlushing = false }) } effect(() => { console.log(obj.foo) }, { scheduler(fn) { // 调度 // setTimeout(fn) // 控制次数 // fn() // 会依次从 1 打印到 6，而我不在过程，只需要结果 6 // 由于 Set 集合的特殊性，多次添加同一个 fn，最终都只会有个 fn 在 set 中 jobQueue.add(fn) flushJob() } }) obj.foo++ obj.foo++ obj.foo++ obj.foo++ obj.foo++ console.log('结束了')"},{"title":"","date":"2022-12-25T14:17:31.440Z","updated":"2022-12-25T14:17:31.440Z","comments":false,"path":"demo/reactive.js","permalink":"http://yoursite.com/demo/reactive.js","excerpt":"","text":"// 存储被注册的副作用函数 let activeEffect; // 副作用函数栈，用来存储当前执行的副作用函数，当副作用函数发生嵌套时，避免函数错误的使用 const effectStack = [] const bucket = new WeakMap() // target => Map const handleProxy = data => { return new Proxy(data, { get(target, key) { // 追踪依赖 track(target, key) return target[key] }, set(target, key, value) { target[key] = value // 触发依赖 trigger(target, key) } }) } function track(target, key) { if (!activeEffect) return target[key] let depsMap = bucket.get(target) if (!depsMap) { bucket.set(target, depsMap = new Map()) } let deps = depsMap.get(key) if (!deps) { depsMap.set(key, deps = new Set()) } deps.add(activeEffect) activeEffect.deps.push(deps) } function trigger(target, key) { const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) // 避免无限循环 // const effectsToRun = new Set(effects) const effectsToRun = new Set() effects && effects.forEach(effectFn => { if (effectFn !== activeEffect) { effectsToRun.add(effectFn) } }) effectsToRun && effectsToRun.forEach(fn => { if (fn.options.scheduler) { fn.options.scheduler(fn) } else { fn() } }) } function effect(fn, options = {}) { function effectFn() { activeEffect = effectFn cleanup(effectFn) effectStack.push(effectFn) // 执行副作用函数 fn() effectStack.pop() activeEffect = effectStack[effectStack.length - 1] } effectFn.options = options effectFn.deps = [] // 开始执行 effectFn() } function cleanup(effectFn) { for(let i = 0; i < effectFn.deps.length; i++) { const deps = effectFn.deps[i] deps.delete(effectFn) } effectFn.deps.length = 0 }"},{"title":"","date":"2022-12-29T13:56:05.333Z","updated":"2022-12-29T13:56:05.333Z","comments":false,"path":"demo/theme/prefers-color-scheme.html","permalink":"http://yoursite.com/demo/theme/prefers-color-scheme.html","excerpt":"","text":"prefers-color-scheme .day { background: #eee; color: black; } .night { background: #333; color: white; } @media (prefers-color-scheme: dark) { .day.dark-scheme { background: #333; color: white; } .night.dark-scheme { background: black; color: red; } } @media (prefers-color-scheme: light) { .day.light-scheme { background: skyblue; color: #333; } .night.light-scheme { background: pink; color: #333; } } .day, .night { display: inline-block; padding: 1em; width: 7em; height: 7em; vertical-align: middle; } :root { --color: #333; --background-color: pink; } [data-theme=\"dark\"] { --color: #fff; --background-color: #000; } MDN: prefers-color-scheme CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。 Day (changes in light scheme) Day (changes in dark scheme) Night (changes in light scheme) Night (changes in dark scheme) dark mode window.onload = function() { // 如果匹配成功，scheme.matches === true // 也就是说，如果我们的系统是暗黑色，那么这个 matches 就是true，否则是 false const scheme = window.matchMedia('(prefers-color-scheme: dark)') scheme.addEventListener('change', e => { console.log(e) if (e.matches) { // 表示亮色模式 document.documentElement.setAttribute('data-theme', 'dark') } else { document.documentElement.setAttribute('data-theme', 'light') } }) const darkBtn = document.querySelector('.dark-btn') darkBtn.addEventListener('click', () => { // 设置主题色 document.documentElement.setAttribute('data-theme', 'dark') // document.documentElement.style.setProperty('--color', '#fff') // document.documentElement.style.setProperty('--background-color', '#000') }) }"},{"title":"","date":"2022-12-28T07:21:33.621Z","updated":"2022-12-28T07:21:33.621Z","comments":false,"path":"demo/webcomponent/README.html","permalink":"http://yoursite.com/demo/webcomponent/README.html","excerpt":"","text":"Web Components作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的 HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义 UI 控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。 组成 Custom elements（自定义元素） Shadow DOM（影子 DOM） HTML templates（HTML 模板） Custom elements（自定义元素）Shadow DOM（影子 DOM）templates and slots复用结构，减少使用相同的标记结构。 组件通信 Lightning Web Component 在 LWC 中，可以通过实现 CustomEvent 接口进行自定义事件，通过 EventTarget.dispatchEvent() 来分配事件。 注意： 定义事件时，不需要在事件名前加 on，因为在使用的时候会默认在名称前使用 on，比如：当我们定义了 click 事件，在 HTML 代码中用 onclick 来调用它 父组件 123456789101112131415// parent compconnectedCallback() &#123; const child = this.shadowRoot.querySelector(&#x27;child-wc&#x27;) // 1. 通过 DOM 属性传参，会触发子组件的 attributeChangedCallback 钩子 child.setAttribute(&#x27;text&#x27;, &#x27;Parent changed the Text&#x27;) // 2. 通过组件实例直接修改内部数据（⚠️未获取到） // console.log(&#x27;??&#x27;, child) // 3. 监听子组件内部定义的事件 child.addEventListener(&#x27;custom-event&#x27;, (&#123; detail &#125;) =&gt; &#123; console.log(&#x27;事件触发 &#x27;, detail.value); &#125;) &#125; 子组件 12345678910111213141516// child compconnectedCallback() &#123; // 定义事件 const event = new CustomEvent(&#x27;custom-event&#x27;, &#123; detail: &#123; value: &#x27;child web component&#x27; &#125; &#125;) this.dispatchEvent(event) const btn = this.shadowRoot.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 获取父组件 this.getRootNode().host.sayHello(&#x27;Hello :&#x27;) &#125;)&#125; 子组件直接调用父组件实例上的方法123456789101112131415// parent compsayHello(msg) &#123; console.log(msg, this.data)&#125;// child compconnectedCallback() &#123; const btn = this.shadowRoot.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 获取父组件实例 this.getRootNode().host.sayHello(&#x27;Hello :&#x27;) &#125;)&#125; 监听组件上属性的变化1234567891011121314151617// parentconst child = this.shadowRoot.querySelector(&#x27;child-wc&#x27;)// 1. 通过 DOM 属性传参，会触发子组件的 attributeChangedCallback 钩子child.setAttribute(&#x27;text&#x27;, &#x27;Parent changed the Text&#x27;)// child// 监听属性变化，必须定静态的 observedAttributes 方法static get observedAttributes() &#123; return [&#x27;text&#x27;];&#125;attributeChangedCallback(name, oldValue, newValue) &#123; console.log(&#x27;name&#x27;, name) console.log(&#x27;oldValue&#x27;, oldValue) console.log(&#x27;newValue&#x27;, newValue)&#125; 参考链接 MDN官方文档 WC官方示例 基于 Web Components 跨框架组件开发 Shadow :host 选择器"},{"title":"","date":"2022-12-27T03:08:10.412Z","updated":"2022-12-27T03:08:10.412Z","comments":false,"path":"demo/webcomponent/composed-path/index.html","permalink":"http://yoursite.com/demo/webcomponent/composed-path/index.html","excerpt":"","text":"Document composed and composedPath demo"},{"title":"","date":"2022-12-27T03:07:36.904Z","updated":"2022-12-27T03:07:36.904Z","comments":false,"path":"demo/webcomponent/element-details-template/index.html","permalink":"http://yoursite.com/demo/webcomponent/element-details-template/index.html","excerpt":"","text":"Document element-details-template details {font-family: \"Open Sans Light\",Helvetica,Arial} .name {font-weight: bold; color: #217ac0; font-size: 120%} h4 { margin: 10px 0 -8px 0; } h4 span { background: #217ac0; padding: 2px 6px 2px 6px } h4 span { border: 1px solid #cee9f9; border-radius: 4px } h4 span { color: white } .attributes { margin-left: 22px; font-size: 90% } .attributes p { margin-left: 16px; font-style: italic } dl { margin-left: 6px; } dt { font-weight: bold; color: #217ac0; font-size: 110% } dt { font-family: Consolas, \"Liberation Mono\", Courier } dd { margin-left: 16px } &lt;NEED NAME&gt; NEED DESCRIPTION Attributes None Hello_AlexCc A mechanism for holding client- side content that is not to be rendered when a page is loaded but may subsequently be instantiated during runtime using JavaScript. name The name of the slot."},{"title":"","date":"2022-12-27T03:17:25.840Z","updated":"2022-12-27T03:17:25.840Z","comments":false,"path":"demo/webcomponent/composed-path/main.js","permalink":"http://yoursite.com/demo/webcomponent/composed-path/main.js","excerpt":"","text":"customElements.define('open-shadow', class extends HTMLElement { constructor() { super(); } connectedCallback() { const pElem = document.createElement('p'); pElem.textContent = this.getAttribute('text'); const shadowRoot = this.attachShadow({mode: 'open'}); shadowRoot.appendChild(pElem); } } ); customElements.define('closed-shadow', class extends HTMLElement { constructor() { super(); } connectedCallback() { const pElem = document.createElement('p'); pElem.textContent = this.getAttribute('text'); const shadowRoot = this.attachShadow({mode: 'closed'}); shadowRoot.appendChild(pElem); } } ); document.querySelector('html').addEventListener('click', e => { console.log(e.composed); console.log(e.composedPath()); });"},{"title":"","date":"2022-12-27T06:41:41.012Z","updated":"2022-12-27T06:41:41.012Z","comments":false,"path":"demo/webcomponent/parent-send-data-to-child/index.html","permalink":"http://yoursite.com/demo/webcomponent/parent-send-data-to-child/index.html","excerpt":"","text":"Life cycle callbacks test 00 Child Button parent template"},{"title":"","date":"2022-12-27T07:37:18.375Z","updated":"2022-12-27T07:37:18.375Z","comments":false,"path":"demo/webcomponent/parent-send-data-to-child/main.js","permalink":"http://yoursite.com/demo/webcomponent/parent-send-data-to-child/main.js","excerpt":"","text":"class ParentWc extends HTMLElement { constructor() { super() this.data = { value: 'Parent instance value' } const template = document.getElementById('parent').content const shadowRoot = this.attachShadow({mode: 'open'}) shadowRoot.appendChild(template.cloneNode(true)) } sayHello(msg) { console.log(msg, this.data) } connectedCallback() { const child = this.shadowRoot.querySelector('child-wc') // 1. 通过 DOM 属性传参 // child.setAttribute('text', 'Parent changed the Text') // 2. 通过组件实例直接修改内部数据（目前主流的形式） // console.log('??', child) // 3. 事件监听 child.addEventListener('custom-event', ({ detail }) => { console.log('事件触发 ', detail.value); }) } } window.customElements.define('parent-wc', ParentWc) // childWc class ChildWc extends HTMLElement { constructor() { super() this.data = { value: 'Child instance value' } Object.defineProperty(this.data, 'text', { set: value => { console.log('data text changed: ', value) } }) const template = document.getElementById('child').content const shadowRoot = this.attachShadow({mode: 'open'}) shadowRoot.appendChild(template.cloneNode(true)) } // 必须先申明需要监听的属性 static get observedAttributes() { return ['text']; } connectedCallback() { const event = new CustomEvent('custom-event', { detail: { value: 'child web component' } }) this.dispatchEvent(event) const btn = this.shadowRoot.querySelector('button') btn.addEventListener('click', () => { // 获取父组件 this.getRootNode().host.sayHello('Hello :') }) } attributeChangedCallback(name, oldValue, newValue) { console.log('name', name) console.log('oldValue', oldValue) console.log('newValue', newValue) } } window.customElements.define('child-wc', ChildWc);"},{"title":"","date":"2022-12-26T16:05:08.235Z","updated":"2022-12-26T16:05:08.235Z","comments":false,"path":"demo/webcomponent/template&slot/main.js","permalink":"http://yoursite.com/demo/webcomponent/template&slot/main.js","excerpt":"","text":"// 单独使用 // window.onload = function() { // let template = document.getElementById('my-paragraph'); // let templateContent = template.content; // document.body.appendChild(templateContent); // } // 在 Web Components 中使用模板 class MyParagraph extends HTMLElement { constructor() { super() } connectedCallback() { let template = document.getElementById('my-paragraph'); let templateContent = template.content; this.attachShadow({ mode: 'open' }) .appendChild(templateContent.cloneNode(true)) } } customElements.define('my-paragraph', MyParagraph)"},{"title":"","date":"2022-12-31T08:51:54.342Z","updated":"2022-12-31T08:51:54.342Z","comments":false,"path":"demo/webcomponent/template&slot/index.html","permalink":"http://yoursite.com/demo/webcomponent/template&slot/index.html","excerpt":"","text":"Document template & slot Default Title default slot My paragraph Slot title"},{"title":"","date":"2022-12-26T14:51:47.978Z","updated":"2022-12-26T14:51:47.978Z","comments":false,"path":"demo/webcomponent/popup-info-box/index.html","permalink":"http://yoursite.com/demo/webcomponent/popup-info-box/index.html","excerpt":"","text":"Document Pop-up info widget - web components Enter your CVC"},{"title":"","date":"2022-12-27T02:59:08.495Z","updated":"2022-12-27T02:59:08.495Z","comments":false,"path":"demo/webcomponent/element-details-template/main.js","permalink":"http://yoursite.com/demo/webcomponent/element-details-template/main.js","excerpt":"","text":"class DetailsElement extends HTMLElement { constructor() { super() const template = document.getElementById('element-details-template').content const shadowRoot = this.attachShadow({mode: 'open'}) shadowRoot.appendChild(template.cloneNode(true)) console.log('host ', shadowRoot.host === this) // ShadowRoot 附加的宿主 DOM 元素。 } } const a = customElements.define('details-element', DetailsElement) console.log('?? ', customElements.get('details-element')) console.log('?? a', a)"},{"title":"","date":"2022-12-26T14:55:34.842Z","updated":"2022-12-26T14:55:34.842Z","comments":false,"path":"demo/webcomponent/popup-info-box/main.js","permalink":"http://yoursite.com/demo/webcomponent/popup-info-box/main.js","excerpt":"","text":"// Create a class for the element class PopUpInfo extends HTMLElement { constructor() { // Always call super first in constructor super(); } connectedCallback() { /** * @name connectedCallback函数 * @desc 当 custom element 首次被插入文档 DOM 时，被调用。 */ // Create a shadow root const shadow = this.attachShadow({mode: 'open'}); // Create spans const wrapper = document.createElement('span'); wrapper.setAttribute('class', 'wrapper'); const icon = document.createElement('span'); icon.setAttribute('class', 'icon'); icon.setAttribute('tabindex', 0); const info = document.createElement('span'); info.setAttribute('class', 'info'); /** * @name 🔥🔥🔥 我们想要获取元素上的属性，必须放在 connectedCallback 函数内去获取 * @desc 因为只有元素插入到了 dom 中，才能获取到 */ const text = this.getAttribute('data-text'); info.textContent = text; // Insert icon let imgUrl; if(this.hasAttribute('img')) { imgUrl = this.getAttribute('img'); } else { // imgUrl = './img/avatar.jpg'; } const img = document.createElement('img'); img.src = imgUrl; icon.appendChild(img); // Create some CSS to apply to the shadow dom const style = document.createElement('style'); console.log(style.isConnected); style.textContent = ` .wrapper { position: relative; } .info { font-size: 0.8rem; width: 200px; display: inline-block; border: 1px solid black; padding: 10px; background: white; border-radius: 10px; opacity: 0; transition: 0.6s all; position: absolute; bottom: 20px; left: 10px; z-index: 3; } img { width: 1.2rem; } .icon:hover + .info, .icon:focus + .info { opacity: 1; } `; // Attach the created elements to the shadow dom shadow.appendChild(style); // 一开始这个style.isConnected 为false，把他添加给shadow Root后 isConnected就为true了 console.log(style.isConnected); shadow.appendChild(wrapper); wrapper.appendChild(icon); wrapper.appendChild(info); } } // Define the new element customElements.define('popup-info', PopUpInfo);"},{"title":"","date":"2022-12-26T15:33:34.314Z","updated":"2022-12-26T15:33:34.314Z","comments":false,"path":"demo/webcomponent/expanding-list/iframe.html","permalink":"http://yoursite.com/demo/webcomponent/expanding-list/iframe.html","excerpt":"","text":"iframe body { background-color: coral; } iframe body iframe page"},{"title":"","date":"2022-12-27T06:41:05.973Z","updated":"2022-12-27T06:41:05.973Z","comments":false,"path":"demo/webcomponent/expanding-list/main.js","permalink":"http://yoursite.com/demo/webcomponent/expanding-list/main.js","excerpt":"","text":"// Create a class for the element class Square extends HTMLElement { // Specify observed attributes so that // attributeChangedCallback will work static get observedAttributes() { return ['c', 'l']; } constructor() { // Always call super first in constructor super(); const shadow = this.attachShadow({mode: 'open'}); const div = document.createElement('div'); const style = document.createElement('style'); shadow.appendChild(style); shadow.appendChild(div); } connectedCallback() { console.log('connectedCallback 当 custom element 首次被插入文档 DOM 时，被调用。'); updateStyle(this); } disconnectedCallback() { console.log('Custom square element 从页面上被删除！'); } adoptedCallback() { console.log('Custom square element 移动到了一个新的页面？'); } attributeChangedCallback(name, oldValue, newValue) { console.log('Custom square element 属性发生了改变'); updateStyle(this); } } customElements.define('custom-square', Square); function updateStyle(elem) { const shadow = elem.shadowRoot; shadow.querySelector('style').textContent = ` div { width: ${elem.getAttribute('l')}px; height: ${elem.getAttribute('l')}px; background-color: ${elem.getAttribute('c')}; } `; } const add = document.querySelector('.add'); const update = document.querySelector('.update'); const remove = document.querySelector('.remove'); const move = document.querySelector('.move'); const other = document.querySelector('.other'); let square; update.disabled = true; remove.disabled = true; move.disabled = true; function random(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); } add.onclick = function() { // Create a custom square element square = document.createElement('custom-square'); square.setAttribute('l', '100'); square.setAttribute('c', 'red'); document.body.appendChild(square); update.disabled = false; remove.disabled = false; move.disabled = false; add.disabled = true; }; update.onclick = function() { // Randomly update square's attributes square.setAttribute('l', random(50, 200)); square.setAttribute('c', `rgb(${random(0, 255)}, ${random(0, 255)}, ${random(0, 255)})`); }; remove.onclick = function() { // Remove the square document.body.removeChild(square); update.disabled = true; remove.disabled = true; add.disabled = false; }; move.onclick = function() { const square1 = document.querySelector('custom-square') // move，我以为的移动到新文档 other.appendChild(square1) /** * @result 生命周期执行顺序: disconnectedCallback > connectedCallback * @desc 很尴尬，这不叫移动到新的文档么？ */ // 那我们来试试 iframe setTimeout(() => { const iframe = document.querySelector('iframe') iframe.contentDocument.querySelector('body').appendChild(square1) move.disabled = true }, 1500); // 这下就对了，生命周期执行顺序 disconnectedCallback > adoptedCallback > connectedCallback };"},{"title":"","date":"2022-12-26T15:33:53.083Z","updated":"2022-12-26T15:33:53.083Z","comments":false,"path":"demo/webcomponent/expanding-list/index.html","permalink":"http://yoursite.com/demo/webcomponent/expanding-list/index.html","excerpt":"","text":"Life cycle callbacks test custom-square { margin: 20px; } .other { /* position: absolute; */ top: 20%; left: 50%; width: 200px; height: 200px; background-color: #808080; } Life cycle callbacks test Add custom-square to DOM Update attributes Remove custom-square from DOM Move custom-square to new Dom"},{"title":"","date":"2022-12-31T14:11:32.903Z","updated":"2022-12-31T14:11:32.903Z","comments":false,"path":"demo/replace$1.html","permalink":"http://yoursite.com/demo/replace$1.html","excerpt":"","text":"Document const name = \"Doe, John\"; name.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\") // John, Doe console.log('\"a\", \"b\"'.replace(/\"([^\"]*)\"/g, \"'$1'\"))"}],"posts":[{"title":"Vue3项目实战(五)：通用功能开发(国际化/换肤)","slug":"vue3-project-generalModule","date":"2022-12-29T03:00:23.000Z","updated":"2022-12-31T16:14:11.735Z","comments":true,"path":"/post/vue3-project-generalModule.html","link":"","permalink":"http://yoursite.com/post/vue3-project-generalModule.html","excerpt":"国际化/换肤/screenfull/headerSearch/tagView/guide","text":"通用功能 国际化 动态换肤 screenfull headerSearch tagView guide 国际化实现原理先来看一个需求： 我们有一个变量 msg ，但是这个 msg 有且只能有两个值： hello world 你好世界 要求：根据需要切换 msg 的值 这样的一个需求就是 国际化 的需求，那么我们可以通过以下代码来实现这个需求 12345678910111213141516171819202122&lt;script&gt; // 1. 定义 msg 值的数据源 const messages = &#123; en: &#123; msg: &#x27;hello world&#x27; &#125;, zh: &#123; msg: &#x27;你好世界&#x27; &#125; &#125; // 2. 定义切换变量 let locale = &#x27;en&#x27; // 3. 定义赋值函数 function t(key) &#123; return messages[locale][key] &#125; // 4. 为 msg 赋值 let msg = t(&#x27;msg&#x27;) console.log(msg); // 修改 locale， 重新执行 t 方法，获取不同语言环境下的值&lt;/script&gt; 总结： 通过一个变量来 控制 语言环境 所有语言环境下的数据源要 预先 定义好 通过一个方法来获取 当前语言 下 指定属性 的值 该值即为国际化下展示值 基于 vue-i18n V9 的国际化实现方案分析在 vue 的项目中，我们不需要手写这么复杂的一些基础代码，可以直接使用 vue-i18n 进行实现（注意：vue3 下需要使用 V 9.x 的 i18n） vue-i18n 的使用可以分为四个部分： 创建 messages 数据源 创建 locale 语言变量 初始化 i18n 实例 注册 i18n 实例 那么接下来我们就去实现以下： 安装 vue-i18n1npm install vue-i18n@next 创建 i18n/index.js 文件 创建 messages 数据源 123456789101112const messages = &#123; en: &#123; msg: &#123; test: &#x27;hello world&#x27; &#125; &#125;, zh: &#123; msg: &#123; test: &#x27;你好世界&#x27; &#125; &#125;&#125; 创建 locale 语言变量 1const locale = &#x27;en&#x27; 初始化 i18n 实例 12345678910import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;const i18n = createI18n(&#123; // 使用 Composition API 模式，则需要将其设置为false legacy: false, // 全局注入 $t 函数 globalInjection: true, locale, messages&#125;) 把 i18n 注册到 vue 实例 1export default i18n 在 main.js 中导入 1234// i18n （PS：导入放到 APP.vue 导入之前，因为后面我们会在 app.vue 中使用国际化内容）import i18n from &#x27;@/i18n&#x27;...app.use(i18n) 在 layout/components/Sidebar/index.vue 中使用 i18n 123&lt;h1 class=&quot;logo-title&quot; v-if=&quot;$store.getters.sidebarOpened&quot;&gt; &#123;&#123; $t(&#x27;msg.test&#x27;) &#125;&#125;&lt;/h1&gt; 修改 locale 的值，即可改变展示的内容 截止到现在我们已经实现了 i18n 的最基础用法，那么解下来我们就可以在项目中使用 i18n 完成国际化。 项目中完成国际化分成以下几步进行: 封装 langSelect 组件用于修改 locale 导入 el-locale 语言包 创建自定义语言包 封装 langSelect 组件 定义 store/app.js 123456789101112131415161718192021import &#123; LANG &#125; from &#x27;@/constant&#x27;import &#123; getItem, setItem &#125; from &#x27;@/utils/storage&#x27;export default &#123; namespaced: true, state: () =&gt; (&#123; ... language: getItem(LANG) || &#x27;zh&#x27; &#125;), mutations: &#123; ... /** * 设置国际化 */ setLanguage(state, lang) &#123; setItem(LANG, lang) state.language = lang &#125; &#125;, actions: &#123;&#125;&#125; 在 constant 中定义常量 12// 国际化export const LANG = &#x27;language&#x27; 创建 components/LangSelect/index 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;el-dropdown trigger=&quot;click&quot; class=&quot;international&quot; @command=&quot;handleSetLanguage&quot; &gt; &lt;div&gt; &lt;el-tooltip content=&quot;国际化&quot; :effect=&quot;effect&quot;&gt; &lt;svg-icon icon=&quot;language&quot; /&gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu&gt; &lt;el-dropdown-item :disabled=&quot;language === &#x27;zh&#x27;&quot; command=&quot;zh&quot;&gt; 中文 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item :disabled=&quot;language === &#x27;en&#x27;&quot; command=&quot;en&quot;&gt; English &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useI18n &#125; from &#x27;vue-i18n&#x27;import &#123; defineProps, computed &#125; from &#x27;vue&#x27;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;defineProps(&#123; effect: &#123; type: String, default: &#x27;dark&#x27;, validator: function(value) &#123; // 这个值必须匹配下列字符串中的一个 return [&#x27;dark&#x27;, &#x27;light&#x27;].indexOf(value) !== -1 &#125; &#125;&#125;)const store = useStore()const language = computed(() =&gt; store.getters.language)// 切换语言的方法const i18n = useI18n()const handleSetLanguage = lang =&gt; &#123; i18n.locale.value = lang store.commit(&#x27;app/setLanguage&#x27;, lang) ElMessage.success(&#x27;更新成功&#x27;)&#125;&lt;/script&gt; 在 navbar 中导入 LangSelect 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; ... &lt;div class=&quot;right-menu&quot;&gt; &lt;lang-select class=&quot;right-menu-item hover-effect&quot; /&gt; &lt;!-- 头像 --&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import LangSelect from &#x27;@/components/LangSelect&#x27;...&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.navbar &#123; ... .right-menu &#123; ... ::v-deep .right-menu-item &#123; display: inline-block; padding: 0 18px 0 0; font-size: 24px; color: #5a5e66; vertical-align: text-bottom; &amp;.hover-effect &#123; cursor: pointer; &#125; &#125; ...&#125;&lt;/style&gt; element-plus 国际化处理截止到目前，我们的国际化内容已经基本功能已经处理完成了。接下来需要处理的就是对应的语言包，有了语言包就可以实现整个项目中的所有国际化处理了。 那么对于语言包来说，我们整个项目中会分成两部分： element-plus 语言包：用来处理 element 组件的国际化功能 自定义语言包：用来处理 非element 组件的国际化功能 那么首先我们先来处理 element-plus 语言包： 在 plugins/index 中导入 element 的中文、英文语言包： 12import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;import en from &#x27;element-plus/lib/locale/lang/en&#x27; 注册 element 时，根据当前语言选择使用哪种语言包 1234567import store from &#x27;@/store&#x27;export default app =&gt; &#123; app.use(ElementPlus, &#123; locale: store.getters.language === &#x27;en&#x27; ? en : zhCn &#125;)&#125; 自定义语言包国际化处理处理完 element 的国际化内容之后，接下来我们来处理 自定义语言包。 在本地创建 lang 文件夹，里面创建好本地需要的语言包，由于比较多，就放一部分来看看： 123456789101112131415161718192021// en.tsexport default &#123; login: &#123; title: &#x27;User Login&#x27;, loginBtn: &#x27;Login&#x27;, usernameRule: &#x27;Username is required&#x27;, passwordRule: &#x27;Password cannot be less than 6 digits&#x27;, &#125;, // other....&#125;// zh.tsexport default &#123; login: &#123; title: &#x27;用户登录&#x27;, loginBtn: &#x27;登录&#x27;, usernameRule: &#x27;用户名为必填项&#x27;, passwordRule: &#x27;密码不能少于6位&#x27;, &#125;, // other...&#125; 在 lang/index 中，导入语言包 12import mZhLocale from &#x27;./lang/zh&#x27;import mEnLocale from &#x27;./lang/en&#x27; 在 messages 中注册到语言包 123456789101112const messages = &#123; en: &#123; msg: &#123; ...mEnLocale &#125; &#125;, zh: &#123; msg: &#123; ...mZhLocale &#125; &#125;&#125; 处理项目国际化内容在处理好了国际化的语言包之后，接下来我们就可以应用国际化功能到我们的项目中 对于我们目前的项目而言，需要进行国际化处理的地方主要分为： 登录页面 navbar 区域 sidebar 区域 面包屑区域 那么这一小节，我们先来处理前两个 登录页面： login/index 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=&quot;login-container&quot;&gt; ... &lt;div class=&quot;title-container&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;&#123;&#123; $t(&#x27;msg.login.title&#x27;) &#125;&#125;&lt;/h3&gt; &lt;lang-select class=&quot;lang-select&quot; effect=&quot;light&quot;&gt;&lt;/lang-select&gt; &lt;/div&gt; ... &lt;el-button type=&quot;primary&quot; style=&quot;width: 100%; margin-bottom: 30px&quot; :loading=&quot;loading&quot; @click=&quot;handleLogin&quot; &gt;&#123;&#123; $t(&#x27;msg.login.loginBtn&#x27;) &#125;&#125;&lt;/el-button &gt; &lt;div class=&quot;tips&quot; v-html=&quot;$t(&#x27;msg.login.desc&#x27;)&quot;&gt;&lt;/div&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useI18n &#125; from &#x27;vue-i18n&#x27;...// 验证规则const i18n = useI18n()const loginRules = ref(&#123; username: [ &#123; ... message: i18n.t(&#x27;msg.login.usernameRule&#x27;) &#125; ], ...&#125;)...&lt;/script&gt; login/rules 1234567891011import i18n from &#x27;@/i18n&#x27;export const validatePassword = () =&gt; &#123; return (rule, value, callback) =&gt; &#123; if (value.length &lt; 6) &#123; callback(new Error(i18n.global.t(&#x27;msg.login.passwordRule&#x27;))) &#125; else &#123; callback() &#125; &#125;&#125; navbar 区域 layout/components/navbar 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; ... &lt;template #dropdown&gt; &lt;el-dropdown-menu class=&quot;user-dropdown&quot;&gt; &lt;router-link to=&quot;/&quot;&gt; &lt;el-dropdown-item&gt; &#123;&#123; $t(&#x27;msg.navBar.home&#x27;) &#125;&#125; &lt;/el-dropdown-item&gt; &lt;/router-link&gt; &lt;a target=&quot;_blank&quot; href=&quot;&quot;&gt; &lt;el-dropdown-item&gt;&#123;&#123; $t(&#x27;msg.navBar.course&#x27;) &#125;&#125;&lt;/el-dropdown-item&gt; &lt;/a&gt; &lt;el-dropdown-item divided @click=&quot;logout&quot;&gt; &#123;&#123; $t(&#x27;msg.navBar.logout&#x27;) &#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; components/LangSelect/index 123456&lt;el-tooltip :content=&quot;$t(&#x27;msg.navBar.lang&#x27;)&quot; :effect=&quot;effect&quot;&gt;const handleSetLanguage = lang =&gt; &#123; ... ElMessage.success(i18n.t(&#x27;msg.toast.switchLangSuccess&#x27;))&#125; sidebar 与 面包屑 区域的国际化处理sidebar 区域 目前对于 sidebar 而言，显示的文本是我们在定义路由表时的 title 1&lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; 我们可以 把 title 作为语言包内容的 key 进行处理 创建 utils/i18n 工具模块，用于 将 title 转化为国际化内容 12345import i18n from &#x27;@/i18n&#x27;export function generateTitle(title) &#123; return i18n.global.t(&#x27;msg.route.&#x27; + title)&#125; 在 layout/components/Sidebar/MenuItem.vue 中导入该方法： 12345678910&lt;template&gt; ... &lt;span&gt;&#123;&#123; generateTitle(title) &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; generateTitle &#125; from &#x27;@/utils/i18n&#x27;...&lt;/script&gt; 最后修改下 sidebarHeader 的内容 123&lt;h1 class=&quot;logo-title&quot; v-if=&quot;$store.getters.sidebarOpened&quot;&gt; &#123;&#123; $t(&#x27;msg.logo&#x27;) &#125;&#125;&lt;/h1&gt; 面包屑区域： 在 components/Breadcrumb/index 123456789101112131415161718&lt;template&gt;... &lt;!-- 不可点击项 --&gt; &lt;span v-if=&quot;index === breadcrumbData.length - 1&quot; class=&quot;no-redirect&quot;&gt;&#123;&#123; generateTitle(item.meta.title) &#125;&#125;&lt;/span&gt; &lt;!-- 可点击项 --&gt; &lt;a v-else class=&quot;redirect&quot; @click.prevent=&quot;onLinkClick(item)&quot;&gt;&#123;&#123; generateTitle(item.meta.title) &#125;&#125;&lt;/a&gt;...&lt;/template&gt;&lt;script setup&gt;import &#123; generateTitle &#125; from &#x27;@/utils/i18n&#x27;...&lt;/script&gt; 国际化缓存处理我们希望在 刷新页面后，当前的国际化选择可以被保留，所以想要实现这个功能，那么就需要进行 国际化的缓存处理 此处的缓存，我们依然通过两个方面进行： vuex 缓存 LocalStorage 缓存 只不过这里的缓存，我们已经在处理 langSelect 组件时 处理完成了，所以此时我们只需要使用缓存下来的数据即可。 在 i18n/index 中，创建 getLanguage 方法： 1234567import store from &#x27;@/store&#x27;/** * 返回当前 lang */function getLanguage() &#123; return store &amp;&amp; store.getters &amp;&amp; store.getters.language&#125; 修改 createI18n 的 locale 为 getLanguage() 1234const i18n = createI18n(&#123; ... locale: getLanguage()&#125;) 国际化方案总结国际化是前端项目中的一个非常常见的功能，那么在前端项目中实现国际化主要依靠的就是 vue-i18n 这个第三方的包。 关于国际化的实现原理大家可以参照 国际化实现原理 这一小节，这里我们就不再赘述了。 而 i18n 的使用，整体来说就分为这么四步： 创建 messages 数据源 创建 locale 语言变量 初始化 i18n 实例 注册 i18n 实例 核心的内容其实就是 数据源的部分，但是大家需要注意，如果你的项目中使用了 第三方组件库 ，那么不要忘记 第三方组件库的数据源 需要 单独 进行处理！ 动态换肤原理分析想要实现 动态换肤 的一个前置条件就是：色值不可以写死！ 首先我们先来说一下动态换肤的实现方式。 在 scss 中，我们可以通过 $变量名:变量值 的方式定义 css 变量 ，然后通过该 css 来去指定某一块 DOM 对应的颜色。 那么大家可以想一下，如果我此时改变了该 css 变量的值，那么对应的 DOM 颜色是不是也会同步发生变化。 当大量的 DOM 都依赖这个 css 变量 设置颜色时，我们是不是只需要改变这个 css 变量 ，那么所有 DOM 的颜色是不是都会发生变化，所谓的 动态换肤 是不是就可以实现了！ 这个就是 动态换肤 的实现原理! 实现换肤和主题大致有两种方案: 使用原生支持的 css var 通过一些手段覆盖 element plus 样式 我们先看来看看 css var 的实现吧。 css变量 https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root 变量 与 color、font-size 等正式属性没有什么不同，只是没有默认含义。 所以 CSS 变量（CSS variable）又叫做”CSS 自定义属性”（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。 变量可以分为 全局变量 局部变量 全局变量通过 :root 去定义，其他所有的元素都可以通过 var(--xxx) 的形式去使用全局变量，我们来看下面这个例子: var()函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。 123456789101112&lt;style&gt; :root &#123; --color: skyblue; &#125; .use-global &#123; color: var(--color) &#125;&lt;/style&gt;// body&lt;div class=&quot;use-global&quot;&gt;使用了全局变量&lt;/div&gt; :root :root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 元素，除了优先级更高之外，与 html 选择器相同。 自定义属性 (–*)：CSS 变量 带有前缀–的属性名，比如–example–name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。 局部变量 我们可以在某个选择器下去定义变量，或者在元素的 style 属性上定义变量： 1234567891011121314151617// style:root &#123; --color: skyblue;&#125;.parent &#123; --color: pink; // 优先级更高&#125;h3 &#123; color: var(--color)&#125;// html&lt;div class=&quot;parent&quot;&gt; &lt;h3&gt;child title&lt;/h3&gt;&lt;/div&gt; 这里 h3 标签会显示红色。虽然我们在 :root 上也定义了 --color 变量，但是根据就近原则，h3 会取父级定义的变量。 我们还可以在 style 属性上定义变量，这里我们定义了一个 --bg 变量，其子元素可以访问到这个变量。 123456789101112.parent &#123; --color: pink;&#125;h3 &#123; color: var(--color); background-color: var(--bg);&#125;&lt;div class=&quot;parent&quot; style=&quot;--bg: black;&quot;&gt; &lt;h3&gt;child title&lt;/h3&gt;&lt;/div&gt; 修改 css 变量这里定义了两个按钮，一个修改全局的（根组件）的变量，一个用来修改特定元素上的定义的变量： 12&lt;button class=&quot;btn&quot;&gt;change root&lt;/button&gt;&lt;button class=&quot;variable&quot;&gt;change local variable&lt;/button&gt; 修改全局变量 1234567const btn = document.querySelector(&#x27;.btn&#x27;)btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const html = document.documentElement html.style.setProperty(&#x27;--color&#x27;, &#x27;red&#x27;)&#125;) 修改局部变量 1234567const variableBtn = document.querySelector(&#x27;.variable&#x27;)variableBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; const parent = document.querySelector(&#x27;.parent&#x27;) parent.style.setProperty(&#x27;--color&#x27;, &#x27;green&#x27;)&#125;) 暗黑模式原理分析 prefers-color-scheme prefers-color-scheme CSS 媒体特性: 用于检测用户是否有将系统的主题色设置为亮色或者暗色。 主题色实现原理通过 媒体查询 去监听系统主题色的变化。 12345678910111213141516171819202122232425// style@media (prefers-color-scheme: dark) &#123; .day.dark-scheme &#123; background: #333; color: white; &#125; .night.dark-scheme &#123; background: black; color: red; &#125;&#125;@media (prefers-color-scheme: light) &#123; .day.light-scheme &#123; background: skyblue; color: #333; &#125; .night.light-scheme &#123; background: pink; color: #333; &#125;&#125;.day, .night &#123; display: inline-block; padding: 1em; width: 7em; height: 7em; vertical-align: middle;&#125;// html&lt;div class=&quot;day light-scheme&quot;&gt;Day (changes in light scheme)&lt;/div&gt;&lt;div class=&quot;day dark-scheme&quot;&gt;Day (changes in dark scheme)&lt;/div&gt; &lt;br&gt;&lt;div class=&quot;night light-scheme&quot;&gt;Night (changes in light scheme)&lt;/div&gt;&lt;div class=&quot;night dark-scheme&quot;&gt;Night (changes in dark scheme)&lt;/div&gt; 现在，我们可以去切换系统的主题色，就会发现页面上的颜色跟着变化了，这是因为我们通过 @media 监听 prefers-color-scheme 起作用了。 window.matchMedia虽然我们通过 css @media 能够应对系统的主题色切换，但是我们如何在 js 中去监听呢？ 答案是通过 window.matchMedia 方法： 1234567891011// 如果匹配成功，scheme.matches === true// 也就是说，如果我们的系统是暗黑色，那么这个 matches 就是true，否则是 falseconst scheme = window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;)scheme.addEventListener(&#x27;change&#x27;, e =&gt; &#123; if (e.matches) &#123; // 暗黑色 &#125; else &#123; // 亮色 &#125;&#125;) 修改主题色到此，我们知道了主题色的实现原理，我们如何在项目里去实现主题色的切换呢？ 我们来看一个小例子 首先，我们先定义好 全局变量，里面包含了一些 亮色模式 下的变量： 12345678910:root &#123; --color: #333; --background-color: pink;&#125;&lt;h1 style=&quot;background-color: var(--background-color); color: var(--color)&quot;&gt; 我是一个标题。！！！&lt;/h1&gt;&lt;button class=&quot;dark-btn&quot;&gt;dark mode&lt;/button&gt; 在页面初始时，我们的背景色是粉色，颜色是浅黑色。 现在我们创建一个按钮，来修改主题颜色，这个之前实现过了很简单对吧。 1234567const darkBtn = document.querySelector(&#x27;.dark-btn&#x27;)darkBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 修改变量 document.documentElement.style.setProperty(&#x27;--color&#x27;, &#x27;#fff&#x27;) document.documentElement.style.setProperty(&#x27;--background-color&#x27;, &#x27;#000&#x27;)&#125;) 好无疑问这样是可以实现的，但是，如果变量多起来了，几十上百个，我们也要一个个去修改吗？ 既然我们的变量都定义在根元素上，那么我们可以采取 属性覆盖 的形式。 我们定义一个 [data-theme=&quot;dark&quot;] 样式表，专门用来处理 暗黑模式 下的变量，这里是黑色背景白色字体。 1234[data-theme=&quot;dark&quot;] &#123; --color: #fff; --background-color: #000;&#125; 或者属性选择器： 1234567891011/* 浅色模式 */html[data-theme=&quot;light&quot;]:root &#123; --body-background: #efefef; --text-color: #333;&#125;/* 深色模式 */html[data-theme=&quot;dark&quot;]:root &#123; --body-background: #000; --text-color: #ededed;&#125; 一开始，这个样式表并不会生效，因为根标签上根本没有 data-theme=&quot;dark&quot; 属性，我们通过按钮来修改： 123darkBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; document.documentElement.setAttribute(&#x27;data-theme&#x27;, &#x27;dark&#x27;)&#125;) 我们给根标签设置了 data-theme=&quot;dark&quot; 属性，同时内部定了暗黑相关的变量，这时，data-theme=&quot;dark&quot; 内部的变量就会覆盖 :root 中的变量了，从而达到切换主题色的效果。 同时，我们需要根据系统的主题色，来设置项目的主题色，这里就要用到 window.matchMedia 方法了。 如果在 Vue 项目中，我们可以这样去实现: 1234567891011121314151617181920212223242526272829303132const theme = computed(() =&gt; store.state.settings.theme);// 查看当前是否是 暗黑模式const mediaQueryListDark = window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;);const changeTheme = (theme) =&gt; &#123; // 批量覆盖全局的变量 document.documentElement.setAttribute(&#x27;data-theme&#x27;, theme);&#125;;const handleColorSchemeChange = evt =&gt; &#123; if (evt.matches) &#123; changeTheme(&#x27;dark&#x27;); &#125; else &#123; changeTheme(&#x27;light&#x27;); &#125;&#125;;watchEffect(() =&gt; &#123; if (theme.value === &#x27;Follow System&#x27;) &#123; // 初始值：跟随系统设置 handleColorSchemeChange(mediaQueryListDark); // 监听系统主题的变化 mediaQueryListDark.addEventListener(&#x27;change&#x27;, handleColorSchemeChange); &#125; else if (theme.value) &#123; changeTheme(theme.value.toLowerCase()); // 如果不是跟随系统设置主题了，用户自己设置的主题色，我们就不需要监听系统的主题色切换了 mediaQueryListDark.removeEventListener(&#x27;change&#x27;, handleColorSchemeChange); &#125;&#125;); 总结到这里，我们花了大量的时间和实例对换肤和主题的原理进行了研究，那么接下来就要进入正式的项目开发环节了。 官方换肤方案 官方样式路径：/node_modules/element-plus/theme-chalk/src/common/var.scss 定义自己的 scss 文件，然后在 main.ts 导入。 123456789101112131415161718192021222324252627$--colors: ( &quot;primary&quot;: ( &quot;base&quot;: pink, ), &quot;success&quot;: ( &quot;base&quot;: blue, ), &quot;warning&quot;: ( &quot;base&quot;: #f2711c, ), &quot;danger&quot;: ( &quot;base&quot;: #db2828, ), &quot;error&quot;: ( &quot;base&quot;: #db2828, ), &quot;info&quot;: ( &quot;base&quot;: #42b8dd, ),);@forward &#x27;element-plus/theme-chalk/src/common/var.scss&#x27; with ( $colors: $--colors,);/* 导入所有的样式变量 */@use &quot;element-plus/theme-chalk/src/index.scss&quot; as *; 修改 main.ts 123456// 注释原导入的 element-plus 样式// import &#x27;element-plus/dist/index.css&#x27;// 导入我们自己的定义的样式import &#x27;@/styles/cover-element-plus.scss&#x27; 通过 CSS 变量设置如果不通过上面那种方案，我们还可以定义全局的变量，来覆盖官方的样式。 在自己的样式文件中写入需要覆盖的样式变量： 123:root &#123; --el-color-primary: green;&#125; 如果你只想自定义一个特定的组件，只需为某些组件单独添加内联样式。 1&lt;el-tag style=&quot;--el-tag-bg-color: red&quot;&gt;Tag&lt;/el-tag&gt; 出于性能原因，更加推荐你在类名下添加自定义 css 变量，而不是在全局的 :root 下。 123.custom-class &#123; --el-tag-bg-color: red;&#125; 如果您想要通过 js 控制 css 变量，可以这样做： 123456789// document.documentElement 是全局变量时const el = document.documentElement// const el = document.getElementById(&#x27;xxx&#x27;)// 获取 css 变量getComputedStyle(el).getPropertyValue(`--el-color-primary`)// 设置 css 变量el.style.setProperty(&#x27;--el-color-primary&#x27;, &#x27;red&#x27;) 总结。相当于我们重新定义了变量，覆盖了官方自己定义的变量，如果我们项目只需要一种颜色，那么这种方案是可行的，但是我们项目需要支持用户选择主题来替换，那么这种方案就不适用了。 那么我来用另一种方案来实现吧。 换肤方案落地在我们的项目中想要实现动态换肤，需要同时处理两个方面的内容： element-plus 主题 非 element-plus 主题 明确好了原理之后，接下来我们就来理一下咱们的实现思路。 从原理中我们可以得到以下两个关键信息： 动态换肤的关键是修改 css 变量 的值 换肤需要同时兼顾 element-plus 非 element-plus 那么根据以上关键信息，我们就可以得出对应的实现方案: 创建一个组件 ThemeSelect 用来处理修改之后的 css 变量 的值 根据新值修改 element-plus 主题色 根据新值修改非 element-plus 主题色 创建 ThemeSelect 组件ThemeSelect 组件将由两部分组成： navbar 中的展示图标 选择颜色的弹出层 这是效果图： 创建 components/ThemeSelect/index 组件 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;!-- 主题图标 v-bind：https://v3.cn.vuejs.org/api/instance-properties.html#attrs --&gt; &lt;el-dropdown v-bind=&quot;$attrs&quot; trigger=&quot;click&quot; class=&quot;theme&quot; @command=&quot;handleSetTheme&quot; &gt; &lt;div&gt; &lt;el-tooltip :content=&quot;$t(&#x27;msg.navBar.themeChange&#x27;)&quot;&gt; &lt;svg-icon icon=&quot;change-theme&quot; /&gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu&gt; &lt;el-dropdown-item command=&quot;color&quot;&gt; &#123;&#123; $t(&#x27;msg.theme.themeColorChange&#x27;) &#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;!-- 展示弹出层 --&gt; &lt;div&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const handleSetTheme = command =&gt; &#123;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 在 layout/components/navbar 中进行引用 1234567&lt;div class=&quot;right-menu&quot;&gt; &lt;theme-picker class=&quot;right-menu-item hover-effect&quot;&gt;&lt;/theme-picker&gt;&lt;/div&gt;... import ThemePicker from &#x27;@/components/ThemeSelect/index&#x27; 创建 SelectColor 组件 在有了 ThemeSelect 之后，接下来我们来去处理颜色选择的组件 SelectColor，在这里我们会用到 element 中的 el-color-picker 组件 对于 SelectColor 的处理，我们需要分成两步进行： 完成 SelectColor 弹窗展示的双向数据绑定 把选中的色值进行本地缓存 那么下面咱们先来看第一步：完成 SelectColor 弹窗展示的双向数据绑定 创建 components/ThemePicker/components/SelectColor.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;el-dialog title=&quot;提示&quot; :model-value=&quot;modelValue&quot; @close=&quot;closed&quot; width=&quot;22%&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;p class=&quot;title&quot;&gt;&#123;&#123; $t(&#x27;msg.theme.themeColorChange&#x27;) &#125;&#125;&lt;/p&gt; &lt;el-color-picker v-model=&quot;mColor&quot; :predefine=&quot;predefineColors&quot; &gt;&lt;/el-color-picker&gt; &lt;/div&gt; &lt;template #footer&gt; &lt;span class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;closed&quot;&gt;&#123;&#123; $t(&#x27;msg.universal.cancel&#x27;) &#125;&#125;&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;comfirm&quot;&gt;&#123;&#123; $t(&#x27;msg.universal.confirm&#x27;) &#125;&#125;&lt;/el-button&gt; &lt;/span&gt; &lt;/template&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; defineProps, defineEmits, ref &#125; from &#x27;vue&#x27;defineProps(&#123; modelValue: &#123; type: Boolean, required: true &#125;&#125;)const emits = defineEmits([&#x27;update:modelValue&#x27;])// 预定义色值const predefineColors = [ &#x27;#ff4500&#x27;, &#x27;#ff8c00&#x27;, &#x27;#ffd700&#x27;, &#x27;#90ee90&#x27;, &#x27;#00ced1&#x27;, &#x27;#1e90ff&#x27;, &#x27;#c71585&#x27;, &#x27;rgba(255, 69, 0, 0.68)&#x27;, &#x27;rgb(255, 120, 0)&#x27;, &#x27;hsv(51, 100, 98)&#x27;, &#x27;hsva(120, 40, 94, 0.5)&#x27;, &#x27;hsl(181, 100%, 37%)&#x27;, &#x27;hsla(209, 100%, 56%, 0.73)&#x27;, &#x27;#c7158577&#x27;]// 默认色值const mColor = ref(&#x27;#00ff00&#x27;)/** * 关闭 */const closed = () =&gt; &#123; emits(&#x27;update:modelValue&#x27;, false)&#125;/** * 确定 * 1. 修改主题色 * 2. 保存最新的主题色 * 3. 关闭 dialog */const comfirm = async () =&gt; &#123; closed()&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.center &#123; text-align: center; .title &#123; margin-bottom: 12px; &#125;&#125;&lt;/style&gt; 在 ThemePicker/index 中使用该组件 123456789101112131415161718&lt;template&gt; ... &lt;!-- 展示弹出层 --&gt; &lt;div&gt; &lt;select-color v-model=&quot;selectColorVisible&quot;&gt;&lt;/select-color&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import SelectColor from &#x27;./components/SelectColor.vue&#x27;import &#123; ref &#125; from &#x27;vue&#x27;const selectColorVisible = ref(false)const handleSetTheme = command =&gt; &#123; selectColorVisible.value = true&#125;&lt;/script&gt; 完成双向数据绑定之后，我们来处理第二步：把选中的色值进行本地缓存 缓存的方式分为两种： vuex 本地存储 在 constants/index 下新建常量值 1234// 主题色保存的 keyexport const MAIN_COLOR = &#x27;mainColor&#x27;// 默认色值export const DEFAULT_COLOR = &#x27;#409eff&#x27; 创建 store/modules/theme 模块，用来处理 主题色 相关内容 1234567891011121314151617import &#123; getItem, setItem &#125; from &#x27;@/utils/storage&#x27;import &#123; MAIN_COLOR, DEFAULT_COLOR &#125; from &#x27;@/constant&#x27;export default &#123; namespaced: true, state: () =&gt; (&#123; mainColor: getItem(MAIN_COLOR) || DEFAULT_COLOR &#125;), mutations: &#123; /** * 设置主题色 */ setMainColor(state, newColor) &#123; state.mainColor = newColor setItem(MAIN_COLOR, newColor) &#125; &#125;&#125; 在 store/getters 下指定快捷访问 1mainColor: state =&gt; state.theme.mainColor 在 store/index 中导入 theme 12345678910...import theme from &#x27;./modules/theme.js&#x27;export default createStore(&#123; getters, modules: &#123; ... theme &#125;&#125;) 在 selectColor 中，设置初始色值 和 缓存色值 12345678910111213141516171819202122232425262728...&lt;script setup&gt;import &#123; defineProps, defineEmits, ref &#125; from &#x27;vue&#x27;import &#123; useStore &#125; from &#x27;vuex&#x27;...const store = useStore()// 默认色值const mColor = ref(store.getters.mainColor).../** * 确定按钮 * * 1. 修改主题色 * 2. 保存最新的主题色 * 3. 关闭 dialog * */const comfirm = async () =&gt; &#123; // 2. 保存最新的主题色 store.commit(&#x27;theme/setMainColor&#x27;, mColor.value) // 3. 关闭 dialog closed()&#125;&lt;/script&gt; scss mix方法123456789// 给当前的颜色值，添加上 50% 的白色.white &#123; color: mix(white, $color, 50%);&#125;// 给当前的颜色值，添加上 50% 的黑色.black &#123; color: mix(black, $color, 50%);&#125; 处理 element-plus 主题色变更原理与步骤分析对于 element-plus 的主题变更，相对比较复杂，所以说整个过程我们会分为三部分： 实现原理 实现步骤 实现过程 实现原理： 在之前我们分析主题变更的实现原理时，我们说过，核心的原理是：*通过修改 scss 变量 * 的形式修改主题色完成主题变更 但是对于 element-plus 而言，我们怎么去修改这样的主题色呢？ 其实整体的原理非常简单，分为三步： 获取当前 element-plus 的所有样式 找到我们想要替换的样式部分，通过正则完成替换 把替换后的样式写入到 style 标签中，利用样式优先级的特性，替代固有样式 实现步骤： 那么明确了原理之后，我们的实现步骤也就呼之欲出了，对应原理总体可分为四步： 获取当前 element-plus 的所有样式 定义我们要替换之后的样式 在原样式中，利用正则替换新样式 把替换后的样式写入到 style 标签中 创建 utils/theme 工具类，写入两个方法 123456789101112131415/** * 写入新样式到 style * @param &#123;*&#125; elNewStyle element-plus 的新样式 * @param &#123;*&#125; isNewStyleTag 是否生成新的 style 标签 */export const writeNewStyle = elNewStyle =&gt; &#123; &#125;/** * 根据主色值，生成最新的样式表 */export const generateNewStyle = primaryColor =&gt; &#123; &#125; 那么接下来我们先实现第一个方法 generateNewStyle，在实现的过程中，我们需要安装两个工具类： rgb-hex：转换RGB(A)颜色为十六进制 css-color-function：在 CSS 中 Tab Atkins 提出的颜色函数的解析器和转换器。 示例 1234567891011121314151617181920212223import rgbHex from &#x27;rgb-hex&#x27;rgbHex(65, 131, 196);//=&gt; &#x27;4183c4&#x27;rgbHex(&#x27;rgb(40, 42, 54)&#x27;);//=&gt; &#x27;282a36&#x27;rgbHex(65, 131, 196, 0.2);//=&gt; &#x27;4183c433&#x27;rgbHex(40, 42, 54, &#x27;75%&#x27;);//=&gt; &#x27;282a36bf&#x27;rgbHex(&#x27;rgba(40, 42, 54, 75%)&#x27;);//=&gt; &#x27;282a36bf&#x27;------------------------------------------------import color from &#x27;css-color-function&#x27; color.convert(&#x27;color(red tint(50%))&#x27;);// &quot;rgb(255, 128, 128)&quot; 然后还需要写入一个 颜色转化计算器 formula.json，定义颜色与关键字之间的对应关系 创建 constants/formula.json 12345678910111213141516&#123; &quot;shade-1&quot;: &quot;color(primary shade(10%))&quot;, &quot;light-1&quot;: &quot;color(primary tint(10%))&quot;, &quot;light-2&quot;: &quot;color(primary tint(20%))&quot;, &quot;light-3&quot;: &quot;color(primary tint(30%))&quot;, &quot;light-4&quot;: &quot;color(primary tint(40%))&quot;, &quot;light-5&quot;: &quot;color(primary tint(50%))&quot;, &quot;light-6&quot;: &quot;color(primary tint(60%))&quot;, &quot;light-7&quot;: &quot;color(primary tint(70%))&quot;, &quot;light-8&quot;: &quot;color(primary tint(80%))&quot;, &quot;light-9&quot;: &quot;color(primary tint(90%))&quot;, &quot;subMenuHover&quot;: &quot;color(primary tint(70%))&quot;, &quot;subMenuBg&quot;: &quot;color(primary tint(80%))&quot;, &quot;menuHover&quot;: &quot;color(primary tint(90%))&quot;, &quot;menuBg&quot;: &quot;color(primary)&quot;&#125; shade tint 方法其实就是利用了 scss 的 mix 方法，css-color-function 库内部调用进行解析。 123456789101112131415161718// scss// 给当前的颜色值，添加上 50% 的白色.white &#123; color: mix(white, $color, 50%);&#125;// 给当前的颜色值，添加上 50% 的黑色.black &#123; color: mix(black, $color, 50%);&#125;@function tint($color, $parcent) &#123; @return mix(white, $color, $parcent)&#125;@function shade($color, $parcent) &#123; @return mix(black, $color, $parcent)&#125; 准备就绪后，我们来实现 generateNewStyle 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// https://www.npmjs.com/package/css-color-functionimport color from &#x27;css-color-function&#x27;// https://www.npmjs.com/package/rgb-heximport rgbHex from &#x27;rgb-hex&#x27;import axios from &#x27;axios&#x27;import formula from &#x27;@/constants/formula.json&#x27;/** * 写入新样式到 style * @param &#123;*&#125; cssText element-plus 的新样式 * @param &#123;*&#125; isNewStyleTag 是否生成新的 style 标签 */export const writeNewStyle = (cssText: string) =&gt; &#123; const style = document.createElement(&#x27;style&#x27;) style.innerText = cssText document.head.appendChild(style)&#125;/** * 根据主色值，生成最新的样式表 */type TObject = &#123; [key: string]: string &#125;export const generateNewStyle = async (primaryColor: string) =&gt; &#123; // colors ===&gt; &#123; primary: &#x27;rgba(8, 12, 132, 0.68)&#x27;, shade-1: &#x27;#070b77ad&#x27;, light-1: &#x27;#212490ad&#x27;, ...... &#125; const colors: TObject = generateColors(primaryColor) as TObject // 拿到整个 element plus 样式表，并对需要修改的变量打上了标记 let cssText = await getOriginalStyle() // 遍历生成的样式表，在 CSS 的原样式中进行全局替换 Object.keys(colors).forEach(key =&gt; &#123; // reg pattern // /(:|\\s+)primary/g // /(:|\\s+)shade-1/g // /(:|\\s+)menuBg/g // ... // 这个模式中的 (:|\\\\s+) 表示一个冒号或一个或多个空白字符（包括空格、制表符和换行符）。 // \\\\s+ 的第一个 \\ 是转义字符 // key 是一个变量，代表一个需要匹配的字符串，比如匹配 `primary` // &#x27;$1&#x27; + colors[key] // 关于为什么要在色值前面加上 $1，我们需要查看 replace 方法的第二个参数。 // 在这里，第二个参数是一个字符串，字符串中的 $1 会被替换成第一个括号捕获组（即 (:|\\\\s+)）匹配到的文本。 // 所以加上 $1 就是为了在【替换的文本】中【保留原本匹配到的文本】。 cssText = cssText.replace( new RegExp(&#x27;(:|\\\\s+)&#x27; + key, &#x27;g&#x27;), &#x27;$1&#x27; + colors[key] ) &#125;) // 最终，新的样式表中，含有我们自定义的颜色主题 return cssText&#125;/** * 根据主色生成色值表 */type TFormulaKey = keyof typeof formulaexport const generateColors = (primary: string) =&gt; &#123; if (!primary) return const colors: &#123; [key: string]: string &#125; = &#123; primary &#125; ;(Object.keys(formula) as Array&lt;TFormulaKey&gt;).forEach( &lt;K extends TFormulaKey&gt;(key: K) =&gt; &#123; // 将所有的主色，替换成我们选中的主题色，形式如 &gt;&gt;&gt; color(rgba(255, 69, 0, 1) shade(10%)) const value = formula[key].replace(/primary/g, primary) // 通过 color 的 conver 方法，计算出 rgba 色值 // color.convert(value) ===&gt;&gt;&gt; rgba(0, 12, 230, 0.68) // 最终将转为每个颜色，转为十六进制：#030420ad，写入到 colors 对象中，并返回 colors[key] = &#x27;#&#x27; + rgbHex(color.convert(value)) &#125; ) return colors&#125;/** * 获取当前 element-plus 的默认样式表 */const getOriginalStyle = async () =&gt; &#123; const version = require(&#x27;element-plus/package.json&#x27;).version const url = `https://unpkg.com/element-plus@$&#123;version&#125;/dist/index.css` const &#123; data &#125; = await axios(url) // 把获取到的数据筛选为原样式模板 return getStyleTemplate(data)&#125;/** * 返回 style 的 template */const getStyleTemplate = (data: string) =&gt; &#123; // element-plus 默认色值 const colorMap: &#123; [key: string]: string &#125; = &#123; &#x27;#3a8ee6&#x27;: &#x27;shade-1&#x27;, &#x27;#409eff&#x27;: &#x27;primary&#x27;, // element-plus 中含有变量 `--el-color-primary: #409eff` &#x27;#53a8ff&#x27;: &#x27;light-1&#x27;, &#x27;#66b1ff&#x27;: &#x27;light-2&#x27;, &#x27;#79bbff&#x27;: &#x27;light-3&#x27;, &#x27;#8cc5ff&#x27;: &#x27;light-4&#x27;, &#x27;#a0cfff&#x27;: &#x27;light-5&#x27;, &#x27;#b3d8ff&#x27;: &#x27;light-6&#x27;, &#x27;#c6e2ff&#x27;: &#x27;light-7&#x27;, &#x27;#d9ecff&#x27;: &#x27;light-8&#x27;, &#x27;#ecf5ff&#x27;: &#x27;light-9&#x27; &#125; // 根据默认色值为要替换的色值打上标记 Object.keys(colorMap).forEach(key =&gt; &#123; const value = colorMap[key] data = data.replace(new RegExp(key, &#x27;ig&#x27;), value) &#125;) // 替换完之后 // `--el-color-primary: #409eff` 就变成了 `--el-color-primary: primary` // `--el-color-primary-light-9: #ecf5ff` 变成了 `--el-color-primary-light-9: light-9` return data&#125; 我们来分析一下 theme.ts 中函数的执行流程 首先，外部调用 generateNewStyle 方法，传入 primaryColor，我们通过 el-color-picker 选中后的值，就是 primaryColor，它的色值长这样 rgba(8, 12, 132, 0.68)。 通过 generateColors 方法生成色值表 通过 css-color-function 处理我们的颜色转化计算器formula.json 1color(rgba(255, 69, 0, 1) shade(10%)) &gt;&gt;&gt; color.convert(value) &gt;&gt;&gt; rgba(0, 12, 230, 0.68) 使用 rgbHex 方法将 rgba 转化为十六进制格式 1rgbHex(color.convert(value)) ===&gt;&gt;&gt; &#x27;#030420ad&#x27; 返回处理过后的色值表 colors 1234567&#123; primary: &#x27;rgba(8, 12, 132, 0.68)&#x27;, // 保留了原始的rgba格式 shade-1: &#x27;#070b77ad&#x27;, light-1: &#x27;#212490ad&#x27;, light-2: &#x27;#393d9dad&#x27;, ......&#125; 通过 getOriginalStyle 方法，获取 element plus 样式表 拿到 element plus 样式数据后，通过 getStyleTemplate 方法，根据默认色值 colorMap 为要替换的色值打上标记 element-plus 中含有变量 --el-color-primary: #409eff，而我们定义的默认值 &#39;#409eff&#39;: &#39;primary&#39;，十六进制值是对等的 替换完之后，value 就被标记上了我们定义的值12`--el-color-primary: #409eff` 就变成了 `--el-color-primary: primary``--el-color-primary-light-9: #ecf5ff` 变成了 `--el-color-primary-light-9: light-9` 返回处理过后的 element plus 样式表 cssText，这个样式表中已经被标记了我们要修改的变量值 接着，我们通过正则以及第二步 generateColors 方法返回的 colors，将 cssText 中每个打了标记的变量值替换 1cssText = cssText.replace(new RegExp(&#x27;(:|\\\\s+)&#x27; + key, &#x27;g&#x27;), &#x27;$1&#x27; + colors[key]) 这个模式中的 (:|\\s+) 表示一个冒号或一个【或】多个空白字符(\\s+)（包括空格、制表符和换行符） \\s+ 的第一个 \\ 是转义字符 key 是一个变量，代表一个需要匹配的字符串，比如匹配 primary &#39;$1&#39; + colors[key]: replace 第二个参数是一个字符串，字符串中的 $1 会被替换成第一个括号捕获组（即 (:|\\s+)）匹配到的文本。所以加上 $1 就是为了在【替换的文本】中【保留原本匹配到的文本】。 最后返回 cssText，新的样式表中，含有我们自定义的颜色主题 最后，通过 writeNewStyle 将新的样式表 cssText 插入到文档中。 123const style = document.createElement(&#x27;style&#x27;)style.innerText = cssTextdocument.head.appendChild(style) 总结 到这里，我们对 element plus 的主题换肤就完成了。 element-plus 新主题的立即生效到目前我们已经完成了 element-plus 的主题变更，但是当前的主题变更还有一个小问题，那就是：在刷新页面后，新主题会失效 那么出现这个问题的原因，非常简单：因为没有写入新的 style 所以我们只需要在 应用加载后，写入 style 即可 那么写入的时机，我们可以放入到 app.vue 中 123456789&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; generateNewStyle, writeNewStyle &#125; from &#x27;@/utils/theme&#x27;const store = useStore()generateNewStyle(store.getters.mainColor).then(newStyleText =&gt; &#123; writeNewStyle(newStyleText)&#125;)&lt;/script&gt; 自定义主题变更自定义主题变更相对来说比较简单，因为 自己的代码更加可控。 目前在我们的代码中，需要进行 自定义主题变更 为 menu 菜单背景色 而目前指定 menu 菜单背景色的位置在 layout/components/sidebar/SidebarMenu.vue 中 123456789&lt;el-menu :default-active=&quot;activeMenu&quot; :collapse=&quot;!$store.getters.sidebarOpened&quot; :background-color=&quot;$store.getters.cssVar.menuBg&quot; :text-color=&quot;$store.getters.cssVar.menuText&quot; :active-text-color=&quot;$store.getters.cssVar.menuActiveText&quot; :unique-opened=&quot;true&quot; router&gt; 此处的 背景色是通过 getters 进行指定的，该 cssVar 的 getters 为： 1cssVar: state =&gt; variables, 所以，我们想要修改 自定义主题 ，只需要从这里入手即可。 根据当前保存的 mainColor 覆盖原有的默认色值 1234567891011121314151617import variables from &#x27;@/styles/variables.scss&#x27;import &#123; MAIN_COLOR &#125; from &#x27;@/constant&#x27;import &#123; getItem &#125; from &#x27;@/utils/storage&#x27;import &#123; generateColors &#125; from &#x27;@/utils/theme&#x27;const getters = &#123; ... cssVar: state =&gt; &#123; return &#123; ...variables, ...generateColors(getItem(MAIN_COLOR)) &#125; &#125;, ...&#125;export default getters 但是我们这样设定之后，整个自定义主题变更，还存在两个问题： menuBg 背景颜色没有变化 这个问题是因为咱们的 sidebar 的背景色未被替换，所以我们可以在 layout/index 中设置 sidebar 的 backgroundColor 12345&lt;sidebar id=&quot;guide-sidebar&quot; class=&quot;sidebar-container&quot; :style=&quot;&#123; backgroundColor: $store.getters.cssVar.menuBg &#125;&quot;/&gt; 主题色替换之后，需要刷新页面才可响应 这个是因为 getters 中没有监听到 依赖值的响应变化，所以我们希望修改依赖值 在 store/modules/theme 中 1234567891011121314151617181920...import variables from &#x27;@/styles/variables.scss&#x27;export default &#123; namespaced: true, state: () =&gt; (&#123; ... variables &#125;), mutations: &#123; /** * 设置主题色 */ setMainColor(state, newColor) &#123; ... state.variables.menuBg = newColor ... &#125; &#125;&#125; 在 getters 中 1234567891011121314....const getters = &#123; ... cssVar: state =&gt; &#123; return &#123; ...state.theme.variables, ...generateColors(getItem(MAIN_COLOR)) &#125; &#125;, ...&#125;export default getters 那么到这里整个自定义主题我们就处理完成了。 对于 自定义主题而言，核心的原理其实就是 修改scss变量来进行实现主题色变化 明确好了原理之后，对后续实现的步骤就具体情况具体分析了。 对于 element-plus：因为 element-plus 是第三方的包，所以它 不是完全可控 的，那么对于这种最简单直白的方案，就是直接拿到它编译后的 css 进行色值替换，利用 style 内部样式表 优先级高于 外部样式表 的特性，来进行主题替换 对于自定义主题：因为自定义主题是 完全可控 的，所以我们实现起来就轻松很多，只需要修改对应的 scss变量即可 那么在之后大家遇到 自定义主题 的处理时，就可以按照这里所梳理的方案进行处理了。 结束语这一章我们花了大量的篇幅来介绍换肤的原理以及业务场景如何实现换肤，篇幅有点长，就不在此添加其他功能的描述了。 如下功能我们放到下一章节去实现： screenfull headerSearch tagView guide 参考链接 CSS变量教程","categories":[],"tags":[{"name":"工程化,Vue3,通用功能","slug":"工程化-Vue3-通用功能","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3-%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD/"}]},{"title":"Vue3项目实战(四)：Layout架构实现","slug":"vue3-project-layout","date":"2022-12-24T07:00:48.000Z","updated":"2022-12-25T12:34:25.143Z","comments":true,"path":"/post/vue3-project-layout.html","link":"","permalink":"http://yoursite.com/post/vue3-project-layout.html","excerpt":"layout架构实现，包括动态菜单栏、动态的面包屑等方案、侧边栏伸缩动画、退出的通用逻辑封装以及Vue3.2版本中的组件状态驱动的动态 CSS 值等等。","text":"实现 layout 布局首先，我们要改造 layout/index.vue，先定义好结构，然后写样式即可。 1234567891011121314&lt;div class=&quot;app-wrapper&quot;&gt; &lt;!-- 左侧 menu --&gt; &lt;siderbar class=&quot;sidebar-container&quot;&gt;&lt;/siderbar&gt; &lt;div class=&quot;main-container&quot;&gt; &lt;div class=&quot;fixed-header&quot;&gt; &lt;!-- 顶部 --&gt; &lt;nav-bar&gt;&lt;/nav-bar&gt; &lt;/div&gt; &lt;!-- 主要内容 --&gt; &lt;app-main&gt;&lt;/app-main&gt; &lt;/div&gt;&lt;/div&gt; 结构定义好了，我再定义样式以及样式文件。在 src 下创建 styles 文件夹，主要存放 scss 的一些样式文件，其中就包括通用的 reset.scss 文件，处理基础的 html 元素样式。mixin.scss 编写通用的样式表，定义通用的样式变量 variables.scss。 123456// styles/index.scss@import &#x27;./reset.scss&#x27;;@import &#x27;./variables.scss&#x27;;@import &#x27;./mixin.scss&#x27;;@import &#x27;./sidebar.scss&#x27;; scss 的使用技巧这里我们主要看下 mixin.scss 和 variables.scss 的一些技巧和用法： mixin.scss 1234567891011121314151617181920212223242526272829303132/* 清除浮动，在 .vue 文件中使用的时候直接引用即可：@include clearfix; */@mixin clearfix &#123; &amp;:after &#123; content: &#x27;&#x27;; display: table; clear: both; &#125;&#125;/* 滚动条的设置 */@mixin scrollBar &#123; &amp;::-webkit-scrollbar-track-piece &#123; background: #d3dce6; &#125; &amp;::-webkit-scrollbar &#123; width: 6px; &#125; &amp;::-webkit-scrollbar-thumb &#123; background: #99a9bf; border-radius: 20px; &#125;&#125;@mixin relative &#123; position: relative; width: 100%; height: 100%;&#125; variables.scss 12345678910111213141516171819202122232425262728// sidebar$menuText: #bfcbd9;$menuActiveText: #ffffff;$subMenuActiveText: #f4f4f5;$menuBg: #304156;$menuHover: #263445;$subMenuBg: #1f2d3d;$subMenuHover: #001528;$sideBarWidth: 210px;$hideSideBarWidth: 54px;$sideBarDuration: 0.28s;// https://www.bluematador.com/blog/how-to-share-variables-between-js-and-sass// JS 与 scss 共享变量，在 scss 中通过 :export 进行导出，在 js 中可通过 ESM 进行导入:export &#123; menuText: $menuText; menuActiveText: $menuActiveText; subMenuActiveText: $subMenuActiveText; menuBg: $menuBg; menuHover: $menuHover; subMenuBg: $subMenuBg; subMenuHover: $subMenuHover; sideBarWidth: $sideBarWidth;&#125; 关于 :export 的使用方式，我们可以查阅一些文档： https://www.bluematador.com/blog/how-to-share-variables-between-js-and-sass 编写 layout/index.vue 样式12345678910111213141516171819&lt;style lang=&quot;scss&quot; scoped&gt;@import &#x27;~@/styles/mixin.scss&#x27;;@import &#x27;~@/styles/variables.scss&#x27;;.app-wrapper &#123; @include clearfix; // 使用 mixin 中的样式 position: relative; height: 100%; width: 100%;&#125;.fixed-header &#123; position: fixed; top: 0; right: 0; z-index: 9; width: calc(100% - #&#123;$sideBarWidth&#125;);&#125;&lt;/style&gt; 给 SideBar 赋予动态的背景色1234567891011121314&lt;template&gt;... &lt;!-- 左侧 menu --&gt; &lt;sidebar class=&quot;sidebar-container&quot; :style=&quot;&#123; backgroundColor: variables.menuBg &#125;&quot; /&gt;...&lt;/template&gt;&lt;script setup&gt;// scss 通过 :export 导出了变量import variables from &#x27;@/styles/variables.scss&#x27;&lt;/script&gt; script导入scss文件报错在 vue 项目里引用.scss文件，vscode编辑器会有红色波浪线，提示找不到模块 找到 shims-vue.d.ts 声明文件，添加如下代码: 1234567declare module &#x27;*.scss&#x27; &#123; const css: &#123; // 定义的变量，通过 `variables.menuBg` 取值时，就不会报错了 menuBg: string; &#125; export default css&#125; 将来，新增了新的样式变量，我们在 css 下添加即可。 设置NavBar样式和头像布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;right-menu&quot;&gt; &lt;el-dropdown class=&quot;avatar-container&quot; trigger=&quot;click&quot;&gt; &lt;div class=&quot;avatar-wrapper&quot;&gt; &lt;el-avatar shape=&quot;square&quot; :size=&quot;40&quot; :src=&quot;&#x27;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&#x27;&quot; &gt;&lt;/el-avatar&gt; &lt;el-icon&gt;&lt;Tools /&gt;&lt;/el-icon&gt; &lt;/div&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu class=&quot;user-dropdown&quot;&gt; &lt;router-link to=&quot;/&quot;&gt; &lt;el-dropdown-item&gt; 主页 &lt;/el-dropdown-item&gt; &lt;/router-link&gt; &lt;a target=&quot;_blank&quot; href=&quot;&quot;&gt; &lt;el-dropdown-item&gt;Vue3&lt;/el-dropdown-item&gt; &lt;/a&gt; &lt;el-dropdown-item divided&gt; 退出 &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;import &#123; Tools &#125; from &#x27;@element-plus/icons-vue&#x27;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.navbar &#123; height: 50px; overflow: hidden; position: relative; background: #fff; box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08); .right-menu &#123; display: flex; align-items: center; float: right; padding-right: 16px; ::v-deep .right-menu-item &#123; display: inline-block; padding: 0 18px 0 0; font-size: 24px; color: #5a5e66; vertical-align: text-bottom; &amp;.hover-effect &#123; cursor: pointer; transition: background 0.3s; &amp;:hover &#123; background: rgba(0, 0, 0, 0.025); &#125; &#125; &#125; ::v-deep .avatar-container &#123; cursor: pointer; .avatar-wrapper &#123; margin-top: 5px; position: relative; .el-avatar &#123; --el-avatar-background-color: none; margin-right: 12px; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 效果图 获取用户信息到目前为止，头像是静态的，也没有实现登出的逻辑，现在来实现一下。 设置请求头我们不希望每次调接口时，都去设置 token，那么我们可以在 请求拦截器 中去设置: 123456789101112service.interceptors.request.use( config =&gt; &#123; if (store.getters.token) &#123; config.headers.Authorization = `Baerer $&#123;store.getters.token&#125;` &#125; return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;) 编写 userInfo 接口简单实现一下 /userinfo 接口，主要是模拟前后端联调的流程。 123456789101112131415161718192021222324const express = require(&#x27;express&#x27;);const app = express()app.get(&#x27;/userinfo&#x27;, (req, res) =&gt; &#123; // 存在 token，可以返回用户信息 if (req.headers[&#x27;authorization&#x27;]) &#123; res.json(&#123; code: 0, data: &#123; avatar: &#x27;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&#x27;, name: &#x27;Hello_AlexCc&#x27;, id: 1, role: &#x27;super_admin&#x27; &#125;, message: &#x27;获取用户信息成功&#x27;, success: true, &#125;) &#125;&#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;server site an port 9999 ...&#x27;)&#125;) 调用 userInfo 接口时机我们的 userInfo 接口已经编写好了，那么我们在什么时候调用呢？ 很显然，我们需要在 permission.ts 中去调用，当用户登录才有 token，也就是说，我们可以在 token 存在时，并且 to.path 不等于 /login 的时候去调用用户信息接口。 12345678910if (store.getters.token) &#123; if (to.path === &#x27;/login&#x27;) &#123; next(&#x27;/&#x27;) &#125; else &#123; // 调用用户信息接口 await store.dispatch(&#x27;user/getUserInfo&#x27;) next() &#125;&#125; 我们获取用户信息接口的动作，放在了 module user 的 actions 中： 1234567891011121314// module/user.ts// statestate: () =&gt; (&#123; token: getItem(&#x27;token&#x27;) || &#x27;&#x27;, userinfo: &#123;&#125;&#125;),// actionsasync getUserInfo(context) &#123; const info = await getUserInfo() context.commit(&#x27;setUserInfo&#x27;, info) return info&#125;, 方便使用 userInfo，我们可以将其放到 getters 中： 1234const getters = &#123; token: (state) =&gt; state.user.token, userInfo: (state) =&gt; state.user.userinfo&#125; 最后，我们就能在 NavBar 使用获取到的用户信息了。 12345&lt;el-avatar shape=&quot;square&quot; :size=&quot;40&quot; :src=&quot;$store.getters.userInfo.avatar&quot;&gt;&lt;/el-avatar&gt; 避免重复调用 userInfo 接口 我们发现，每次切换路由时，都会触发路由的前置守卫，从而多次触发 getUserInfo 接口，我们把这个问题解决一下 在 store 中定义 hasUserInfo，用来判断是否已经有用户信息了，如果有用户信息，我们就不要再触发 getUserInfo 接口了 123456// getters.tshasUserInfo: (state) =&gt; &#123; // 如果用户信息存在，return true return JSON.stringify(state.user.userinfo) !== &#x27;&#123;&#125;&#x27;&#125; 修改 permission.ts 文件，只有 hasUserInfo 为 false 时，我们才调用用户信息接口 1234567891011if (store.getters.token) &#123; if (to.path === &#x27;/login&#x27;) &#123; next(&#x27;/&#x27;) &#125; else &#123; if (!store.getters.hasUserInfo) &#123; await store.dispatch(&#x27;user/getUserInfo&#x27;) &#125; next() &#125;&#125; 登出逻辑登出分为两种形式： 用户主动退出 用户被动登录（token 过去 | 账号被挤） 不管以何种形式退出，登出的逻辑都是相同的。 清理掉用户的缓存数据 清理掉权限相关的配置 返回到登录页 登出的逻辑，我们也可以写在 module user 中去处理。 主要执行 3 个步骤： 清空 store token 清除浏览器本地存储 跳转到 login 页 12345logout(context: any) &#123; context.commit(&#x27;setToken&#x27;, &#x27;&#x27;) removeAllItem() router.push(&#x27;/login&#x27;)&#125; 主动退出用户点击登录按钮，通过 store dispatch 触发 action 的 logout 即可。 被动退出被动退出大概分为两种： token 失效 账号被挤下去 那么这两种场景下，在前端对应的处理方案一共也分为两种，共分为 主动处理 、被动处理 两种 ： 主动处理：主要应对 token 失效 被动处理：同时应对 token 失效 与 单点登录（账号被挤） 用户被动退出解决方案之主动处理为了保证用户的信息安全，那么对于 token 而言就被制定了很多的安全策略，比如： 动态 token（可变 token） 刷新 token 时效 token… 我们这里采用 时效 token。 那么对应到我们代码中的实现方案为： 在用户登陆时，记录当前 登录时间 制定一个 失效时长 在接口调用时，根据 当前时间 对比 登录时间 ，看是否超过了 时效时长 如果未超过，则正常进行后续操作 如果超过，则进行 退出登录 操作 代码实现创建 utils/auth.js 文件，并写入以下代码： 123456789101112131415161718192021222324import &#123; TIME_STAMP, TOKEN_TIMEOUT_VALUE &#125; from &#x27;@/constant&#x27;import &#123; setItem, getItem &#125; from &#x27;@/utils/storage&#x27;/** * 获取时间戳 */export function getTimeStamp() &#123; return getItem(TIME_STAMP)&#125;/** * 设置时间戳 */export function setTimeStamp() &#123; setItem(TIME_STAMP, Date.now())&#125;/** * 是否超时 */export function isCheckTimeout() &#123; // 当前时间戳 var currentTime = Date.now() // 缓存时间戳 var timeStamp = getTimeStamp() return currentTime - timeStamp &gt; TOKEN_TIMEOUT_VALUE&#125; 在 constant 中声明对应常量： 1234// token 时间戳export const TIME_STAMP = &#x27;timeStamp&#x27;// 超时时长(毫秒) 两小时export const TOKEN_TIMEOUT_VALUE = 2 * 60 * 60 * 1000 在用户登录成功之后去设置时间，到 store/user.js 的 login 中： 1234567891011121314import &#123; setTimeStamp &#125; from &#x27;@/utils/auth&#x27;login(context, userInfo) &#123; ... return new Promise((resolve, reject) =&gt; &#123; ... .then(data =&gt; &#123; ... // 保存登录时间 setTimeStamp() resolve() &#125;) &#125;)&#125;, 在 utils/request 对应的请求拦截器中进行 主动介入 123456789101112import &#123; isCheckTimeout &#125; from &#x27;@/utils/auth&#x27;if (store.getters.token) &#123; if (isCheckTimeout()) &#123; // 登出操作 store.dispatch(&#x27;user/logout&#x27;) // 失败的话，会走到 interceptors.response 的 error 方法。 return Promise.reject(new Error(&#x27;token 失效&#x27;)) &#125; ...&#125; 那么至此我们就完成了 主动处理 对应的业务逻辑。 用户被动退出解决方案之被动处理背景： 首先我们需要先明确 被动处理 需要应对两种业务场景： token 过期 单点登录 然后我们一个一个来去看，首先是 token 过期 我们知道对于 token 而言，本身就是具备时效的，这个是在服务端生成 token 时就已经确定的。 而此时我们所谓的 token 过期指的就是： 服务端生成的 token 超过 服务端指定时效 的过程，就像我们前端项目指定 token 的失效性一样。 而对于 单点登录 而言，指的是： 当用户 A 登录之后，token 过期之前。 用户 A 的账号在其他的设备中进行了二次登录，导致第一次登录的 A 账号被 “顶下来” 的过程。 即：同一账户仅可以在一个设备中保持在线状态 那么明确好了对应的背景之后，接下来我们来看对应的业务处理场景： 从背景中我们知道，以上的两种情况，都是在 服务端进行判断的，而对于前端而言其实是 服务端通知前端的一个过程。 所以说对于其业务处理，将遵循以下逻辑： 服务端返回数据时，会通过特定的状态码通知前端 当前端接收到特定状态码时，表示遇到了特定状态：token 时效 或 单点登录 此时进行 退出登录 处理 这里只做了 token 的过期处理，如果需要到 单点登录 时，只需要增加一个状态码判断即可。 服务端超时间逻辑我们来简单实现一下后端的超时逻辑。 我们通过 app.use 添加了一个中间件，每一次前端触发了接口请求，都会先走这个中间件逻辑。 服务器启动时，我们把 now 和 current 设置当前时间戳，当有一个接口触发了，会将 current 设置新的时间戳。 1234567891011121314151617181920212223242526272829303132const express = require(&#x27;express&#x27;);const app = express()// token 超时 2hconst TOKEN_TIMEOUT_VALUE = 2 * 60 * 60 * 1000let now = Date.now()let current = Date.now()app.use(function(req, res, next) &#123; // 每次有接口调用，触发中间件，将 current 更新 current = Date.now() // 如果是登录逻辑，我们将 now 设置为 current，这样就不会触发超时逻辑 // 重新登录，继续走此判断，将 now 设置为 current if (req.path === &#x27;/login&#x27;) &#123; now = current &#125; // 每次中间件都会将 current 更新为当前时间戳，一旦时间戳的差值，大于了 2h，就会触发 超时逻辑 if (current - now &gt; TOKEN_TIMEOUT_VALUE) &#123; // 超时 res.status(401).send(&#123; code: 401, message: &#x27;服务端message: token 失效啦&#x27;, success: false, &#125;) &#125; else &#123; // 没有超时，将执行权交给下一个路由 next() &#125;&#125;) 那么明确好了业务之后，接下来我们来实现前端对应代码： 在 utils/request 的响应拦截器中，增加以下逻辑： 1234567891011121314151617181920212223// 响应拦截器service.interceptors.response.use( response =&gt; &#123; ... &#125;, error =&gt; &#123; // 处理 token 超时问题 if ( error.response &amp;&amp; error.response.data &amp;&amp; error.response.data.code === 401 ) &#123; store.dispatch(&#x27;user/logout&#x27;) &#125; if (error.response &amp;&amp; error.response.data &amp;&amp; error.response.data.message) &#123; ElMessage.error(error.response.data.message) // 提示服务端抛出的错误信息 &#125; else &#123; ElMessage.error(error.message) &#125; return Promise.reject(error) &#125;) 那么至此，我们就已经完成了 整个用户退出 方案。 Sidebar 动态菜单接下来我们来处理 动态menu菜单。 临时的 menu 菜单，创建 layout/Sidebar/SidebarMenu 文件 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;!-- 一级 menu 菜单 --&gt; &lt;el-menu &#123;/* 只允许一个菜单展开 */&#125; :uniqueOpened=&quot;true&quot; default-active=&quot;1&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; &gt; &lt;!-- 子集 menu 菜单 --&gt; &lt;el-sub-menu index=&quot;1&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;location /&gt;&lt;/el-icon&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;!-- 具体菜单项 --&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;el-icon&gt;&lt;setting /&gt;&lt;/el-icon&gt; &lt;template #title&gt;导航四&lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;import &#123; Location, Setting &#125; from &#x27;@element-plus/icons-vue&#x27;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在 layout/Sidebar/index 中导入该组件 12345678910111213&lt;template&gt; &lt;div class=&quot;&quot;&gt; &lt;h1&gt;占位&lt;/h1&gt; &lt;el-scrollbar&gt; &lt;sidebar-menu&gt;&lt;/sidebar-menu&gt; &lt;/el-scrollbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import SidebarMenu from &#x27;./SidebarMenu&#x27;import &#123;&#125; from &#x27;vue&#x27;&lt;/script&gt; 那么至此我们生成了一个临时的 menu 菜单，从这个临时的 menu 菜单出可以看到，el-menu 其实分成了三个部分： el-menu：整个 menu 菜单 el-submenu：子集 menu 菜单 el-menu-item：具体菜单项 那么明确好了这些内容之后，接下来我们就可以来去分析一下 动态 menu 菜单如何生成了 动态menu菜单处理方案解析动态menu菜单 其实主要是和 动态路由表 配合来去实现 用户权限 的。 但是 用户权限处理 目前还未涉及到，因为咱们想要处理 用户权限 还需要先去处理很多的业务场景，所以暂时先只处理 动态menu菜单 。 所谓 动态menu菜单 指的是： 根据路由表的配置，自动生成对应的 menu 菜单。 当路由表发生变化时，menu 菜单自动发生变化 那么明确了 动态menu菜单 的含义之后，接下来咱们就需要来明确 动态menu菜单 的实现方案： 定义 路由表 对应 menu 菜单规则 根据规则制定 路由表 根据规则，依据 路由表 ，生成 menu 菜单 那么根据我们的实现方案可以发现，实现 动态menu菜单 最核心的关键点其实就在步骤一，也就是 定义 路由表 对应 menu 菜单规则 那么下面我们就来看一下，这个规则如何制定： 对于单个路由规则而言（循环）： 如果存在 meta &amp;&amp; meta.title &amp;&amp; meta.icon ：则显示在 menu 菜单中，其中 title 为显示的内容，icon 为显示的图标 如果存在 children ：则以 el-sub-menu（子菜单） 展示 否则：则以 el-menu-item（菜单项） 展示 否则：不显示在 menu 菜单中 那么明确好了对应的规则之后，接下来我们就可以来去看一下如何进行实现啦！ 生成项目页面组件明确了对应的方案之后，那么下面咱们就来实现对应的代码逻辑。 根据我们的分析，想要完成动态的 menu，那么我们需要按照以下的步骤来去实现： 创建页面组件 生成路由表 解析路由表 生成 menu 菜单 那么明确好了步骤之后，接下来我们就先来实现第一步 创建页面组件 在 views 文件夹下，创建如下页面： 创建文章：article-create 文章详情：article-detail 文章排名：article-ranking 错误页面：error-page 404 401 导入：import 权限列表：permission-list 个人中心：profile 角色列表：role-list 用户信息：user-info 用户管理：user-manage 创建结构路由表想要实现结构路由表，那么我们需要先知道最终我们要实现的结构是什么样子的，大家来看下面的截图： 这是我们最终要实现的 menu 截图。 根据此截图，我们可以知道两点内容： 我们创建的页面并没有全部进行展示 不显示页面表示 不满足 该条件 meta &amp;&amp; meta.title &amp;&amp; meta.icon menu 菜单将具备父子级的结构 按照此结构规划数据，则数据应为123456789101112131415161718192021222324252627282930313233343536[ &#123; &quot;title&quot;: &quot;个人中心&quot;, &quot;path&quot;: &quot;&quot; &#125;, &#123; &quot;title&quot;: &quot;用户&quot;, &quot;children&quot;: [ &#123; &quot;title&quot;: &quot;员工管理&quot;, &quot;path&quot;: &quot;&quot; &#125;, &#123; &quot;title&quot;: &quot;角色列表&quot;, &quot;path&quot;: &quot;&quot; &#125;, &#123; &quot;title&quot;: &quot;权限列表&quot;, &quot;path&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;title&quot;: &quot;文章&quot;, &quot;children&quot;: [ &#123; &quot;title&quot;: &quot;文章排名&quot;, &quot;path&quot;: &quot;&quot; &#125;, &#123; &quot;title&quot;: &quot;创建文章&quot;, &quot;path&quot;: &quot;&quot; &#125; ] &#125;] 又因为将来我们需要进行 用户权限处理，所以此时我们需要先对路由表进行一个划分： 私有路由表 privateRoutes ：权限路由 公有路由表 publicRoutes：无权限路由 根据以上理论，生成以下路由表结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * 私有路由表 */const privateRoutes = [ &#123; path: &#x27;/user&#x27;, component: layout, redirect: &#x27;/user/manage&#x27;, meta: &#123; title: &#x27;user&#x27;, icon: &#x27;personnel&#x27; &#125;, children: [ &#123; path: &#x27;/user/manage&#x27;, component: () =&gt; import(&#x27;@/views/user-manage/index&#x27;), meta: &#123; title: &#x27;userManage&#x27;, icon: &#x27;personnel-manage&#x27; &#125; &#125;, &#123; path: &#x27;/user/role&#x27;, component: () =&gt; import(&#x27;@/views/role-list/index&#x27;), meta: &#123; title: &#x27;roleList&#x27;, icon: &#x27;role&#x27; &#125; &#125;, &#123; path: &#x27;/user/permission&#x27;, component: () =&gt; import(&#x27;@/views/permission-list/index&#x27;), meta: &#123; title: &#x27;permissionList&#x27;, icon: &#x27;permission&#x27; &#125; &#125;, &#123; path: &#x27;/user/info/:id&#x27;, name: &#x27;userInfo&#x27;, component: () =&gt; import(&#x27;@/views/user-info/index&#x27;), meta: &#123; title: &#x27;userInfo&#x27; &#125; &#125;, &#123; path: &#x27;/user/import&#x27;, name: &#x27;import&#x27;, component: () =&gt; import(&#x27;@/views/import/index&#x27;), meta: &#123; title: &#x27;excelImport&#x27; &#125; &#125; ] &#125;, &#123; path: &#x27;/article&#x27;, component: layout, redirect: &#x27;/article/ranking&#x27;, meta: &#123; title: &#x27;article&#x27;, icon: &#x27;article&#x27; &#125;, children: [ &#123; path: &#x27;/article/ranking&#x27;, component: () =&gt; import(&#x27;@/views/article-ranking/index&#x27;), meta: &#123; title: &#x27;articleRanking&#x27;, icon: &#x27;article-ranking&#x27; &#125; &#125;, &#123; path: &#x27;/article/:id&#x27;, component: () =&gt; import(&#x27;@/views/article-detail/index&#x27;), meta: &#123; title: &#x27;articleDetail&#x27; &#125; &#125;, &#123; path: &#x27;/article/create&#x27;, component: () =&gt; import(&#x27;@/views/article-create/index&#x27;), meta: &#123; title: &#x27;articleCreate&#x27;, icon: &#x27;article-create&#x27; &#125; &#125;, &#123; path: &#x27;/article/editor/:id&#x27;, component: () =&gt; import(&#x27;@/views/article-create/index&#x27;), meta: &#123; title: &#x27;articleEditor&#x27; &#125; &#125; ] &#125;]/** * 公开路由表 */const publicRoutes = [ &#123; path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/login/index&#x27;) &#125;, &#123; path: &#x27;/&#x27;, // 注意：带有路径“/”的记录中的组件“默认”是一个不返回 Promise 的函数 component: layout, redirect: &#x27;/profile&#x27;, children: [ &#123; path: &#x27;/profile&#x27;, name: &#x27;profile&#x27;, component: () =&gt; import(&#x27;@/views/profile/index&#x27;), meta: &#123; title: &#x27;profile&#x27;, icon: &#x27;el-icon-user&#x27; &#125; &#125;, &#123; path: &#x27;/404&#x27;, name: &#x27;404&#x27;, component: () =&gt; import(&#x27;@/views/error-page/404&#x27;) &#125;, &#123; path: &#x27;/401&#x27;, name: &#x27;401&#x27;, component: () =&gt; import(&#x27;@/views/error-page/401&#x27;) &#125; ] &#125;]const router = createRouter(&#123; history: createWebHashHistory(), routes: [...publicRoutes, ...privateRoutes]&#125;) 最后不要忘记在 layout/appMain 下设置路由出口 12345&lt;template&gt; &lt;div class=&quot;app-main&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 解析路由表，获取结构化数据想要获取路由表数据，那么有两种方式： router.options.routes：初始路由列表（新增的路由 无法获取到） router.getRoutes()：获取所有 路由记录 的完整列表 所以，我们此时使用 router.getRoutes() 方法获取完整的路由列表 在 layout/components/Sidebar/SidebarMenu 下写入以下代码： 123456&lt;script setup&gt;import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()console.log(router.getRoutes())&lt;/script&gt; 从返回的数据来看，它与我们想要的数据结构相去甚远。 出现这个问题的原因，是因为它返回的是一个 完整的路由表 这个路由表距离我们想要的存在两个问题： 存在重复的路由数据 不满足该条件 meta &amp;&amp; meta.title &amp;&amp; meta.icon 的数据不应该存在 那么接下来我们就应该来处理这两个问题 创建 utils/route.ts 文件，创建两个方法分别处理对应的两个问题： filterRouters generateMenus 写入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import path from &#x27;path&#x27;/** * 返回所有子路由 */const getChildrenRoutes = routes =&gt; &#123; const result = [] routes.forEach(route =&gt; &#123; if (route.children &amp;&amp; route.children.length &gt; 0) &#123; result.push(...route.children) &#125; &#125;) return result&#125;/** * 处理脱离层级的路由：某个一级路由为其他子路由，则剔除该一级路由，保留路由层级 * @param &#123;*&#125; routes router.getRoutes() */export const filterRouters = routes =&gt; &#123; const childrenRoutes = getChildrenRoutes(routes) return routes.filter(route =&gt; &#123; return !childrenRoutes.find(childrenRoute =&gt; &#123; return childrenRoute.path === route.path &#125;) &#125;)&#125;/** * 判断数据是否为空值 */function isNull(data) &#123; if (!data) return true if (JSON.stringify(data) === &#x27;&#123;&#125;&#x27;) return true if (JSON.stringify(data) === &#x27;[]&#x27;) return true return false&#125;/** * 根据 routes 数据，返回对应 menu 规则数组 */export function generateMenus(routes, basePath = &#x27;&#x27;) &#123; const result = [] // 遍历路由表 routes.forEach(item =&gt; &#123; // 不存在 children &amp;&amp; 不存在 meta 直接 return if (isNull(item.meta) &amp;&amp; isNull(item.children)) return // 存在 children 不存在 meta，进入迭代 if (isNull(item.meta) &amp;&amp; !isNull(item.children)) &#123; result.push(...generateMenus(item.children)) return &#125; // 合并 path 作为跳转路径 const routePath = path.resolve(basePath, item.path) // 路由分离之后，存在同名父路由的情况，需要单独处理 let route = result.find(item =&gt; item.path === routePath) if (!route) &#123; route = &#123; ...item, path: routePath, children: [] &#125; // icon 与 title 必须全部存在 if (route.meta.icon &amp;&amp; route.meta.title) &#123; // meta 存在生成 route 对象，放入 arr result.push(route) &#125; &#125; // 存在 children 进入迭代到children if (item.children) &#123; route.children.push(...generateMenus(item.children, route.path)) &#125; &#125;) return result&#125; 在 SidebarMenu 中调用该方法 123456789101112&lt;script setup&gt;import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useRouter &#125; from &#x27;vue-router&#x27;import &#123; filterRouters, generateMenus &#125; from &#x27;@/utils/route&#x27;const router = useRouter()const routes = computed(() =&gt; &#123; const filterRoutes = filterRouters(router.getRoutes()) return generateMenus(filterRoutes)&#125;)console.log(JSON.stringify(routes.value))&lt;/script&gt; 得到该数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091[ &#123; &quot;path&quot;:&quot;/profile&quot;, &quot;name&quot;:&quot;profile&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;profile&quot;, &quot;icon&quot;:&quot;el-icon-user&quot; &#125;, &#125;, &#123; &quot;path&quot;:&quot;/user&quot;, &quot;redirect&quot;:&quot;/user/manage&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;user&quot;, &quot;icon&quot;:&quot;personnel&quot; &#125;, &quot;props&quot;:&#123; &quot;default&quot;:false &#125;, &quot;children&quot;:[ &#123; &quot;path&quot;:&quot;/user/manage&quot;, &quot;name&quot;:&quot;userManage&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;userManage&quot;, &quot;icon&quot;:&quot;personnel-manage&quot; &#125;, &quot;children&quot;:[ ] &#125;, &#123; &quot;path&quot;:&quot;/user/role&quot;, &quot;name&quot;:&quot;userRole&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;roleList&quot;, &quot;icon&quot;:&quot;role&quot; &#125;, &quot;children&quot;:[ ] &#125;, &#123; &quot;path&quot;:&quot;/user/permission&quot;, &quot;name&quot;:&quot;userPermission&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;permissionList&quot;, &quot;icon&quot;:&quot;permission&quot; &#125;, &quot;children&quot;:[ ] &#125; ], &#125;, &#123; &quot;path&quot;:&quot;/article&quot;, &quot;redirect&quot;:&quot;/article/ranking&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;article&quot;, &quot;icon&quot;:&quot;article&quot; &#125;, &quot;props&quot;:&#123; &quot;default&quot;:false &#125;, &quot;children&quot;:[ &#123; &quot;path&quot;:&quot;/article/ranking&quot;, &quot;name&quot;:&quot;articleRanking&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;articleRanking&quot;, &quot;icon&quot;:&quot;article-ranking&quot; &#125;, &quot;children&quot;:[ ] &#125;, &#123; &quot;path&quot;:&quot;/article/create&quot;, &quot;name&quot;:&quot;articleCreate&quot;, &quot;meta&quot;:&#123; &quot;title&quot;:&quot;articleCreate&quot;, &quot;icon&quot;:&quot;article-create&quot; &#125;, &quot;children&quot;:[ ] &#125; ], &#125;] 生成动态 menu 菜单有了数据结构之后，最后的步骤就水到渠成了 整个 menu 菜单，我们将分成三个组件来进行处理 SidebarMenu：处理数据，作为最顶层 menu 载体 SidebarItem：根据数据处理 当前项为 el-submenu || el-menu-item MenuItem：处理 el-menu-item 样式 那么下面我们一个个来处理 首先是 SidebarMenu 12345678910111213&lt;template&gt; &lt;!-- 一级 menu 菜单 --&gt; &lt;el-menu ... &gt; &lt;sidebar-item v-for=&quot;item in routes&quot; :key=&quot;item.path&quot; :route=&quot;item&quot; &gt;&lt;/sidebar-item&gt; &lt;/el-menu&gt;&lt;/template&gt; 创建 SidebarItem 组件，用来根据数据处理 当前项为 el-sub-menu || el-menu-item 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;!-- 支持渲染多级 menu 菜单 --&gt; &lt;el-sub-menu v-if=&quot;route.children.length &gt; 0&quot; :index=&quot;route.path&quot;&gt; &lt;template #title&gt; &lt;menu-item :title=&quot;route.meta.title&quot; :icon=&quot;route.meta.icon&quot;&gt;&lt;/menu-item&gt; &lt;/template&gt; &lt;!-- 循环渲染 --&gt; &lt;sidebar-item v-for=&quot;item in route.children&quot; :key=&quot;item.path&quot; :route=&quot;item&quot; &gt;&lt;/sidebar-item&gt; &lt;/el-sub-menu&gt; &lt;!-- 渲染 item 项 --&gt; &lt;el-menu-item v-else :index=&quot;route.path&quot;&gt; &lt;menu-item :title=&quot;route.meta.title&quot; :icon=&quot;route.meta.icon&quot;&gt;&lt;/menu-item&gt; &lt;/el-menu-item&gt;&lt;/template&gt;&lt;script setup&gt;import MenuItem from &#x27;./MenuItem&#x27;import &#123; defineProps &#125; from &#x27;vue&#x27;// 定义 propsdefineProps(&#123; route: &#123; type: Object, required: true &#125;&#125;)&lt;/script&gt; 创建 MenuItem 用来处理 el-menu-item 样式 12345678910111213141516171819202122&lt;template&gt; &lt;i v-if=&quot;icon.includes(&#x27;el-icon&#x27;)&quot; class=&quot;sub-el-icon&quot; :class=&quot;icon&quot;&gt;&lt;/i&gt; &lt;svg-icon v-else :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; defineProps &#125; from &#x27;vue&#x27;defineProps(&#123; title: &#123; type: String, required: true &#125;, icon: &#123; type: String, required: true &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 至此，整个的 menu 菜单结构就已经完成了！ 修复最后残余问题目前 menu 菜单存在三个问题 样式问题 路由跳转问题 默认激活项 样式问题： 首先处理样式，因为后面我们需要处理 主题替换 ，所以此处我们不能把样式写死。因为我们的样式变量都放在 variables.scss 文件中，并通过 :export 导出了变量以供 js 导入，每次使用都需要导入，比较麻烦，我们可以将其放在 store getters 中，以便 快捷访问。 12345import variables from &#x27;@/styles/variables.scss&#x27;const getters = &#123; cssVar: () =&gt; variables&#125;export default getters 在 SidebarMenu 中写入如下样式 123456&lt;el-menu :background-color=&quot;$store.getters.cssVar.menuBg&quot; :text-color=&quot;$store.getters.cssVar.menuText&quot; :active-text-color=&quot;$store.getters.cssVar.menuActiveText&quot; :unique-opened=&quot;true&quot;&gt; 路由跳转问题： 为 el-menu 指定 router 1234&lt;el-menu ... router&gt; 添加 router 属性 表示是否启用 vue-router 模式。 启用该模式会在激活导航时以 index 作为 path 进行路由跳转 使用 default-active 来设置加载时的激活项。 默认激活项： 根据当前 url 进行判断即可 123456789101112131415&lt;el-menu :default-active=&quot;activeMenu&quot; ...&gt;&lt;script setup&gt;...// 计算高亮 menu 的方法const route = useRoute()const activeMenu = computed(() =&gt; &#123; const &#123; path &#125; = route return path&#125;)&lt;/script&gt; 至此整个 动态menu完成 左侧菜单伸缩功能实现下面我们来实现一个标准化功能 左侧菜单伸缩 ，对于这个功能核心的点在于动画处理 样式的改变总是由数据进行驱动，所以首先我们去创建对应的数据 创建 store/app 模块，写入如下代码 12345678910111213export default &#123; namespaced: true, state: () =&gt; (&#123; sidebarOpened: true &#125;), mutations: &#123; triggerSidebarOpened(state) &#123; state.sidebarOpened = !state.sidebarOpened &#125; &#125;, actions: &#123;&#125;&#125; 在 store/index 中进行导入 123456789...import app from &#x27;./modules/app&#x27;export default createStore(&#123; getters, modules: &#123; ... app &#125;&#125;) 在 store/getters 中创建快捷访问 1sidebarOpened: state =&gt; state.app.sidebarOpened 创建 components/hamburger 组件，用来控制数据 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;hamburger-container&quot; @click=&quot;toggleClick&quot;&gt; &lt;svg-icon class=&quot;hamburger&quot; :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useStore &#125; from &#x27;vuex&#x27;const store = useStore()const toggleClick = () =&gt; &#123; store.commit(&#x27;app/triggerSidebarOpened&#x27;)&#125;const icon = computed(() =&gt; store.getters.sidebarOpened ? &#x27;hamburger-opened&#x27; : &#x27;hamburger-closed&#x27;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.hamburger-container &#123; padding: 0 16px; .hamburger &#123; display: inline-block; vertical-align: middle; width: 20px; height: 20px; &#125;&#125;&lt;/style&gt; 在 navbar 中使用该组件 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;hamburger class=&quot;hamburger-container&quot; /&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import Hamburger from &#x27;@/components/Hamburger&#x27;...&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.navbar &#123; ... .hamburger-container &#123; line-height: 46px; height: 100%; float: left; cursor: pointer; // hover 动画 transition: background 0.5s; &amp;:hover &#123; background: rgba(0, 0, 0, 0.1); &#125; &#125; ...&#125;&lt;/style&gt; 在 SidebarMenu 中，控制 el-menu 的 collapse 属性 123&lt;el-menu :collapse=&quot;!$store.getters.sidebarOpened&quot; ... 在 layout/index 中指定 整个侧边栏的宽度和缩放动画 12345&lt;div class=&quot;app-wrapper&quot; :class=&quot;[$store.getters.sidebarOpened ? &#x27;openSidebar&#x27; : &#x27;hideSidebar&#x27;]&quot; &gt; ... 在 layout/index 中 处理 navbar 的宽度 12345678910111213141516&lt;style lang=&quot;scss&quot; scoped&gt;....fixed-header &#123; position: fixed; top: 0; right: 0; z-index: 9; width: calc(100% - #&#123;$sideBarWidth&#125;); transition: width 0.28s;&#125;.hideSidebar .fixed-header &#123; width: calc(100% - #&#123;$hideSideBarWidth&#125;);&#125;&lt;/style&gt; 在 styles/variables.scss 中指定 hideSideBarWidth 1$hideSideBarWidth: 54px; SidebarHeader 处理整个左侧的 menu 菜单，到现在咱们还剩下最后一个 header 没有进行处理 在 sidebar/index 中写入如下代码 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;&quot;&gt; &lt;div class=&quot;logo-container&quot;&gt; &lt;el-avatar size=&quot;44&quot; shape=&quot;square&quot; src=&quot;https://m.imooc.com/static/wap/static/common/img/logo-small@2x.png&quot; /&gt; &lt;h1 class=&quot;logo-title&quot; v-if=&quot;$store.getters.sidebarOpened&quot;&gt; imooc-admin &lt;/h1&gt; &lt;/div&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.logo-container &#123; height: 44px; padding: 10px 0 22px 0; display: flex; align-items: center; justify-content: center; .logo-title &#123; margin-left: 10px; color: #fff; font-weight: 600; line-height: 50px; font-size: 16px; white-space: nowrap; &#125;&#125;&lt;/style&gt; 创建 styles/element.scss 文件，统一处理 el-avatar 的背景问题 123.el-avatar &#123; --el-avatar-background-color: none;&#125; 在 styles/index.scss 中导入 12...@import &#x27;./element.scss&#x27;; 统一处理下动画时长的问题，在 styles/variables.scss 中，加入以下变量 1$sideBarDuration: 0.28s; 为 styles/sidebar.scss 修改时长 123456789.main-container &#123; transition: margin-left #&#123;$sideBarDuration&#125;; ...&#125;.sidebar-container &#123; transition: width #&#123;$sideBarDuration&#125;; ...&#125; 为 layout/index 修改样式 1234.fixed-header &#123; ... transition: width #&#123;$sideBarDuration&#125;;&#125; Vue3.2：组件状态驱动的动态 CSS 值在 vue 3.2 最新更新中，除了之前我们介绍的 响应式变化 之外，还有另外一个很重要的更新，那就是 组件状态驱动的动态 CSS 值 ，对应的文档也已经公布，大家可以 点击这里 查看 那么下面我们就使用下最新的特性，来为 logo-container 指定下高度： 1234567891011121314151617181920&lt;template&gt; ... &lt;el-avatar :size=&quot;logoHeight&quot; ...&lt;/template&gt;&lt;script setup&gt;...const logoHeight = 44&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.logo-container &#123; height: v-bind(logoHeight) + &#x27;px&#x27;;...&#125;&lt;/style&gt; 动态面包屑方案分析面包屑导航分为： 静态面包屑 动态面包屑 静态面包屑： 指的是：在每个页面中写死对应的面包屑菜单，缺点也很明显： 每个页面都得写一遍 页面路径结构变化了，得手动更改 简单来说就是 不好维护，不好扩展 。 动态面包屑： 根据当前的 url 自动生成面包屑导航菜单 无论之后路径发生了什么变化，动态面包屑 都会正确的进行计算 那么在后面的实现过程中，我们将会分成三大步来实现 创建、渲染基本的面包屑组件 计算面包屑结构数据 根据数据渲染动态面包屑内容 渲染基本的面包屑组件完成第一步，先去创建并渲染出基本的 面包屑 组件 创建 components/Breadcrumb/index，并写入如下代码： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;el-breadcrumb class=&quot;breadcrumb&quot; separator=&quot;/&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&lt;a href=&quot;/&quot;&gt;活动管理&lt;/a&gt;&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;活动列表&lt;/el-breadcrumb-item&gt; &lt;!-- 面包屑的最后一项 --&gt; &lt;el-breadcrumb-item&gt; &lt;span class=&quot;no-redirect&quot;&gt;活动详情&lt;/span&gt; &lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;&#125; from &#x27;vue&#x27;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.breadcrumb &#123; display: inline-block; font-size: 14px; line-height: 50px; margin-left: 8px; ::v-deep .no-redirect &#123; color: #97a8be; cursor: text; &#125;&#125;&lt;/style&gt; 在 layout/components/Navbar 组件下导入 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;hamburger class=&quot;hamburger-container&quot; /&gt; &lt;breadcrumb class=&quot;breadcrumb-container&quot; /&gt; ... &lt;/div&gt;&lt;/template&gt;...&lt;style lang=&quot;scss&quot; scoped&gt;.navbar &#123; ... .breadcrumb-container &#123; float: left; &#125; ...&#125;&lt;/style&gt; 动态计算面包屑结构数据现在我们是完成了一个静态的 面包屑，接下来咱们就需要依托这个静态的菜单来完成动态的。 对于现在的静态面包屑来说，他分成了两个组件： el-breadcrumb：包裹性质的容器 el-breadcrumb-item：每个单独项 如果我们想要完成动态的，那么就需要 *依据动态数据，渲染 el-breadcrumb-item * 所以说接下来我们需要做的事情就很简单了 动态数据 渲染 el-breadcrumb-item 咱们先来看 动态数据如何制作 我们希望可以制作出一个 数组，数组中每个 item 都表示一个 路由信息： 创建一个方法，用来生成数组数据，在这里我们要使用到 route.match 属性来：获取与给定路由地址匹配的标准化的路由记录数组 如何理解上面这句话呢？其实我们将 route.matched 打印出来就可以发现，你每次切换菜单（或者说更换了路由），打印出来的就是当前路由的路由表（包含父级、子集的路由信息）。 123456789101112131415161718192021222324252627&lt;script setup&gt;import &#123; ref, reactive, watch &#125; from &#x27;vue&#x27;import &#123; useRoute, RouteRecordRaw &#125; from &#x27;vue-router&#x27;const breadcrumbData = ref&lt;RouteRecordRaw[]&gt;([]) // 存放计算出的面包屑数据const route = useRoute()const getBreadcrumbData = () =&gt; &#123; console.log(route.matched) // 只有存在 meta 并且 meta.title 的路由，我们才会显示到面包屑中 // 就像 menu 菜单一样，类似 404 login 的我们不要显示 breadcrumbData.value = route.matched.filter(r =&gt; r.meta &amp;&amp; r.meta.title)&#125;// 监听路由变化时触发watch( route, () =&gt; &#123; getBreadcrumbData() &#125;, &#123; immediate: true &#125;)&lt;/script&gt; 依据动态数据，渲染面包屑有了数据之后，根据数据来去渲染面包屑就比较简单了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;template&gt; &lt;el-breadcrumb class=&quot;breadcrumb&quot; separator=&quot;/&quot;&gt; &lt;el-breadcrumb-item v-for=&quot;(item, index) in breadcrumbData&quot; :key=&quot;item.path&quot; &gt; &lt;!-- 不可点击项 --&gt; &lt;span v-if=&quot;index === breadcrumbData.length - 1&quot; class=&quot;no-redirect&quot;&gt;&#123;&#123; item.meta.title &#125;&#125;&lt;/span&gt; &lt;!-- 可点击项 --&gt; &lt;a v-else class=&quot;redirect&quot; @click.prevent=&quot;onLinkClick(item)&quot;&gt;&#123;&#123; item.meta.title &#125;&#125;&lt;/a&gt; &lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;import &#123; useRoute, useRouter, RouteRecordRaw &#125; from &#x27;vue-router&#x27;import &#123; useStore &#125; from &#x27;vuex&#x27;const breadcrumbData = ref&lt;RouteRecordRaw[]&gt;([]) // 存放计算出的面包屑数据const store = useStore()const route = useRoute()const router = useRouter()const getBreadcrumbData = () =&gt; &#123; console.log(route.matched) // 只有存在 meta 并且 meta.title 的路由，我们才会显示到面包屑中 // 就像 menu 菜单一样，类似 404 login 的我们不要显示 breadcrumbData.value = route.matched.filter(r =&gt; r.meta &amp;&amp; r.meta.title)&#125;watch( route, () =&gt; &#123; getBreadcrumbData() &#125;, &#123; immediate: true &#125;)// 跳转路由const onLinkClick = (item: RouteRecordRaw) =&gt; &#123; router.push(item.path)&#125;// 将来需要进行主题替换，所以这里获取下动态样式const linkHoverColor = ref(store.getters.cssVars.menuBg)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.breadcrumb &#123; ... .redirect &#123; color: #666; font-weight: 600; &#125; .redirect:hover &#123; color: v-bind(linkHoverColor); // 应对主题切换 &#125;&#125;&lt;/style&gt; 面包屑动画vue3对 动画 进行了一些修改（vue 动画迁移文档） 主要的修改其实只有两个： 过渡类名 v-enter 修改为 v-enter-from 过渡类名 v-leave 修改为 v-leave-from 那么依据修改之后的动画，我们来为面包屑增加一些动画样式： 在 Breadcrumb/index 中增加 transition-group 1234567&lt;template&gt; &lt;el-breadcrumb class=&quot;breadcrumb&quot; separator=&quot;/&quot;&gt; &lt;transition-group name=&quot;breadcrumb&quot;&gt; ... &lt;/transition-group&gt; &lt;/el-breadcrumb&gt;&lt;/template&gt; 新建 styles/transition 样式文件 1234567891011121314.breadcrumb-enter-active,.breadcrumb-leave-active &#123; transition: all 0.5s;&#125;.breadcrumb-enter-from,.breadcrumb-leave-active &#123; opacity: 0; transform: translateX(20px);&#125;.breadcrumb-leave-active &#123; position: absolute;&#125; 在 styles/index 中导入 1@import &#x27;./transition.scss&#x27;; 总结到这里我们的 layout 整体架构就已经做完了，我们来看看效果吧。","categories":[],"tags":[{"name":"工程化,Vue3","slug":"工程化-Vue3","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3/"}]},{"title":"Vue3项目实战(三)：登录/请求模块/鉴权","slug":"vue3-project-generalLogin","date":"2022-12-23T15:34:24.000Z","updated":"2022-12-29T02:59:39.272Z","comments":true,"path":"/post/vue3-project-generalLogin.html","link":"","permalink":"http://yoursite.com/post/vue3-project-generalLogin.html","excerpt":"axios模块/接口请求模块/登录请求动作/Token缓存/鉴权","text":"配置环境变量 / 封装 axios封装的 axios 模块，至少具备一种能力，根据当前环境的不同，设定不同的 baseUrl @vue/cli 模式 官网：https://cli.vuejs.org/zh/guide/mode-and-env.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F 请注意，只有 NODE_ENV，BASE_URL 和以 VUE_APP_ 开头的变量将通过 webpack.DefinePlugin 静态地嵌入到客户端侧的代码中。这是为了避免意外公开机器上可能具有相同名称的私钥。 除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 会是 “development”、”production” 或 “test” 中的一个。具体的值取决于应用运行的模式。 BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。 12345// .env.developmentusername=chenghaolun // 不会暴露出来VUE_APP_BASE_API=/api // 暴露出来，可以通过 process.env 获取 所有解析出来的环境变量都可以在 public/index.html 中以 HTML 插值中介绍的方式使用。 1&lt;title&gt;网站标题 &lt;%= VUE_APP_BASE_API %&gt;&lt;/title&gt; 我们可以打印 process.env 看看： 12345&#123; BASE_URL: &quot;/&quot;, NODE_ENV: &quot;development&quot;, VUE_APP_BASE_API: &quot;/api&quot;,&#125; 根据环境变量切换 baseUrl12345678import axios from &#x27;axios&#x27;const service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, timeout: 5000&#125;)export default service 封装接口请求模块在 src 下创建 api 文件夹，并创建 sys.ts 文件，用于处理系统的一些接口请求： 123456789import request from &#x27;@/utils/request&#x27;export const login = data =&gt; &#123; return request(&#123; url: &#x27;/sys/login&#x27;, method: &#x27;POST&#x27;, data &#125;)&#125; 封装登录请求动作我们不希望在点击登录按钮时，就立马调用登录接口，而是将其封装到 vuex 中，当然也可以使用 pinia。 在 store 下创建 modules 文件夹，并创建 user.ts 模块，用于处理所有的 用户相关 的内容（token获取、用户信息获取、退出登录…） 注意 当我们创建好了 store 时，在 vue template 里面使用 $store.state.globalName 可能会爆红，原因是没有声明 $store 123456789101112131415// src/vuex.d.tsimport &#123; Store &#125; from &#x27;vuex&#x27;declare module &#x27;@vue/runtime-core&#x27; &#123; // 声明自己的 store state interface State &#123; globalName: string &#125; // 为 `this.$store` 提供类型声明 interface ComponentCustomProperties &#123; $store: Store&lt;State&gt; &#125;&#125; 创建 user.ts 模块 123456789101112131415// store/index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state() &#123; return &#123; globalName: &#x27;Hello_AlexCc&#x27; &#125; &#125;, modules: &#123; user &#125;&#125;) 创建 modules 文件夹 12345678910111213141516171819202122232425import md5 from &#x27;md5&#x27;import &#123; login &#125; from &#x27;@/api/sys&#x27;export default &#123; namespaced: true, state: () =&gt; (&#123;&#125;), mutations: &#123;&#125;, actions: &#123; login(context: any, userInfo: any) &#123; const &#123; username, password &#125; = userInfo return new Promise((resolve, reject) =&gt; &#123; login(&#123; username, password: md5(password) &#125;) .then(res =&gt; &#123; resolve(res) &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125; &#125;&#125; 到这里，我们的登录请求动作就完成了，我们只需要在点击登录按钮时，获取到 store 并 dispatch login 方法即可： 12345678910111213// 获取到 store 实例const store = useStore()// user.value 是登录表单的 refstore .dispatch(&#x27;user/login&#x27;, user.value) .then(res =&gt; &#123; console.log(&#x27;login res&#x27;, res) &#125;) .catch(err =&gt; &#123; console.log(&#x27;err &#x27;, err) &#125;) 写一个简单的 node 服务器12345678910111213const express = require(&#x27;express&#x27;);const app = express()app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.json(&#123; code: 0, msg: &quot;hello server 9999&quot; &#125;)&#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;server site an port 9999 ...&#x27;)&#125;) 配置 devServer我们将 项目 和 node 服务跑起来之后，点击登录，发现报错了 404，是因为请求 http://localhost:8080/#/api/user 并不存在，接口请求地址资源找不到，我们的接口写在 node 端，那么 node 服务跑起来后，我们怎么去访问呢，这里就要用到 webpack 的 devServer 了。 123456789101112131415161718// vue.config.jsdevServer: &#123; // 配置代理 proxy: &#123; // 当地址中有/api的时候会触发代理机制，因为我们配置了 axios baseURL，所以每个请求中，都会以 `/api` 开头 &#x27;/api&#x27;: &#123; // 要代理的服务器地址 这里不用写 api // node 服务 target: &#x27;http://localhost:9999&#x27;, changeOrigin: true, // 是否跨域 pathRewrite: &#123; // 必须得带上,否则，真正的请求中就会带上 &#x27;/api&#x27;，&#x27;http://localhost:9999/api/user&#x27; &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125;&#125;, 最后，我们再重启项目，点击登录，就会拿到 user 接口返回的的结果了。 本地缓存处理方案存储 token 分为两种： 本地缓存：localstorage 全局状态管理：vuex 保存在 localstorage 中，是为了在 token 没过期的情况下，让用户自动登录。保存在 vuex 中，是为了方便在其他位置使用。 那么我们来定义 localstorage 的相关方法吧！ 123456789101112131415161718192021222324252627282930313233343536373839// utils/storage.ts/** * 存储数据 */export const setItem = (key: string, value: unknown): void =&gt; &#123; // 将数组、对象类型的数据转化为 JSON 字符串进行存储 if (typeof value === &#x27;object&#x27;) &#123; value = JSON.stringify(value) &#125; window.localStorage.setItem(key, value as string)&#125;/** * 获取数据 */export const getItem = (key: string): unknown =&gt; &#123; const data = window.localStorage.getItem(key) as string try &#123; return JSON.parse(data) &#125; catch (err) &#123; // 如果报错了，直接将数据发送给使用端 return data &#125;&#125;/** * 删除数据 */export const removeItem = (key: string): void =&gt; &#123; window.localStorage.removeItem(key)&#125;/** * 删除所有数据 */export const removeAllItem = (key: string): void =&gt; &#123; window.localStorage.clear()&#125; 然后，我们来处理 vuex user 模块，在 state 中定义 token，以及设置 token 的 mutations 方法。 123456789101112131415161718import &#123; setItem, getItem &#125; from &#x27;@/utils/storage&#x27;// 我们可以定义一个常量文件夹，用来设置 TOKEN 常量，或者各种其他常量值const TOKEN = &#x27;token&#x27;&#123; state: () =&gt; (&#123; token: getItem(TOKEN) || &#x27;&#x27; &#125;), mutations: &#123; setToken(state: IState, token: string): void &#123; state.token = token // 本地存储 token setItem(TOKEN, token) &#125; &#125;,&#125; 在 actions login 方法中，请求成功后我们需要 commit 一个 mutation，来触发 setToken 方法: 1context.commit(&#x27;setToken&#x27;, res.data.data.token) 到这，我们的 token 存储就完成了，我们可以在页面上将其显示出来看看。 1&lt;p&gt;token: &#123;&#123; $store.state.user.token || &#x27;暂无Token&#x27; &#125;&#125;&lt;/p&gt; 接口响应数据统一处理我们在 vuex user 模块中通过 login 接口获取到了 token，当我们处理数据时，会发现需要通过好几个 . 的方式去拿到token，层级太深了，不太方便。 那么我们可以通过 axios 的响应拦截器来处理这种情况。 12345678910111213141516171819import &#123; ElMessage &#125; from &#x27;element-plus&#x27;// 响应拦截器service.interceptors.response.use( response =&gt; &#123; const &#123; success, message, data &#125; = response.data if (success) &#123; return data &#125; else &#123; ElMessage.error(message) return Promise.reject(new Error(message)) &#125; &#125;, error =&gt; &#123; ElMessage.error(error.message) // 提示错误信息 return Promise.reject(error) &#125;) 修改好 axios 响应拦截器之后，我们就可以改写一下 vuex user 下的 actions login 方法了。 1234.then(res =&gt; &#123; context.commit(&#x27;setToken&#x27;, res.token) // 这样获取 token 是不是就方便很多了 resolve(res)&#125;) 登录后操作我们可以创建一个 src/layout 文件夹，登录成功后，用来显示的主容器，将 layout/index.vue 配置在 router 路由表中 1234&#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;@/layout/index.vue&#x27;)&#125; 登录成功后，跳转到 layout 页面 12345678910// login/index.vuestore .dispatch(&#x27;user/login&#x27;, user.value) .then(() =&gt; &#123; router.replace(&#x27;/&#x27;) &#125;) .catch(err =&gt; &#123; console.log(&#x27;err &#x27;, err) &#125;) 登录鉴权到这里，我们点击登录，就可以跳转到 layout 页面了，但是我们如果在地址栏手动输入 /login，我们依然可以回到 login 页面，明明我们登录成功，有了 token 还会跳到 login 页面，这是为什么呢？ 因为我们到这里，还未做登录鉴权，即使存在token，我们并未做任何的权限控制和处理。 那么我们要做什么处理呢？ 当用户未登录时，不允许进入除 login 之外的任何页面 用户登录成功之后，token 未过期之前，不让用户进入 login 页面 实现这个功能的核心就是使用 vue-router 的 路由守卫 传送门：https://router.vuejs.org/zh/guide/advanced/navigation-guards.html 那么我们创建 permission.ts 来处理路由守卫吧： 因为我们的 token 定义在 modules user 中，每次获取 token，需要使用 store.state.user.token，这样显得太长了，我们可以定义 store getters，来方便获取 token： 12345// getters.tsconst getters = &#123; token: (state: any) =&gt; state.user.token&#125;export default getters 然后将其放入 store 的 getters 中 12345678910111213import getters from &#x27;./getters&#x27;export default createStore(&#123; state() &#123; return &#123; globalName: &#x27;Hello_AlexCc&#x27; &#125; &#125;, getters, modules: &#123; user &#125;&#125;) 然后创建 permissions.ts 文件，定义路由前置守卫。 判断 token 是否存在，如果存在 token，并且 to.path 等于 /login，那么不让跳转到登录页，而是去 layout 页面。 如果 to.path 不是 /login，直接执行 next 方法即可。 如果 token 不存在，并且 to.path 是 /login，直接跳转 next() 如果 token 不存在并且 to.path 不是 /login，我们让其跳转到登录页 next(&#39;/login&#39;) 123456789101112131415161718192021// permissions.tsimport router from &#x27;./router&#x27;import store from &#x27;./store&#x27;router.beforeEach((to, from, next) =&gt; &#123; // 判断token是否存在 if (store.getters.token) &#123; if (to.path === &#x27;/login&#x27;) &#123; next(&#x27;/&#x27;) &#125; else &#123; next() &#125; &#125; else &#123; if (to.path === &#x27;/login&#x27;) &#123; next() &#125; else &#123; next(&#x27;/login&#x27;) &#125; &#125;&#125;) 到这里，我们点击登录，就会去到根路径下 ‘/‘，也就是 layout 页面。这时我们在地址栏输入 /login，就不会再去登录页面了。 我们还可以改进一下，当 token 不存在时，我们判断了 to.path === &#39;/login&#39;，这样限制死了，将来我们还有 /404 以及 /401 等页面，这些页面也是不需要 token 就能访问的，我们不希望在 if 语句里面加太多的判断逻辑，这时，我们可以定义一个 白名单，专门处理不需要 token 的路径: 1234567const whiteList = [&#x27;/login&#x27;]if (whiteList.indexOf(to.path) &gt; -1) &#123; next()&#125; else &#123; next(&#x27;/login&#x27;)&#125;","categories":[],"tags":[{"name":"工程化,Vue3,Config","slug":"工程化-Vue3-Config","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3-Config/"}]},{"title":"Vue3项目实战(二)：Icon图标（SVG）","slug":"vue3-project-traning","date":"2022-12-23T04:16:55.000Z","updated":"2022-12-29T14:21:17.354Z","comments":true,"path":"/post/vue3-project-traning.html","link":"","permalink":"http://yoursite.com/post/vue3-project-traning.html","excerpt":"自定义 SvgIcon 组件，支持外部链接显示以及本地 svg 图片显示","text":"使用 Element plus Icon https://element-plus.gitee.io/zh-CN/component/icon.html 自定义 SVG 图标对于 element plus 的图标，我们可以直接通过 el-icon 来显示。 12345678910111213&lt;template&gt; &lt;div&gt; &lt;el-icon :size=&quot;size&quot; :color=&quot;color&quot;&gt; &lt;Edit /&gt; &lt;/el-icon&gt; &lt;!-- 或者独立使用它，不从父级获取属性 --&gt; &lt;!-- 由于SVG图标默认不携带任何属性，你需要直接提供它们 --&gt; &lt;Edit /&gt; &lt;Edit style=&quot;width: 1em; height: 1em; margin-right: 8px&quot; /&gt; &lt;Share style=&quot;width: 1em; height: 1em; margin-right: 8px&quot; /&gt; &lt;/div&gt;&lt;/template&gt; 但是自定义的图标，我们却没有显示的方式，那么我们就需要一个自定义的组件，来展示自定义的 svg 图标。 对于这个自定义的组件，它需要拥有两种能力： 显示外部的 svg 图标（链接的方式） 显示项目内的 svg 图标 接下来，我们就来实现自定义组件。 显示外部的 svg 图标css mask:mask 属性允许使用者通过遮罩或者裁切特定区域的图片的方式来 隐藏一个元素的部分 或者 全部可见区域。 css mask: https://juejin.cn/post/6846687594693001223 接下来，我们定义组件 SvgIcon: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div v-if=&quot;isExternal&quot; :style=&quot;styleExternalIcon&quot; class=&quot;svg-external-icon svg-icon&quot; :class=&quot;className&quot; /&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; defineProps, computed &#125; from &#x27;vue&#x27;const props = withDefaults(defineProps&lt;&#123; icon: string className?: string&#125;&gt;(), &#123; className: &#x27;&#x27;, icon: &#x27;&#x27;&#125;)// 判断是否为外部图标const isExternal = computed(() =&gt; /^(https?:|mailto:|tel:)/.test(props.icon))// 外部图标样式const styleExternalIcon = computed(() =&gt; (&#123; mask: `url($&#123;props.icon&#125;) no-repeat 50% 50%`, &#x27;-webkit-mask&#x27;: `url($&#123;props.icon&#125;) no-repeat 50% 50%`&#125;))&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;.svg-external-icon &#123; background-color: currentColor; mask-size: cover !important; display: inline-block;&#125;&lt;/style&gt; 这样，我们就可以通过 链接 的形式，来使用 svg 图标了： 1&lt;svg-icon icon=&quot;https://res.lgdsunday.club/user.svg&quot;&gt;&lt;/svg-icon&gt; 展示内部图标如果不是外部链接的话，我们就展示项目内部的 svg 图标。 通过 use 的 xlink href 属性，找到 body 下已经处理的过的 svg sprite 元素内容，它其中就包含了 symbol 元素，每个 symbol 元素上都有一个 id，这个 id 就是和 xlink:href 与之对应的。 123456// ...&lt;svg v-else class=&quot;svg-icon&quot; :class=&quot;className&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot; /&gt;&lt;/svg&gt;const iconName = computed(() =&gt; `#icon-$&#123;props.icon&#125;`) // 当我们定义好了组件之后，那么就需要在项目中，导入所有的 svg 图标了。 1234// icons/index.tsrequire(&#x27;./svg/user.svg&#x27;)require(&#x27;./svg/password.svg&#x27;) 假设我们有几百上千个 svg 图标，我们都要这样子引入吗？会不会太难受了 ~~ 这里，我们可以使用 webpack 提供的 require.context 方法，来 批量 导入 svg 图标: 12345678// https://webpack.docschina.org/guides/dependency-management/#requirecontext// 通过 require.context() 函数来创建自己的 contextconst svgRequire = require.context(&#x27;./svg&#x27;, false, /\\.svg$/)// 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。// 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标 [&#x27;./xxx1.svg&#x27;, &#x27;./xxx2.svg&#x27;]// 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入svgRequire.keys().forEach(svgIcon =&gt; svgRequire(svgIcon)) 这样，就完成了所有的本地 svg 图片导入。 然后我们注册全局的 SvgIcon 组件，方便使用。 12345678// icons/index.tsimport type &#123; App &#125; from &#x27;vue&#x27;import SvgIcon from &#x27;@/components/SvgIcon/index.vue&#x27;export default (app: App): void =&gt; &#123; app.component(&#x27;svg-icon&#x27;, SvgIcon)&#125; 到这里，我们去页面上使用 &lt;svg-icon icon=&quot;user&quot; /&gt;，发现没有效果，图标展示不出来。 这是因为，我们虽然在 icons/index.ts 中，通过 require.context 导入了所有的 svg 图片，但是并没有做处理，svg-icon 内部的 &lt;use :xlink:href=&quot;#icon-user&quot; /&gt; 找不到任何跟 #icon-user 有关的 svg 图标。 这里，我们就需要用到 svg-sprite-loader 了。 svg-sprite-loadersvg-sprite-loader 的官方解释是：一个用于创建 svg 雪碧图的 Webpack 加载器。这个加载器现在已经被 JetBrains 公司收录和维护了。 通俗的讲：svg-sprite-loader 会把你引入的 svg 塞到一个个 symbol 中，合成一个大的 svg，最后将这个大的 svg 放入 body 中。symbol 的 id 如果不特别指定，就是你的文件名。在页面上形成这样的元素，下面是导入了本地的 user.svg 和 password.svg： 我们可以看到，每个 symbol 上，都有一个 id 属性，因为我们在 SvgIcon 中指定了 use 的 :xlink:href，使用时，就能找到页面上对应的图标了。 接着，我们来配置 svg-sprite-loader，打开 vue.config.js: 1234567891011121314151617181920212223242526272829303132333435const path = require(&#x27;path&#x27;)function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; chainWebpack(config) &#123; // 使用了 config.module.rule(&#x27;svg&#x27;) 方法来获取对 SVG 文件的处理规则。 // 然后，它使用了 exclude 属性来添加一个排除规则，这个规则会排除 resolve(&#x27;src/icons&#x27;) 目录中的所有文件。 // 最后，它使用了 end 方法来结束这个链式调用。 // 这段代码的作用是在 Webpack 构建流程中排除 src/icons 目录中的所有 SVG 文件。这意味着 Webpack 在构建时不会处理这些文件。 config.module.rule(&#x27;svg&#x27;).exclude.add(resolve(&#x27;src/icons&#x27;)).end() // 使用了 config.module.rule(&#x27;icons&#x27;) 方法来获取对图标文件的处理规则。 // 然后，它使用了 test 属性来设置这个规则应用于哪些文件，这里使用的是一个正则表达式，表示只有以 .svg 结尾的文件才会被处理。 // 接着，它使用了 include 属性来添加一个包含规则，这个规则只会包含 resolve(&#x27;src/icons&#x27;) 目录中的文件。 // 最后，它使用了 use 方法来添加一个新的规则，这个规则使用了 svg-sprite-loader 来处理 SVG 文件。 // 这段代码的作用是在 Webpack 构建流程中处理 src/icons 目录中的 SVG 文件。 // 它会使用 svg-sprite-loader 加载器来将这些 SVG 文件转换为可以在浏览器中使用的精灵图（Sprite）。 config.module .rule(&#x27;icons&#x27;) .test(/\\.svg$/) .include.add(resolve(&#x27;src/icons&#x27;)) .end() .use(&#x27;svg-sprite-loader&#x27;) .loader(&#x27;svg-sprite-loader&#x27;) .options(&#123; symbolId: &#x27;icon-[name]&#x27; // 指定精灵的符号 ID 应为 icon-[name]。 &#125;) .end() &#125;&#125; 这两条规则在 webpack 配置中设置了两种不同的方法来处理 SVG 文件：一种用于排除位于 src/icons 目录中的 SVG 文件，另一种用于使用 svg-sprite-loader 处理位于 src/icons 目录中的 SVG 文件。 到这里，我们就完成了 svg-sprite-loader 的配置，然后重新启动项目，就可以愉快的使用本地的 svg 了。 12345&lt;svg-icon icon=&quot;user&quot;&gt;&lt;/svg-icon&gt;&lt;svg-icon icon=&quot;password&quot;&gt;&lt;/svg-icon&gt; 页面上的效果是这样的 总结经过 svg-sprite-loader 加载之后，不仅可以通过指定 id 的方式引入 icon，而且相比图片引入的方式，最大的优点就在于可以通过给 svg 标签添加 fill 属性来调整 icon 的颜色。 除此之外，还可以通过给 svg 添加 class 来调整 icon 的样式，虽然说图片引入的方式也能做到，但是如果图片指定宽高与原图的宽高不成比例，就会导致图片的失真，而 svg 不会。即使随意调整 svg 的宽高样式，它也是按照原尺寸进行缩放，达到高保真的效果。 而且通过svg-sprite-loader的处理后，生成了精灵图，它是一种将多个图标放在一张图片中的技术，可以减少 HTTP 请求数，从而提升网站性能。","categories":[],"tags":[{"name":"工程化,Vue3","slug":"工程化-Vue3","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3/"}]},{"title":"Vue3项目实战(一)：工程化配置","slug":"vue3-project-config","date":"2022-12-23T04:16:55.000Z","updated":"2022-12-23T15:02:10.667Z","comments":true,"path":"/post/vue3-project-config.html","link":"","permalink":"http://yoursite.com/post/vue3-project-config.html","excerpt":"工程化/编程规范/项目基础配置/...","text":"编程规范编程规范的重要作用： 规范的代码可以促进团队合作 规范的代码可以减少bug处理，规范不是对开发的制约，而确实是有助于提高开发效率的 规范的代码可以降低维护成本 规范的代码有助于代码审查 养成代码规范的习惯，有助于自身的成长 ESLint + Prettier 自动格式化代码 VSCode 安装 ESLint 插件，在根目录创建 .eslintrc 配置文件 123456789101112131415161718192021222324252627282930313233module.exports = &#123; root: true, // 表示当前目录为根目录 env: &#123; node: true, &#125;, // ESLint 中基础配置需要继承的配置 extends: [ &quot;plugin:vue/vue3-essential&quot;, &quot;eslint:recommended&quot;, &quot;@vue/typescript/recommended&quot;, &quot;@vue/prettier&quot;, &quot;@vue/prettier/@typescript-eslint&quot;, ], parserOptions: &#123; ecmaVersion: 2020, &#125;, // 错误规则：off(0) warn(1) error(2) rules: &#123; &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, // 关闭 no-used 检查 &quot;@typescript-eslint/no-unused-vars&quot;: &quot;off&quot;, &#125;, overrides: [&#123; files: [ &quot;**/__tests__/*.&#123;j,t&#125;s?(x)&quot;, &quot;**/tests/unit/**/*.spec.&#123;j,t&#125;s?(x)&quot;, ], env: &#123; jest: true, &#125;, &#125;, ],&#125;; VSCode 安装 Prettier 插件，在根目录创建 .prettierrc 配置文件 123456&#123; &quot;semi&quot;: false, // 是否加分号 &quot;singleQuote&quot;: true, // 单引号 &quot;arrowParens&quot;: &quot;avoid&quot;, // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时，是否要小括号， avoid: 省略小括号 &quot;trailingComma&quot;: &quot;none&quot; // 以多个逗号相隔的，最后是否加逗号&#125; 我们打开 VSCode 设置，切换到 工作区，找到 Code Action on Save，修改配置： 123456&quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: true, &quot;source.fixAll.eslint&quot;: true, &quot;source.fixAll.stylelint&quot;: true, &quot;source.fixAll.tslint&quot;: true,&#125;, 注意项 对 VSCode 而言，默认一个 tab 等于 4 个空格，而 ESlint 默认为两个空格，我们在 VSCode 设置中，找到 tab size 改为 2 就行。 可能安装了多个代码格式化工具，我们右键文件，找到 使用...格式化文档，设置默认的为 Prettier 即可。 有可能 Prettier 和 eslint 规则存在冲突，比如 eslint 希望方法名和括号之间有空格，而 Prettier 不希望有空格，控制台就会报出 ESlint 错误，我们就可以找到 ESlint 配置文件，找到 rules，将 space-before-function-paren 设置为 0 或者 off 即可。 Git 提交规范12345&lt;类型&gt;[可选 范围]: &lt;描述&gt;[可选 正文][可选 脚注] CommitizenGithub: cz-cli 当你使用 commitizen 进行代码提交时，commitizen 会提交你在提交时填写所有必须得提交字段 全局安装 1npm install -g commitizen@4.2.4 项目配置 安装 cz-customizable 1npm install cz-customizable@6.3.0 --save-dev 在 package.json 中配置 表示 commitizen 的配置在 node_modules 中的第三方包之中。 1234567...&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-customizable&quot; &#125;&#125;... 3.项目根目录下创建 .cz-config.js，配置自定义提示文件 1234567891011121314151617181920212223242526module.exports = &#123; types: [ &#123; value: &#x27;feat&#x27;, name: &#x27;feat: 新功能&#x27; &#125;, &#123; value: &#x27;fix&#x27;, name: &#x27;fix: 修复&#x27; &#125;, &#123; value: &#x27;docs&#x27;, name: &#x27;docs: 文档变更&#x27; &#125;, &#123; value: &#x27;style&#x27;, name: &#x27;style: 代码格式（不影响代码运行的变动）&#x27; &#125;, &#123; value: &#x27;refactor&#x27;, name: &#x27;refactor: 重构（既不是增加 feature，也不是修复 bug）&#x27; &#125;, &#123; value: &#x27;perf&#x27;, name: &#x27;perf: 性能优化&#x27; &#125;, &#123; value: &#x27;test&#x27;, name: &#x27;test: 增加测试&#x27; &#125;, &#123; value: &#x27;chore&#x27;, name: &#x27;chore: 构建过程或辅助工具的变动&#x27; &#125;, &#123; value: &#x27;revert&#x27;, name: &#x27;revert: 回退&#x27; &#125;, &#123; value: &#x27;build&#x27;, name: &#x27;build: 打包&#x27; &#125;, ], // 步骤 messages: &#123; type: &#x27;请选择提交的类型&#x27;, customScope: &#x27;请输入修改的范围（可选）&#x27;, subject: &#x27;请简要描述提交内容（必填）&#x27;, body: &#x27;请输入详细的描述（可选）&#x27;, footer: &#x27;请输入要关闭的 issue（可选）&#x27;, confirmCommit: &#x27;确认要使用以上信息提交?(y/n)&#x27;, &#125;, // 需要跳过的问题 skipQuestions: [&#x27;body&#x27;, &#x27;footer&#x27;], subjectLimit: 72, // 描述内容的限制&#125; 使用 git cz 代替 git commit 最后 我们可以通过 git cz 规范化了 git 提交，那么存在一个问题，我们必须通过 git cz 提交，才能规范化，如果我们忘记了使用 git cz，依然使用的 git commit 直接提交了怎么办呢？ 那么，有没有办法限制这种错误的出现？ 使用 git hooks Git Hooks当《提交描述信息》不符合 约定式提交规范 的时候，阻止当前的提交，并抛出相应的错误提示。 通过 git hooks 在执行某个事件之前或者之后进行一些额外的操作。 git hooks 非常多，实际用的比较多的就两个： pre-commit：git commit 执行前，在获取提交日志信息并进行提交之前调用 commit-msg：git commit 执行前，可用于将消息规范化为某种项目标准格式 使用 husky + commitlint 检查提交信息使用 git hooks去检验我们的提交信息，需要使用两个工具： commitlint: 用于检查提交信息 husky: git hooks 工具 主要: npm 版本需要在 7.x 以上 安装依赖: 1npm install @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4 --save-dev 创建 commitlint-config.js 123module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;]&#125; 增加配置项 12345678910111213141516module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;], rules: &#123; // type 的类型定义，表示 git 提交的 type 必须在以下范围内 &#x27;type-enum&#x27;: [ // 当前验证的错误级别 2, // 在什么情况下验证 &#x27;always&#x27;, // 枚举的内容 [&#x27;feat&#x27;, &#x27;fix&#x27;, &#x27;docs&#x27;, &#x27;style&#x27;, &#x27;refactor&#x27;, &#x27;perf&#x27;, &#x27;test&#x27;, &#x27;chore&#x27;, &#x27;revert&#x27;, &#x27;build&#x27;], ], // subject 大小写不做校验 &#x27;subject-case&#x27;: [0] &#125;&#125; 注意: 必须确保我们的配置文件保存为 utf-8 的编码格式，否则可能会报错。 打开配置文件，查看 vscode 右下角，是否显示了 utf-8，如果不是就要将其切换为正确的编码格式。 安装 husky 检测 git hooks 的工具 安装 1npm install husky@7.0.1 --save-dev 启动 hooks，在根目录下生成 .husky 文件夹 1npx husky install 在 package.json 中生成 prepare 指令（npm &gt; 7） 12// 执行指令，会在 npm scripts 中生成配置npm set-script prepare &quot;husky install&quot; 执行 prepare 指令 1npm run prepare 添加 commitlint 的 hook 到 husky 中，并在 commit-msg 的 hooks 下，执行 npx --no-install commitlint --edit &quot;$1&quot; 1npx husky add .husky/commit-msg &#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27; 打开 .husky，就可以看到 commit-msg 文件了。 123456// commit-msg#!/bin/sh. &quot;$&#123;dirname &quot;$&#123;0&#125;&quot;&#125;/_/husky.sh&quot;npx --no-install commitlint --edit $1 最后，我们就可以愉快的提交了。 pre-commit 检测代码提交规范虽然我们使用了 eslint + prettier 在本地自动格式化代码，但是，有可能有的小伙伴，忘记将 vscode 的自动保存格式化打开了，并且写的代码格式不符合规范，也是可以提交上去的。 那么我们就得加一些配置，来检测小伙伴们提交的代码是否符合规范了。 要完成这一操作，就需要使用 husky 配合 eslint 来实现了。 我们期望通过 husky 检测 pre-commit 钩子，在该钩子下执行 npx eslint --ext .js,.vue, src 指令去进行相关的检测。 执行 npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue, src&quot; 命令 会在 .husky 文件夹下面，生成 pre-commit 文件 123456// pre-commit#!/bin/sh. &quot;$&#123;dirname &quot;$&#123;0&#125;&quot;&#125;/_/husky.sh&quot;npx eslint --ext .js,.vue, src 每次我们提交代码，都会触发 pre-commit 钩子，从而使用 eslint 去检测我们的代码文件。 关闭自动保存，修改代码提交试试吧 lint staged 自动修复错误我们通过 pre-commit + husky 处理了代码提交时的规范化问题，当我们进行代码提交时，会检测所有的代码格式规范。 但是这样就有两个问题： 我们只修改了个别文件，没有必要检测所有的文件代码格式 它只能给我们提示出对应的错误，竟然还需要我们手动进行修复？不合理 我们使用 lint-staged 插件，来帮助我们解决这两个问题。 lint-staged 可以 只检测本次更新的代码，并在错误出现的时候，自动修复并且推送 安装 使用 vue-cli 生成项目时，lint-staged 不需要安装了，项目已经有了。如果没有的话，就需要单独安装 修改 package.json： 123456&quot;lint-staged&quot;: &#123; &quot;src/**/*.&#123;js,jsx,vue&#125;&quot;: &#123; &quot;eslint --fix&quot;, &quot;git add&quot; &#125;&#125; 修改 .husky/pre-commit 文件 12345678// pre-commit#!/bin/sh. &quot;$&#123;dirname &quot;$&#123;0&#125;&quot;&#125;/_/husky.sh&quot;// npx eslint --ext .js,.vue, src // 删除npx lint-staged // 新增 尝试将代码修改为不符合规范的，通过 git cz 再次提交试试！ lint-staged 会尝试自动修复错误 错误修复完成，继续执行，并将代码提交","categories":[],"tags":[{"name":"工程化,Vue3","slug":"工程化-Vue3","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3/"}]},{"title":"Vue3的响应式系统","slug":"vue3-reactive","date":"2022-12-22T13:34:30.000Z","updated":"2022-12-22T14:41:46.770Z","comments":true,"path":"/post/vue3-reactive.html","link":"","permalink":"http://yoursite.com/post/vue3-reactive.html","excerpt":"响应式系统的作用与实现","text":"响应式系统实现响应式基础 通过 proxy 代理对象，读取属性时触发 get 方法，设置属性时触发 set 方法 在 get 方法中收集副作用函数，在 set 方法中触发副作用函数 假设有这么一个对象：&#123; ok: true, text: &#39;hello world&#39; &#125;，注册副作用函数 123effect(() =&gt; &#123; document.body.innerHTML = obj.ok ? obj.text : &#x27;ok not&#x27;&#125;) 当 ok 为 true，我们会走 obj.text 的读取逻辑，触发 get 拦截方法。这个时候页面上会显示 hello world，当我们将 obj.ok 设置为 false 后，我们会有副作用遗留函数（text的），因为 ok 为 false，永远不会再读取 obj.text 了。 但是，当我们修改 obj.text 时， effect 副作用函数依然会触发，虽然页面上永远是 ok not。 清除不必要的副作用函数 这时，我们就需要进行 分支切换和 cleanup 函数了，通过 cleanup 函数，我们将只收集使用到的 key 的副作用函数，也就是说，当 ok 为false 时，我们不再对 obj.text 进行依赖手机，无论我们如何修改 obj.text，都不会触发 effect 方法。 我们对注册副作用函数，做一些改变，在注册函数内部，定义了一个新的副作用函数方法，这个方法内部执行 删除副作用函数的方法 和真正的副作用函数（设置 document.body 内容） 同时，我们还在 副作用函数 上定义了一个 deps 属性，用来存储与该副作用函数相关联的依赖集合，将来在 cleanup 中通过 activeEffect.deps[i] delete effectFn 时，其实，就是将 某个 key 的 deps 中的副作用函数删除了 1234567891011121314function effect(fn) &#123; function effectFn() &#123; activeEffect = effectFn cleanup(effectFn) // 删除所有key 收集到的依赖 fn() // 重新执行副作用函数，重新收集依赖 &#125; effectFn.deps = [] effectFn()&#125; 定义 cleanup 函数，每一次触发 set 方法时，都会先删除所有 key 对应的依赖，然后重新执行 effectFn 内部的 fn 函数，重新收集依赖 因为 obj.ok = false 了，不会再读取 obj.text，所以也就不会再对 obj.text 收集依赖了。 12345678910function cleanup(effectFn) &#123; for(let i = 0; i &lt; effectFn.deps.length; i++) &#123; const deps = effectFn.deps[i] // Set 集合 deps.delete(effectFn) &#125; effectFn.deps.length = []&#125; 注意 我们删除 effectFn.deps[i] 中的 effectFn，其实就是删除了 ‘ok、text’ 中对应的依赖集合（Set）的副作用函数，因为 effectFn.deps 中存放的集合 和 Map key 对应的 Value 的集合，是同一个集合 删除后，Map 中的所有 value 都是空的 Set 然后执行 fn 函数，重新进行读取 obj 属性，进行依赖收集。 竟然无限循环？ 最后一步，我们还需要改造一下 trigger 函数，否则会造成 无限循环 1234567891011function trigger(target, key) &#123; const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) const effectsToRun = new Set(effects) // effects &amp;&amp; effects.forEach(fn =&gt; fn()) effectsToRun &amp;&amp; effectsToRun.forEach(fn =&gt; fn())&#125; 为什么新建一个 Set 集合呢? const effectsToRun = new Set(effects) 因为，我们遍历 effects 时，执行了每一个 副作用 函数，当副作用函数执行时，会调用 cleanup 进行清除，实际上就是从 effects 集合中奖当前执行的副作用函数剔除 但是，副作用函数的执行 fn() 会触发属性的读取操作，执行 track，导致副作用函数重新被收集到依赖中，而对于 effects集合的遍历仍然在执行，从而造成 无限循环。 解决办法就是：根据 effects 重新建立一个集合，进行遍历。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;收集 key 的依赖&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 存储被注册的副作用函数 let activeEffect; const data = &#123; ok: true, text: &#x27;hello world&#x27; &#125; const bucket = new WeakMap() // target =&gt; Map const obj = new Proxy(data, &#123; get(target, key) &#123; // 追踪依赖 track(target, key) return target[key] &#125;, set(target, key, value) &#123; target[key] = value // 触发依赖 trigger(target, key) &#125; &#125;) function track(target, key) &#123; if (!activeEffect) return target[key] let depsMap = bucket.get(target) if (!depsMap) &#123; bucket.set(target, depsMap = new Map()) &#125; let deps = depsMap.get(key) if (!deps) &#123; depsMap.set(key, deps = new Set()) &#125; // 添加副作用函数 deps.add(activeEffect) // deps 存储与该副作用函数相关联的依赖集合 // 将来在 cleanup 中通过 activeEffect.deps[i] delete effectFn 时，其实，就是将 deps 中的副作用函数删除了 activeEffect.deps.push(deps) &#125; function trigger(target, key) &#123; const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) const effectsToRun = new Set(effects) // effects &amp;&amp; effects.forEach(fn =&gt; fn()) effectsToRun &amp;&amp; effectsToRun.forEach(fn =&gt; fn()) &#125; function effect(fn) &#123; function effectFn() &#123; activeEffect = effectFn cleanup(effectFn) fn() &#125; effectFn.deps = [] // 存储所有包含当前副作用函数的依赖 集合，在 get 拦截函数中处理 deps effectFn() &#125; function cleanup(effectFn) &#123; console.log(&#x27;effectFn &#x27;, effectFn.deps) // 我们删除 effectFn.deps[i] 中的 effectFn，其实就是删除了 &#x27;xxx&#x27;(key) 中对应的依赖集合的副作用函数 // effectFn.deps[i] 中，存放的依赖集合，和 Map key 对应的依赖集合，是同一个集合，删除某一项，自然会影响到另一个 // 当我们在 trigger 中执行 effects 时，就是执行副作用函数 // 这个时候，会执行 cleanup，删除所有的 key 对应的副作用函数，最后执行 fn，重新走 属性的读取逻辑，触发 get 方法，重新收集依赖 // 当我们设置 obj.ok = false 后，不会再读取 obj.text 了，从而不会对其 key 收集依赖。 for(let i = 0; i &lt; effectFn.deps.length; i++) &#123; const deps = effectFn.deps[i] deps.delete(effectFn) &#125; effectFn.deps.length = 0 &#125; effect(() =&gt; &#123; console.log(&#x27; obj.ok&#x27;, obj.ok) // obj.ok = true 会触发 obj 的 get拦截方法，并且通过 track 函数收集到了副作用函数，并且将其存储在 deps 中 document.body.innerHTML = obj.ok ? obj.text : &#x27;ok not&#x27; &#125;) setTimeout(() =&gt; &#123; // obj.text = &#x27;Vue3 Reactive&#x27; obj.ok = false console.log(&#x27;bucket &#x27;, bucket) &#125;, 1000) // setTimeout(() =&gt; &#123; // console.log(&#x27;执行了&#x27;) // obj.text = &#x27;Vue3 Reactive&#x27; // &#125;, 3000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Reactive,Vue3","slug":"Reactive-Vue3","permalink":"http://yoursite.com/tags/Reactive-Vue3/"}]},{"title":"Nginx 实战","slug":"nginx","date":"2022-12-17T03:30:00.000Z","updated":"2022-12-17T03:46:00.578Z","comments":true,"path":"/post/nginx.html","link":"","permalink":"http://yoursite.com/post/nginx.html","excerpt":"Never too old to learn.","text":"查看 Nginx 命令查看安装目录 whereis nginx nginx: /usr/bin/nginx 查看 nginx 进程 ps -ef | grep nginx 查看 nginx 可执行文件 ps -ef | grep nginx /www/server/nginx/conf/nginx.conf 表示配置文件 或者也可以通过 nginx -t 来查看配置文件在哪，虽然这个命令是检测 nginx 配置文件是否有语法错误： 12nginx: the configuration file /www/server/nginx/conf/nginx.conf syntax is oknginx: configuration file /www/server/nginx/conf/nginx.conf test is successful 配置文件 nginx.conf 全局模块worker_processes auto; // 进程数量error_log /www/wwwlogs/nginx_error.log crit; // 错误日志存放路径pid /www/server/nginx/logs/nginx.pid; // 存放 pid 文件 eventsworker_connections 51200; // 单个进程最大的连接数（最大连接数：连接数+进程数） http 块 include 引入其他的配置文件 default_type 文件类型 解决跨域问题首先启动 nginx 服务，输入命令 nginx，修改根路径下的 index.html 文件 1234567891011121314151617181920212223242526// nginx 配置，访问 localhost:8080/ 时，会打开 index.htmllocation / &#123; root html; index index.html index.htm;&#125;// 修改index.html&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;button id=&quot;btn&quot;&gt;send&lt;/button&gt;&lt;script&gt; btn.onclick = () =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;GET&#x27;, &#x27;http://localhost:9999/list&#x27;) xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(&#x27;返回结果&#x27;, xhr.responseText) &#125; &#125; xhr.send(null) &#125;&lt;/script&gt;&lt;/body&gt; 起一个本地 node 服务 9999 123456789101112const express = require(&#x27;express&#x27;);const app = express()app.get(&#x27;/list&#x27;, (req, res) =&gt; &#123; res.json(&#123; code: 0, msg: &quot;hello server&quot; &#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;server site an port 9999 ...&#x27;)&#125;) 当我们点击发送按钮时，会出现跨域问题，这是因为浏览器 同源策略限制，协议、域名、端口号不同，会形成跨域。 这里是端口不同。 我们可以利用 nginx 来解决。 打开 nginx.conf，新增一条转发规则，表示遇到 api 开头的，都将转发到某个服务下 比如 xhr.open(&#39;GET&#39;, &#39;/api/list&#39;), 会将 api 替换成 http://localhost:9999/ 12345// 添加location /api/ &#123; proxy_pass http://localhost:9999/;&#125; 修改调用接口的地方: 1xhr.open(&#x27;GET&#x27;, &#x27;/api/list&#x27;) 此时，再次点击 发送,不会再出现跨域了。 Vue Router History 模式 404 问题Vue 项目，采用 history 的路由模式，打包后放到 nginx 上部署，切换路由时出现 404 现象。 解决方案：try_files $uri $uri/ /index.html; 123456location / &#123; root html; index index.html index.htm; try_files $uri $uri/ /index.html;&#125; 负载均衡我们可以建 3 个（或者更多）node 服务来模拟实现，可以通过 count 计数，来查看每个服务被分配到的请求数 server1 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const app = express()let count = 1app.get(&#x27;/list&#x27;, (req, res) =&gt; &#123; res.json(&#123; code: 0, msg: &quot;hello server 9999&quot; &#125;) console.log(`server 9999 ------ $&#123;count&#125;`) count++&#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;server site an port 9999 ...&#x27;)&#125;) 通过 pm2 log 查看日志 1234567// package.json&quot;start&quot;: &quot;pm2 start index.js index2.js index3.js --watch&quot;,&quot;stop&quot;: &quot;pm2 stop index.js&quot;,&quot;allList&quot;: &quot;pm2 list&quot;,&quot;monit&quot;: &quot;pm2 monit&quot;,&quot;log&quot;: &quot;pm2 log&quot; server2、server3 只是端口不一样 修改 nginx 配置配置根路径，代理到本地服务，当我们启动 nginx，访问 http://localhost:8080/ 时，服务会代理到我们配置的 upstream node 服务上，访问 http://localhost:8080/list 即可调用咱们写好的 node 接口。 1234567891011upstream node &#123;server 127.0.0.1:9997;server 127.0.0.1:9998;server 127.0.0.1:9999;&#125;server &#123; location / &#123; proxy_pass http://node; // node 是 upstream 指定的 name &#125;&#125; 最后我们可以通过 postman 或 apifox 来进行压测了。 1接口：http://localhost:8080/list 这里设置的接口循环次数是 33，意味着我们将要调用 33 次接口，运行之后，33次均可以成功跑通。 来看下结果： 每个 server 分配均匀，33次，每个服务分配了 11 次请求。 权重还可以给服务设置权重 weight，数值越大，权重越高，请求数越多。 123server 127.0.0.1:9997 weight=3;server 127.0.0.1:9998 weight=2;server 127.0.0.1:9999 weight=1; 修改完配置后，重启 nginx nginx -s reload，继续运行 apifox 压测接口： 权重最高的 9997 请求被分配了 17 次，权重最低的 9999 只分配了 5 次请求。 超时设置超时备用模式，如果存在超时，就会选用备用的服务 9003，如果不存在超时请求，则不会有请求打到 9999 服务上。 12345upstream node &#123; server 127.0.0.1:9997 fail_timeout=60; server 127.0.0.1:9998 fail_timeout=20; server 127.0.0.1:9999 backup;&#125; 参考资料小满介绍Nginx ↩安装Nginx ↩Nginx相关 ↩","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"在Linux上部署 Node 接口","slug":"nodejs","date":"2022-12-16T06:00:00.000Z","updated":"2022-12-16T13:55:24.244Z","comments":true,"path":"/post/nodejs.html","link":"","permalink":"http://yoursite.com/post/nodejs.html","excerpt":"Never too old to learn.","text":"连接远程服务器打开 mac 终端: 123ssh root@124.221.230.105 (公网IP)// 接着输入密码，即可登录远程服务器 登录进去，输入 pwd，会输出 /root，这时我们切到 ‘/‘ 目录下: cd .. 在远程安装 nodejs1wget https://cdn.npmmirror.com/binaries/node/v14.19.1/node-v14.19.1-linux-x64.tar.xz 解压压缩包使用 tar 命令 -c 压缩 -x 解压 -t 查看内容 -r 想压缩归档文件末尾追加文件 -v 显示所有过程 -f 使用档案名字，切记，这是最后一个参数，最后只能接档案名 1tar -xvf node-v14.19.1-linux-x64.tar.xz 配置环境变量找到根目录 ‘/‘ 下的 etc文件夹，进去里面，打开 profile 文件，打开，执行命令： 12345// &#x27;/&#x27;cd etcvim profile 在最后一行加上如下这句： 1export PATH=$PATH:/node-v14.19.1-linux-x64/bin 最后，使文件生效 12// /etcsource profile 查看 node 版本 123node -vnpm -v 安装 pm21npm install -g pm2 部署 node 接口在根目录下 /，创建 node-server 文件夹 可以通过 express 建立一个 node 服务 123456789101112131415const express = require(&quot;express&quot;);const app = express()app.get(&#x27;/list&#x27;, (req, res) =&gt; &#123; console.log(&#x27;current IP&#x27;, req.ip) res.json(&#123; code: 200, msg: &#x27;linux node server&#x27; &#125;)&#125;)app.listen(9999, () =&gt; &#123; console.log(&#x27;node server at port 9999...&#x27;)&#125;) 通过 pm2 启动node服务12// node-serverpm2 start index.js --watch 通过 pm2 monit 查看 node 服务的打印日志 注意访问接口，如果打不开，大概率是因为没有放开防火墙。 http://124.221.230.105:9999/list 找到服务器地址，放开 node 服务对应的端口号 此时依然无法打开对应的接口 登录服务器，查看防火墙所有的端口 firewall-cmd –zone=public –list-ports 添加新的端口 firewall-cmd –zone=public –add-port=9999/tcp –permanent 删除 firewall-cmd –zone=public –remove-port=9999/tcp –permanent 表示永久有效 重启防火墙 firewall-cmd –reload 至此，就可以访问服务器上 node 服务的接口了。 参考资料小满Linux介绍 ↩","categories":[],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"Vue Router 4+","slug":"vue-router4","date":"2022-12-16T04:22:00.000Z","updated":"2022-12-16T04:39:36.629Z","comments":true,"path":"/post/vue-router4.html","link":"","permalink":"http://yoursite.com/post/vue-router4.html","excerpt":"富有表现力的路由语法、细致的导航控制、基于组件的配置方法、支持历史模式、 支持滚动控制、支持自动编码","text":"Vue Routerhistory1234const router = VueRouter.createRouter(&#123; history: VueRouter.createWebHashHistory(), // hash 模式 routes,&#125;) hash 模式底层是通过 hashchange 监听的： 1window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123; ... &#125;) history 模式 (createWebHistory)，底层是通过 popstate 监听的: 1window.addEventListener(&#x27;popstate&#x27;, () =&gt; &#123; ... &#125;) 在 setup 中访问路由和当前路由因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route。 1234567891011121314151617import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;export default &#123; setup() &#123; const router = useRouter() const route = useRoute() function pushWithQuery(query) &#123; router.push(&#123; name: &#x27;search&#x27;, query: &#123; ...route.query, &#125;, &#125;) &#125; &#125;,&#125; route 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该避免监听整个 route 对象。在大多数情况下，你应该直接监听你期望改变的参数。 请注意，在模板中我们仍然可以访问 $router 和 $route，所以不需要在 setup 中返回 router 或 route。","categories":[],"tags":[{"name":"JS,Vue-Router,Vue3,","slug":"JS-Vue-Router-Vue3","permalink":"http://yoursite.com/tags/JS-Vue-Router-Vue3/"}]},{"title":"深入浅出Vue3","slug":"vue3","date":"2022-12-01T10:09:04.000Z","updated":"2022-12-23T14:57:41.953Z","comments":true,"path":"/post/vue3.html","link":"","permalink":"http://yoursite.com/post/vue3.html","excerpt":"渐进式 JavaScript 框架。易学易用，性能出色，适用场景丰富的 Web 前端框架","text":"ref 和 reactive 使用上有什么区别? ref 支持所有的类型，reactive 只接收引用类型（Array/Object/Map/Set） ref 取值和赋值都需要加 .value，reactive 不需要 .value reactive 不能直接赋值，否则会破坏响应式（proxy） 如果要改变数组，可以通过 push 方法，将要 push 的数组结构 (xx.push(…arr)) 如何抉择呢？因为社区大佬 basvanmeurs提出了一个新的 PR，大概就是重构了响应式的部分内容，由于重构内容过于庞大，所以一直等到 2021 年 8 月 5 号，伴随着 Vue3.2 的发布，尤大大才合并对应的代码。 ref 被重构之后，有了更高效的实现（提升了 约 260% 的读取速度 / 约 50% 的写入速度），依赖跟踪速度提高了约 40%，内存使用量减少了约 17%，毫无疑问这是一个伟大的变化。 那么，在以后的使用过程当中，能使用 ref 就用 ref吧，毕竟它的性能得到了如此大的提升。 defineProps 如何定义默认值？ 针对类型的 defineProps 声明的不足之处在于，它没有可以给 props 提供默认值的方式。 使用TS 特有的默认值方式 withDefaults 函数，无须引入开箱即用，接受一个props函数第二个参数是一个对象设置默认值。 123456789export interface Props &#123; msg?: string labels?: string[]&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123; msg: &#x27;hello&#x27;, labels: () =&gt; [&#x27;one&#x27;, &#x27;two&#x27;]&#125;) 注意 如果使用 withDefaults 报错 &#39;withDefaults&#39; is not defined，我们修改 .eslintrc 文件 添加如下配置代码： 123globals: &#123; withDefaults: &#x27;readonly&#x27;&#125;, 动态组件 component 要渲染的实际组件由 is prop 决定。 当 is 是字符串，它既可以是 HTML 标签名也可以是组件的注册名。 或者，is 也可以直接绑定组件。 按注册名渲染组件 1234567891011121314151617&lt;script&gt;import Foo from &#x27;./Foo.vue&#x27;import Bar from &#x27;./Bar.vue&#x27;export default &#123; components: &#123; Foo, Bar &#125;, data() &#123; return &#123; view: &#x27;Foo&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;component :is=&quot;view&quot; /&gt;&lt;/template&gt; 按定义渲染组件 &lt;script setup&gt; 组合式 API： 1&lt;component :is=&quot;Math.random() &gt; 0.5 ? Foo : Bar&quot; /&gt; 渲染 HTML 元素 1&lt;component :is=&quot;href ? &#x27;a&#x27; : &#x27;span&#x27;&quot;&gt;&lt;/component&gt; 插槽默认插槽、具名插槽。 作用域插槽：:headerName=&quot;&#39;我是头部&#39;&quot;，父组件可以通过 v-slot=&quot;&#123; headerName &#125;&quot; 拿到组件内部暴露出来的数据 1234567891011121314// SlotComp.vue&lt;template&gt; &lt;div class=&quot;slot-wrapper&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;slot name=&quot;header&quot; :headerName=&quot;&#x27;我是头部&#x27;&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main class=&quot;content&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt; 使用具有插槽的组件，headerName 是作用域插槽从内部提供的 12345&lt;SlotComp&gt; &lt;template v-slot:header=&quot;&#123; headerName &#125;&quot;&gt;&#123;&#123; headerName &#125;&#125;&lt;/template&gt; &lt;template v-slot&gt;default slot&lt;/template&gt; &lt;template v-slot:footer&gt;footer&lt;/template&gt;&lt;/SlotComp&gt; 插槽简写方式 # 12345&lt;SlotComp&gt; &lt;template #header=&quot;&#123; headerName &#125;&quot;&gt;&#123;&#123; headerName &#125;&#125;&lt;/template&gt; &lt;template #default&gt;default slot&lt;/template&gt; &lt;template #footer&gt;footer&lt;/template&gt;&lt;/SlotComp&gt; 动态插槽 1234567&lt;SlotComp&gt; &lt;template #[slotName]&gt;动态插槽&lt;/template&gt;&lt;/SlotComp&gt;// jsconst slotName = ref(&#x27;header&#x27;) 异步组件官方描述 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能： 12345678import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // ...从服务器获取组件 resolve(/* 获取到的组件 */) &#125;)&#125;) ES 模块动态导入 也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点 分包、性能优化) 12345import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; import(&#x27;./components/MyComponent.vue&#x27;)) 最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时 才会调用加载内部实际组件的函数。 顶层 await&lt;script setup&gt; 中可以使用顶层 await。结果代码会被编译成 async setup()： 123&lt;script setup&gt;const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())&lt;/script&gt; 搭配 Suspense 组件使用 定义异步组件 Sync.vue 123456789101112131415&lt;template&gt; &lt;div&gt; Name: &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;ref, reactive&#125; from &#x27;vue&#x27;import iTools from &#x27;@/utils/Tools&#x27;const name = ref(&#x27;&#x27;)const &#123; data &#125; = await iTools.Axios.get(&#x27;./sync-data.json&#x27;) // 定义在 public 下的json文件name.value = data.name&lt;/script&gt; 通过 defineAsyncComponent 动态导入 Sync.vue 组件 1const Sync = defineAsyncComponent(() =&gt; import(&#x27;@/components/Sync.vue&#x27;)) 使用 Suspense 内置组件 在请求过程中，会一直显示 loading… 状态，真实项目中我们可以替换成骨架屏。当接口请求成功，才会显示 Sync.vue 的内容。 123456789&lt;Suspense&gt; &lt;template #default&gt; &lt;Sync /&gt; &lt;/template&gt; &lt;template #fallback&gt; Loading... &lt;/template&gt;&lt;/Suspense&gt; 性能优化当我们使用了 defineAsyncComponent 动态导入组件，build 项目时，会单独将 Sync.vue 的 js 包拎出来，不会将其打包到index.js 中，通过拆包的方式，减少入口文件的大小，从而减少白屏的时间。 Teleport 传送门将其插槽内容渲染到 DOM 中的另一个位置。 12345678910111213141516171819interface TeleportProps &#123; /** * 必填项。指定目标容器。 * 可以是选择器或实际元素。 */ to: string | HTMLElement /** * 当值为 `true` 时，内容将保留在其原始位置 * 而不是移动到目标容器中。 * 可以动态更改。 */ disabled?: boolean&#125;// examples&lt;teleport to=&quot;#some-id&quot; /&gt;&lt;teleport to=&quot;.some-class&quot; /&gt;&lt;teleport to=&quot;[data-teleport]&quot; /&gt;&lt;teleport to=&quot;body&quot; /&gt; MittVue 2可以支持$on，$off来实现event bus，但是 Vue3 已经不支持这些属性，不过Vue 3可以支持第三方event bus来实现事件通信， 这里使用 mitt，官方地址：https://github.com/developit/mitt 1234import mitt from &#x27;mitt&#x27;// vue3挂载到全局app.config.globalProperties.$mitt = mitt() tsx 安装插件 npm install @vitejs/plugin-vue-jsx -D 安装如果失败，将 node 版本切换至 v14.16.0 使用插件 123456import vueJsx from &quot;@vitejs/plugin-vue-jsx&quot;;export default defineConfig(&#123; plugins: [vue(), vueJsx()], // ...&#125;) 但是导入 .tsx 文件，TypeScript 会报错： 12345// 找不到模块“@/components/Foo”或其相应的类型声明。import Foo from &#x27;@/components/Foo&#x27; // 省略了 .tsx 后缀// 导入路径不能以“.tsx”扩展名结束。考虑改为导入“@/components/Bar.js”。import Bar from &#x27;@/components/Bar.tsx&#x27; 配置 tsconfig.json: 12345678&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125;, &#125;&#125; 之后我们导入 tsx 类型的组件，就不要带上后缀了。 编写 tsx 组件的3中方式 函数模式 12345export default function() &#123; return ( &lt;h1&gt;TSX componen111t&lt;/h1&gt; )&#125; options API 模式 1234567891011121314import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123; data() &#123; return &#123; compname: &#x27;jsx comp&#x27; &#125; &#125;, render() &#123; return ( &lt;div&gt;&#123;this.compname&#125;&lt;/div&gt; ) &#125;&#125;) setup 函数模式 1234567891011121314151617181920interface IProps &#123; name?: string;&#125;export default defineComponent(&#123; props: &#123; name: String, &#125;, emits: [&#x27;on-click&#x27;], setup(props: IProps) &#123; const is = true // 返回渲染函数 return () =&gt; &#123; return ( &lt;h1 v-show=&#123;is&#125;&gt;setup 渲染函数 &#123;props?.name&#125;&lt;/h1&gt; ) &#125; &#125;&#125;) tsx slot 使用12345678910111213141516171819const Foo = (_, &#123; slots &#125;) =&gt; &#123; return (&lt;&gt; &lt;p&gt;&#123; slots?.header?.()&#125;&lt;/p&gt; &lt;h3&gt;slot comp&lt;/h3&gt; &lt;p&gt;&#123; slots.default ? slots.default() : &#x27;默认插槽&#x27; &#125;&lt;/p&gt; &lt;/&gt;)&#125;&lt;Foo v-slots=&#123;&#123; default() &#123; return &#x27;setup default slot&#x27; &#125;, header() &#123; return &#x27;header&#x27; &#125;&#125;&#125; /&gt; 自动引入 安装插件 unplugin-auto-import/vite https://github.com/antfu/unplugin-auto-import 注册完 plugin 之后，不再引入 ref, reactive 等等方法了，直接使用即可。 v-model 官网：https://cn.vuejs.org/guide/components/events.html v-model 在原生元素上的用法： 12345678&lt;input v-model=&quot;searchText&quot; /&gt;// 等价于&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot;/&gt; 而当使用在一个组件上时，v-model 会被展开为如下的形式： 123456789101112131415161718&lt;CustomInput :modelValue=&quot;searchText&quot; @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;/&gt;// 内部定义 props 和 方法const props = defineProps&lt;&#123; modelValue: boolean&#125;&gt;()const emits = defineEmits([&#x27;update:modelValue&#x27;])// 调用emits(&#x27;update:modelValue&#x27;, !props.modelValue) 当然，我们也可以给 v-model 指定一个参数，不使用默认的 modelValue: 12345&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;// 定义 propsdefineProps([&#x27;title&#x27;])defineEmits([&#x27;update:title&#x27;]) 我们还可以绑定多个 v-model: 1234&lt;UserName v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot;/&gt; 自定义指令 https://cn.vuejs.org/guide/reusability/custom-directives.html 12345678910111213141516171819const myDirective = &#123; // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode, prevVnode) &#123;&#125;, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode, prevVnode) &#123;&#125;, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode, prevVnode) &#123;&#125;, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) &#123;&#125;, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125; 123456789&lt;div v-example:foo.bar=&quot;baz&quot;&gt;// binding 参数会是一个这样的对象：&#123; arg: &#x27;foo&#x27;, modifiers: &#123; bar: true &#125;, value: /* `baz` 的值 */, oldValue: /* 上一次更新时 `baz` 的值 */&#125; 全局函数或变量在 Vue2 中，我们经常将全局用到的函数定义在 Vue 的 prototype 上，在 Vue3 中已经不这样使用了: 123456789const app = createApp(App)app.config.globalProperties.$env = &#x27;dev&#x27;app.config.globalProperties.$filters = &#123; format&lt;T&gt;(str: T): string &#123; return str.trim() &#125;&#125; 我们使用的时候，不需要导入什么，直接在 .vue 文件使用即可: 12345678&lt;div&gt;env &#123;&#123;$env&#125;&#125;&lt;/div&gt;&lt;script setup lang=&quot;ts&quot;&gt; const app = getCurrentInstance() console.log(app?.proxy?.$filters.format(&#x27;getCurrentInstance&#x27;))&lt;/script&gt; 在组件中使用全局的变量或者函数时，会出现 ts 报错，这时我们需要去声明它的类型: 12345678declare module &#x27;vue&#x27; &#123; export interface ComponentCustomProperties &#123; $filters: &#123; format&lt;T&gt;(str: T): string, &#125;, $env: string, &#125;&#125; 自定义插件 一个插件可以是一个拥有 install() 方法的对象，也可以直接是一个安装函数本身。 插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种： 通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令。 通过 app.provide() 使一个资源可被注入进整个应用。 向 app.config.globalProperties 中添加一些全局实例属性或方法 以一个全局的 Loading 组件为例： 12345678910111213141516171819202122// Loading/index.tsimport type &#123; App, VNode &#125; from &#x27;vue&#x27;import &#123; createVNode, render &#125; from &#x27;vue&#x27;import Loading from &#x27;./index.vue&#x27;export default &#123; install (app: App) &#123; // Loading 需要转成 VNode const VNode: VNode = createVNode(Loading) // 将组件挂在到某个元素下 render(VNode, document.body) // Loading 组件通过 defineExpose 方法，暴露内部方法会在 exposed 字段上 app.config.globalProperties.$loading = &#123; onShow: VNode.component?.exposed?.onShow, onHide: VNode.component?.exposed?.onHide &#125; &#125;&#125; Loading 组件内部实现 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;loading&quot; v-if=&quot;show&quot; @click=&quot;onHide&quot;&gt; &lt;img src=&quot;../../assets/imgs/loading.gif&quot; alt=&quot;&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;ref, reactive&#125; from &#x27;vue&#x27;const show = ref(false)const onShow = () =&gt; show.value = trueconst onHide = () =&gt; show.value = false// 暴露内部方法供外部调用defineExpose(&#123; onShow, onHide,&#125;)&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.loading &#123; width: 100%; height: 100%; background-color: #1f2123; position: absolute; top: 0; left: 0; text-align: center;&#125;&lt;/style&gt; 这样我们就可以在任何地方使用 全局 Loading 了。 123456789// setupconst instance = getCurrentInstance()const showLoading = () =&gt; &#123; instance?.proxy?.$loading.onShow()&#125;// or 直接在 template 中使用&lt;button @click=&quot;$loading.onShow&quot;&gt;show loading&lt;/button&gt; 如果调用 $loading 报ts错误，我们可以声明全局类型 12345678declare module &#x27;vue&#x27; &#123; export interface ComponentCustomProperties &#123; $loading: &#123; onShow(): void; onHide(): void; &#125; &#125;&#125; Scoped原理 &amp; 样式穿透 给 HTML DOM节点加一个不重复的 data 属性（形如: data-v-xxxxx），来表示它的唯一性 在每句 CSS 选择器的末尾，加一个当前组件的 data 属性选择器，来私有化样式 如果组件内部包含其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性. 想要直接修改开源组件的样式，大概率是失败的，解决方案就是要使用样式穿透 123456789/deep/ .input &#123; ...&#125;// or:deep(.input) &#123; ...&#125; css新特性插槽选择器我们在使用插槽时，如何在子组件中修改插槽内容的样式 123:slotted(.p-footer) &#123; color: red;&#125; 定义全局样式123:global(div) &#123; color: red;&#125; 动态 css123456789101112// jsconst color = ref(&#x27;red&#x27;)const font = ref(&#123; fontSize: &#x27;24px&#x27;, fontWeight: &#x27;bold&#x27;,&#125;)// css.box &#123; color: v-bind(color); font-size: v-bind(&#x27;font.fontSize&#x27;);&#125; 模块化 css给 style 标签加上 module 属性 123456789101112// template// 如果有多个，就写成数组形式&lt;div :class=&quot;[$style.box]&quot;&gt; 模块 css&lt;/div&gt;// css&lt;style module&gt;.box &#123; color: red&#125;&lt;/style&gt; $style 是固定的写法，如果不想用这个变量，我们可以指定 module=&quot;myStyle&quot; 。 我们还可以通过 useCssModule 获取当前组件下的样式类名 123456// 默认const class = useCssModule()const class = useCssModule(&#x27;$style&#x27;)// 如果指定了 moduleconst class = useCssModule(&#x27;myStyle&#x27;) 集成 Tailwind CSS https://blog.csdn.net/qq1195566313/article/details/124951311?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167109189716782427434983%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=167109189716782427434983&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-124951311-null-null.nonecase&amp;utm_term=tailwind&amp;spm=1018.2226.3001.4450 安装 vscode 提示插件 Tailwind CSS IntelliSense h函数1234567891011import &#123; h &#125; from &#x27;vue&#x27;const Btn = (props, ctx) =&gt; &#123; return h(&#x27;div&#x27;, &#123; class: [...], onClick: () =&gt; &#123; ctx.emit(&#x27;on-click&#x27;, &#x27;hello world&#x27;) &#125;, &#125;, ctx.slots.default())&#125; 参考资料Vue3+Vite+Ts 项目实战 01 Vite 创建项目、ESLint+TS+GitCommit配置、Vue3新特性介绍 ↩","categories":[],"tags":[{"name":"JS,Vue3","slug":"JS-Vue3","permalink":"http://yoursite.com/tags/JS-Vue3/"}]},{"title":"高性能渲染十万条数据(虚拟列表)","slug":"virtual-list","date":"2022-11-23T12:43:13.000Z","updated":"2022-11-28T03:19:11.257Z","comments":true,"path":"/post/virtual-list.html","link":"","permalink":"http://yoursite.com/post/virtual-list.html","excerpt":"使用虚拟列表的方式，来同时加载大量数据。","text":"前言在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。 时间分片 提到了可以使用时间分片的方式来对长列表进行渲染，但这种方式更适用于列表项的DOM结构十分简单的情况。本文会介绍使用虚拟列表的方式，来同时加载大量数据。 当我们渲染10w条数据时，其实主要是的时间花费在 Recalculate Style 和 Layout 上 Recalculate Style：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。 Layout：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。 在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。 那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在Recalculate Style和Layout阶段消耗大量的时间。 而虚拟列表就是解决这一问题的一种实现。 什么是虚拟列表虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。 假设有1万条记录需要同时渲染，我们屏幕的可见区域的高度为1000px,而列表项的高度为50px，则此时我们在屏幕中最多只能看到20个列表项，那么在首次渲染的时候，我们只需加载20条即可。 说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。 假设滚动发生，滚动条距顶部的位置为150px,则我们可得知在可见区域内的列表项为第4项至`第13项。 实现虚拟列表的实现，实际上是在首屏加载的时候，只加载 可视区域 内需要的列表项，当滚动发生时，通过计算动态获得可视区域内的列表项，并将非可视区域内存在的列表项删除。 计算当前可视区域起始数据索引（startIndex） 计算当前可视区域结束数据索引（endIndex） 计算当前可视区域的数据，并渲染到页面中 计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上 由于只是对可视区域内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构： 1234567891011121314151617181920&lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;!-- 所有数据的总高度 --&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 可视区区域，可以当做滑块看待 --&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;!-- 每一项数据 --&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.value &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 接着，监听infinite-list-container的 scroll事件，获取滚动位置 scrollTop。 列表总高度 listHeight = listData.length * itemSize 可显示的列表项数 visibleCount = Math.ceil(screenHeight / itemSize) 数据的起始索引 startIndex = Math.floor(scrollTop / itemSize) 数据的结束索引 endIndex = startIndex + visibleCount 列表显示数据为 visibleData = listData.slice(startIndex,endIndex) 12345678910111213scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引（向下取整），itemSize 是 100 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize);&#125;, 当滚动后，由于 渲染区域 相对于 可视区域 已经发生了偏移，此时我需要获取一个 偏移量startOffset，通过样式控制将渲染区域偏移至可视区域中，当用户在滑动时，渲染区域就会根据 startOffset 计算出偏移量，渲染区域就会一直在可视区域内呈现。 1234567this.startOffset = scrollTop - (scrollTop % this.itemSize);// computed//偏移量对应的stylegetTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`;&#125;, 完整代码12345678910111213141516&lt;style&gt; html&#123; height: 100%; &#125; body&#123; height: 100%; margin:0; &#125; #app&#123; height:100%; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;VirtualList :listData=&quot;state.data&quot; :itemSize=&quot;100&quot; /&gt;&lt;/div&gt; VirtualList comp. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;script&gt;export default &#123; name: &quot;VirtualList&quot;, props: &#123; //所有列表数据 listData: &#123; type: Array, default: () =&gt; [], &#125;, //每项高度 itemSize: &#123; type: Number, default: 200, &#125;, &#125;, computed: &#123; //列表总高度 listHeight() &#123; return this.listData.length * this.itemSize; &#125;, //可显示的列表项数 visibleCount() &#123; // 向上取整: Math.ceil(13.06) =&gt; 14，表示整个屏幕，可以放 14 条数据 return Math.ceil(this.screenHeight / this.itemSize); &#125;, //偏移量对应的style getTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`; &#125;, //获取真实显示列表数据 visibleData() &#123; return this.listData.slice( this.start, Math.min(this.end, this.listData.length) ); &#125;, &#125;, mounted() &#123; // this.$el 表示当前组件的根节点，这里是 infinite-list-container this.screenHeight = this.$el.clientHeight; this.start = 0; this.end = this.start + this.visibleCount; &#125;, data() &#123; return &#123; //可视区域高度 screenHeight: 0, //偏移量 startOffset: 0, //起始索引 start: 0, //结束索引 end: null, &#125;; &#125;, methods: &#123; scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引（向下取整），itemSize 是 100 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;!-- 所有数据的总高度 --&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 可视区区域，可以当做滑块看待 --&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.value &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.infinite-list-container &#123; height: 100%; overflow: auto; position: relative; -webkit-overflow-scrolling: touch;&#125;.infinite-list-phantom &#123; position: absolute; left: 0; top: 0; right: 0; z-index: -1;&#125;.infinite-list &#123; left: 0; right: 0; top: 0; position: absolute; text-align: center;&#125;.infinite-list-item &#123; padding: 10px; color: #555; box-sizing: border-box; border-bottom: 1px solid #999;&#125;&lt;/style&gt; 列表项动态高度在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。 而实际应用的时候，当列表中包含文本之类的可变内容，会导致 列表项的高度并不相同。 比如这样： 在虚拟列表中应用动态高度的解决方案一般有如下三种： 1.对组件属性itemSize进行扩展，支持传递类型为数字、数组、函数 可以是一个固定值，如 100，此时列表项是固高的 可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, …] 可以是一个根据列表项索引返回其高度的函数：(index: number): number 这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。 2.将列表项 渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内。 由于 预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。 3.以预估高度先行渲染，然后获取真实高度并缓存。 这是可以选择的实现方式，可以避免前两种方案的不足。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"高性能渲染十万条数据(时间分片)","slug":"time-fragment","date":"2022-11-23T11:53:52.000Z","updated":"2022-11-23T12:52:27.198Z","comments":true,"path":"/post/time-fragment.html","link":"","permalink":"http://yoursite.com/post/time-fragment.html","excerpt":"渲染大量数据。","text":"最粗暴的做法（一次性渲染JS的运行时间为187ms，还是蛮快的，但是最终渲染完成后的总时间确是2844ms，中间会白屏一段时间。 1234567891011121314151617// 记录任务开始时间let now = Date.now();// 插入十万条数据const total = 100000;// 获取容器let ul = document.getElementById(&#x27;container&#x27;);// 将数据插入容器中for (let i = 0; i &lt; total; i++) &#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = i ul.appendChild(li);&#125;console.log(&#x27;JS运行时间：&#x27;, Date.now() - now);setTimeout(() =&gt; &#123; console.log(&#x27;总运行时间：&#x27;, Date.now() - now);&#125;, 0) 使用定时器页面的卡顿是由于同时渲染大量DOM所引起的，所以考虑将渲染过程分批进行，这里用到的就是 setTimeout。 1234567891011121314151617181920212223242526let ul = document.getElementById(&#x27;container&#x27;);// 插入十万条数据let total = 100000;// 一次插入 20 条let once = 20;//总页数let page = total / once//每条记录的索引let index = 0;//循环加载数据function loop(curTotal, curIndex) &#123; if (curTotal &lt;= 0) &#123; return false; &#125; //每页多少条 let pageCount = Math.min(curTotal, once); setTimeout(() =&gt; &#123; for (let i = 0; i &lt; pageCount; i++) &#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) ul.appendChild(li) &#125; loop(curTotal - pageCount, curIndex + pageCount) &#125;, 0)&#125;loop(total, index); 页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象。 为什么会出现闪屏现象呢首先，理清一些概念。FPS表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS是描述帧变化速度的物理量。 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，FPS为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。 因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。 为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。 而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。 大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 直观感受，不同帧率的体验： 帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适； 帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异； 帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感； 帧率波动很大的动画，亦会使人感觉到卡顿。 简单聊一下 setTimeout 和闪屏现象 setTimeout的执行时间并不是确定的。在JS中，setTimeout任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此setTimeout的实际执行时间可能会比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。 在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 使用 requestAnimationFrame与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。 如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame 的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。 将 setTimeout 替换成 requestAnimationFrame: 123456789101112// 其他 ...window.requestAnimationFrame(function()&#123; for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) ul.appendChild(li) &#125; loop(curTotal - pageCount,curIndex + pageCount)&#125;)// ... 使用 DocumentFragment DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。可以使用document.createDocumentFragment方法或者构造函数来创建一个空的DocumentFragment 从MDN的说明中，我们得知DocumentFragments是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流（什么是回流? 回流是会导致页面重新渲染的一些元素,从而影响性能）。 当append元素到document中时，被append进去的元素的样式表的计算是同步发生的，此时调用 getComputedStyle 可以得到样式的计算值。 而append元素到 documentFragment 中时，是不会计算元素的样式表，所以documentFragment 性能更优。当然现在浏览器的优化已经做的很好了， 当append元素到document中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后。 1234567891011121314// 其他 ...window.requestAnimationFrame(function()&#123; const fragment = document.createDocumentFragment() for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = curIndex + i + &#x27; : &#x27; + ~~(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) loop(curTotal - pageCount,curIndex + pageCount)&#125;)// ...","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ESM/ESBuild","slug":"ESM-ESBuild","date":"2022-09-13T09:11:35.000Z","updated":"2022-09-16T08:40:53.050Z","comments":true,"path":"/post/ESM-ESBuild.html","link":"","permalink":"http://yoursite.com/post/ESM-ESBuild.html","excerpt":"继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。","text":"ESModule继 CommonJS、AMD、CMD 几种模块化规范由社区提出后，ES 2015（ES6）在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案。 在浏览器中通过 &lt;script type=&quot;module&quot;&gt; 原生支持 ESM。 https://www.cnblogs.com/zhaojian-08/p/14385312.html 导入/导出12345678// esm_index.jsexport const hello_world = 1export default function() &#123;&#125;&lt;script type=&quot;module&quot;&gt; import fn, &#123; hello_world &#125; from &#x27;./esm_index.js&#x27;&lt;/script&gt; 动态加载123456789101112// dynamic-m.jsexport const dynamic_value = &#x27;动态加载&#x27;export default function() &#123; console.log(&#x27;default&#x27;)&#125;mport(&#x27;./dynamic-m.js&#x27;) .then(module =&gt; &#123; // module: &#123; default: fn, dynamic_value: &#x27;动态加载&#x27; &#125; console.log(&#x27;动态&#x27;, module) &#125;) ESBuild https://esbuild.github.io/api/ 介绍: https://juejin.cn/post/6918927987056312327","categories":[],"tags":[{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"}]},{"title":"深入浅出TypeScript","slug":"深入浅出TypeScript","date":"2022-09-09T02:35:36.000Z","updated":"2022-09-13T03:03:59.001Z","comments":true,"path":"/post/深入浅出TypeScript.html","link":"","permalink":"http://yoursite.com/post/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATypeScript.html","excerpt":"TypeScript","text":"TypeScript.d.ts 和 declare 是干嘛用的如果一个文件有扩展名 .d.ts，则表示它是一个声明文件，可以用来声明全局的类型定义和接口，或者是其它模块。比如： 1234567891011121314151617181920// global.d.ts// 声明接口declare interface Person &#123; name: string; age: number;&#125;// 声明类型 (别名)declare type TName = string;// 声明模块declare module &#x27;*.css&#x27;;declare module &#x27;*.less&#x27;;declare module &#x27;*.png&#x27;;// 拓展 window 属性，在 window 对象上显式设置属性declare interface Window &#123; MyNameSpace: any&#125; 但是也不是说创建了.d.ts文件，里面声明的东西就能生效了，毕竟归根到底也是.ts文件，需要预编译，所以需要在tsconfig.json文件里面的include数组里面添加 global.d.ts 文件。 1&quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;] .d.ts 文件中的顶级声明必须以 “declare” 或 “export” 修饰符开头。通过declare声明的类型或者变量或者模块，在include包含的文件范围内，都可以直接引用。 12345// .vue setup / .tsconst me: Person = &#123; name: &#x27;alex.cheng&#x27;, age: 18&#125; 注意.d.ts文件顶级声明declare最好不要跟export同级使用，不然在其他ts文件引用这个.d.ts的内容的时候，就需要手动import导入了。 12345678// global.d.tsexport type TName = string;// 这个时候，外部 ts 就无法直接使用 Person 了，需要引入 import &#123; Person &#125; from &#x27;../global.d.ts&#x27;export declare interface Person &#123; name: string; age: number;&#125; 给对象分配动态（未知）属性1234567891011121314const o: &#123; [key: string]: any &#125; = &#123;&#125;// 使用 ts 内置工具 Record，效果同上const o: Record&lt;string, any&gt; = &#123;&#125;interface IPerson extends Record&lt;string, any&gt; &#123; name: string; age?: number;&#125;const me1: IPerson = &#123; name: &#x27;alex&#x27;, hair: &#x27;black&#x27;&#125; interface 和 type 有什么区别 接口和类型别名都可以用来描述对象的形状或函数签名。 与接口类型不一样的是，类型别名可以用于一些其他类型，比如原始类型、联合类型（|）和元组。 接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。 interface 扩展（接口、类型）使用 extends 关键字，类型别名扩展（接口、类型）使用的是 交叉类型（&amp;）: 123456789101112131415// 接口扩展interface IPerson &#123; name: string;&#125;interface IMe extends IPerson &#123; age: number;&#125;// 类型扩展type TPerson = &#123; name: string;&#125;type TMe = TPerson &amp; &#123; age: number;&#125; 类可以以相同的方式实现(implements)接口或类型别名，但类不能实现使用类型别名定义的联合类型 12345678910111213// Error:type PartialPoint = &#123; x: number; &#125; | &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; // 类只能实现具有静态已知成员的对象类型或对象类型的交集。ts(2422) x = 1; y = 2;&#125;// Successtype PartialPoint = &#123; x: number; &#125; &amp; &#123; y: number; &#125;;class SomePartialPoint implements PartialPoint &#123; x = 1; y = 2;&#125; 与类型别名不同，接口可以定义多次，会被自动合并为单个接口。 123456789101112interface IMerge &#123; a: 1;&#125;interface IMerge &#123; b: 2&#125;const ab: IMerge = &#123;&#125;; // 类型“&#123;&#125;”缺少类型“IMerge”中的以下属性: a, bts(2739)// Error: 标识符“TOne”重复。ts(2300)type TOne = string;type TOne = number; 类型保护 typeof instanceof in 参考资料TS 学习指南 ↩深入理解TypeScript ↩","categories":[],"tags":[{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"}]},{"title":"移动端开发实践","slug":"app-h5","date":"2022-06-09T06:26:40.000Z","updated":"2022-06-09T06:44:26.042Z","comments":true,"path":"/post/app-h5.html","link":"","permalink":"http://yoursite.com/post/app-h5.html","excerpt":"React Native 、H5移动端开发实践","text":"WebView现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发，它具备开发周期短、灵活性好的优点，但是缺点也很明显，加载速度慢 &amp; 消耗流量。引起缺点的主要原因如下： js解析效率，以及手机硬件设备的性能 页面资源的下载（图片、js文件、css文件） 参考资料Android Webview H5 秒开方案实现 ↩","categories":[],"tags":[{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"}]},{"title":"如何编写高标准的 JavaScript 代码","slug":"js-advice","date":"2022-03-31T02:12:23.000Z","updated":"2022-04-08T02:42:23.957Z","comments":true,"path":"/post/js-advice.html","link":"","permalink":"http://yoursite.com/post/js-advice.html","excerpt":"代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。","text":"概述你是否曾经为了提供一个简单的应用解决方案而彻夜地查看源代码？你是否曾经为了理解某个框架而冥思苦想、阅览群书？你是否曾经为了提升0.1s的DOM性能而对多种实现方案进行严格测试和对比？你是否曾经为了避免兼容问题而遍寻高手共同“诊治”？ 跟我一起，专注高质量 JavaScript 代码，少出 Bug🐛，早下班 ! 期望为读者带来如下帮助 📚： ❑ 能写出简单、清晰、高效的代码。 ❑ 能搭建一个稳定、健壮、快捷的应用框架。 ❑ 能回答一个困扰很多人的技术问题。 ❑ 能修复一个应用开发中遇到的大的Bug。 ❑ 能非常熟悉某个开源产品。 ❑ 能提升客户端应用性能。 JavaScript 基础代码量少，运行速度不一定快；代码量多，运行速度也不一定慢。 减少全局变量 多个全局变量都追加在一个名称空间下，将显著降低与其他应用程序产生冲突的概率 123const namespace = &#123;&#125;namespace.name = &#x27;my namespace&#x27; 使用闭包体将信息隐藏，它是另一种有效减少“全局污染”的方法。 1234567const sayName = function() &#123; const name = &#x27;closure&#x27; return function() &#123; alert(name) &#125;&#125;() 作用域控制着变量与参数的可见性及生命周期。 JavaScript支持函数作用域，定义在函数中的参数和变量在函数外部是不可见的，并且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。它不仅减少了名称冲突，并且提供了自动内存管理。 ES6 模块化编程中每个 js 文件内部定义的变量，外部无法获取。如果外部需要模块内部变量，通过 export 导出。 1234567891011&lt;script&gt; var windowA = &#x27;window a&#x27; console.log(window.windowA) // 输出 &#x27;window a&#x27;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; var moduleA = &#x27;module a&#x27; console.log(window.moduleA) // 输出 undefined&lt;/script&gt; 谨慎JS数据类型在自动转换数据类型时，JavaScript一般遵循：如果某个类型的值被用于需要其他类型的值的环境中，JavaScript就自动将这个值转换成所需要的类型。 类型转换慎用JavaScript类型自动转换，注意自动转换规则: 如果把非空对象用在逻辑运算环境中，则对象被转换为true。此时的对象包括所有类型的对象，即使是值为false的包装对象也被转换为true。 果把对象用在数值运算环境中，则对象会被自动转换为数字，如果转换失败，则返回值为NaN。 当数组被用在数值运算环境中时，数组将根据包含的元素来决定转换的值。如果数组为空数组，则被转换为数值0。如果数组仅包含一个数字元素，则被转换为该数字的数值。如果数组包含多个元素，或者仅包含一个非数字元素，则返回NaN。 🌰 123456789101112// 对象const obj = &#123;&#125;obj &amp;&amp; 1 &gt;&gt; 1obj + 1 &gt;&gt; &#x27;[object Object]1&#x27;obj.valueOf = function() &#123; return 99 &#125;obj + 1 &gt;&gt; 100// 数组自动转换规则+[] &gt;&gt; 0+[1] &gt;&gt; 1+[1,2] &gt;&gt; NaN 类型判断 typeof对于任何变量来说，使用typeof运算符总是以字符串的形式返回以下6种类型之一：❑ “number”❑ “string”❑ “boolean”❑ “object”❑ “function”❑ “undefined” 令人疑惑的是，在使用 typeof 检测null值时，返回的是“object”，而不是“null”。 12345typeof null &gt;&gt; &#x27;object&#x27;typeof [] &gt;&gt; &#x27;object&#x27;typeof &#123;&#125; &gt;&gt; &#x27;object&#x27; instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 这个在判断对象时存在一些不确定性，来看下例子： 🌰 123456function Person(name) &#123; this.name = name&#125;const p = new Person(&#x27;hello&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 再看一个🌰: 123456789101112131415function Person(name) &#123; this.name = name&#125;function Child(name) &#123; this.name = name&#125;Child.prototype = Person.prototypeChild.prototype.constructor = Childconst p = new Child(&#x27;hello child&#x27;)p instanceof Person &gt;&gt; truep instanceof Object &gt;&gt; true 如果是判断数组呢? 1234567[] instanceof Array &gt;&gt; true[] instanceof Object &gt;&gt; true// 当然这种方式存在不确定性，我们可以使用 Array.isArray() 方法来判断Array.isArray([]) &gt;&gt; trueArray.isArray(&#123;&#125;) &gt;&gt; false 从上面例子可以看出，使用 instanceof 来判断时存在种种不确定性，只要出现在原型链上的对象都会返回 true，使用的时候还需要着重注意！ 为什么会这样，想必大家应该想起来了！ Object类是所有对象类型的的父类! toString() 方法 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 toString() 方法，它定义在 Object 的原型对象上，对象在调用时会返回一个表示该对象的字符串。 使用 toString() 方法检测对象类型是最安全、最准确的。调用toString()方法把对象转换为字符串，然后通过检测字符串中是否包含数组所特有的标志字符可以确定对象的类型。 为什么说 toString 方法用来检测对象类型是最安全、最准确的，我们慢慢来看吧~ 先看看在对象上直接使用 toString会是什么结果： 1234567891011121314const obj = &#123; a: 1 &#125;const arr = [1, 2]obj.toString() &gt;&gt; &#x27;[object Object]&#x27;// 如果是数组的话，则输出字符串arr.toString() &gt;&gt; &#x27;1,2&#x27;// 当然我们可以重写/覆盖原型链上的 toString 方法obj.toString = function() &#123; return &#x27;overwrite&#x27;&#125;obj.toString() &gt;&gt; &#x27;overwrite&#x27; 既然 toString 方法定义在原型对象上，我们看看如果单独调用它，会是什么结果呢? 1Object.prototype.toString() &gt;&gt; &#x27;[object Object]&#x27; 如果通过 call/apply 方法，改变 toString 方法内部的 this 执行，又会是什么结果呢? 看到如下结果，我相信这绝对可以完美 cover 住项目里面所有的类型判断了！所以说它是最安全、最准确的类型判断，没有异议吧😏 12345678910111213141516171819202122Object.prototype.toString.call(&#123;&#125;) &gt;&gt; &#x27;[object Object]&#x27;Object.prototype.toString.call([]) &gt;&gt; &#x27;[object Array]&#x27;Object.prototype.toString.call(function()&#123;&#125;) &gt;&gt; &#x27;[object Function]&#x27;Object.prototype.toString.call(&#x27;&#x27;) &gt;&gt; &#x27;[object String]&#x27;Object.prototype.toString.call(1) &gt;&gt; &#x27;[object Number]&#x27;Object.prototype.toString.call(true) &gt;&gt; &#x27;[object Boolean]&#x27;Object.prototype.toString.call(null) &gt;&gt; &#x27;[object Null]&#x27;Object.prototype.toString.call(undefined) &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call() &gt;&gt; &#x27;[object Undefined]&#x27;Object.prototype.toString.call(new Date()) &gt;&gt; &#x27;[object Date]&#x27;Object.prototype.toString.call(/at/) &gt;&gt; &#x27;[object RegExp]&#x27; 那么它是如何做到的呢，我们来扒一扒它的原理！在 toString 方法被调用时，会执行以下几个操作步骤: 获取this指向的那个对象的[[Class]]属性的值。（call/apply 改变 this 指向） 计算出三个字符串”[object “、 第一步的操作结果、 以及 “]” 连接后的新字符串。 返回第二步的操作结果，也就是类似 &#39;[object Type]&#39; 这种格式字符串。 需要注意的是，对象的[[Class]]属性是无法直接访问的，它一个内部属性，所有的对象(原生对象和宿主对象)都拥有该属性，且不能被任何人修改。在规范中，[[Class]]是这么定义的：内部属性描述。 如果要单独或者对象的 [[Class]]，我们可以这样做: 12const targetObj = []Object.prototype.toString.call(targetObj).slice(8, -1) &gt;&gt; &#x27;Array&#x27; 既然它如此好用，难道就没有缺点吗？ 答案是当然有的，毕竟凡事都不可能那么绝对的嘛！ 那么缺点是什么呢？第一，toString() 会进行装箱操作，产生很多临时对象。（装箱就是将基本类型的数据，通过引用类型包装起来，从而可以使用引用类上的方法） 12345// 你肯定不能这样用1.toString() &gt;&gt; SyntaxError: Invalid or unexpected token// 你必须这样用(1).toString() &gt;&gt; &#x27;1&#x27; 第二，无法区分自定义对象类型，用来判断这类对象时，返回的都是Object，这样我们就需要通过 instanceof 来判断了。 1234function Person()&#123;&#125;const p = new Person()Object.prototype.toString.call(p) &gt;&gt; &#x27;[object Object]&#x27; 字符串JavaScript解释器强制约定字符串在堆区存储的数据是不可变的，也就是说，JavaScript解释器强制约定字符串在堆区存储的数据是不可变的。 参考资料参考资料 ↩参考资料2 ↩","categories":[],"tags":[{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"}]},{"title":"React Hooks","slug":"react-hooks","date":"2022-03-26T10:41:01.000Z","updated":"2022-12-23T04:43:55.402Z","comments":true,"path":"/post/react-hooks.html","link":"","permalink":"http://yoursite.com/post/react-hooks.html","excerpt":"什么是React Hooks，为什么需要它？如何高效的使用React Hooks？如何自定义 Hooks ？如何通过 Hooks 做性能优化？","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 动机Hook 规则 只在最顶层使用 Hook 只在 React 函数中调用 Hook。（或：在自定义 Hook 中调用其他 Hook） 使用 useCallback、useMemo、memo 做性能优化尽可能的保证组件不去发生变化，发生变化的因素有：state、props、context。 那么 React 是如何比较这三者的呢？ 答案是 内存地址。 比如说，对比一个 function，对比的就是这个函数在内存中的地址，通过地址的判断，从而判断 props 是否发生了改变。 React.memo https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate React.memo 包裹一个组件，来对它的 props 进行浅比较。等效于 PureComponent，但它只比较 props。（也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。） 123456789101112131415161718192021222324// 不使用 memo，每一次 setCount，都会造成 Child 组件重新 renderconst Child = () =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;const Demo = () =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child /&gt; &lt;/&gt; )&#125;// 通过 memo 包裹后，Child 组件不会再重新 render了。const Child = memo(() =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;) 当 memo 感知 props 没有发生改变时，不会重新 render 组件。如果传入 count 进来，Child组件就会重新 render。 总结： 如果我们将 setCount 当做 prop 传入进来，Child 不会重新render（因为 setCount 在内存中的地址没有发生改变） 如果传入我们自己定义的方法 (fn)进来，Child会重新 render，因为 Demo 组件每次更新 count 后，重新生成了 fn 函数。 只是传了个 fn ，不想让 Child 组件更新怎么办？那就要用到 useCallback 钩子了 useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算。 1234// 只有当 count 发生变化时，才会重新计算const computedCount = useMemo(() =&gt; &#123; return count * 2&#125;, [count]) useMemo 也允许你跳过一次子节点的昂贵的重新渲染，比如组件初始化时，需要一次大量的计算，后续就不会再改变了： 123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; )&#125; useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。 下面这个例子，即使我们用 memo 包裹了组件，因为 setCount 每次会引起 Demo 组件重新 render，生成了新的 fn 函数(内存地址发生了变化)，导致 Child 也会重新 render。 123456789101112131415161718192021interface IChild &#123; fn: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;&#125;const Child = memo((props: IChild) =&gt; &#123; console.log(&#x27;Child&#x27;) return ( &lt;&gt;Child component&lt;/&gt; )&#125;)const Demo = () =&gt; &#123; const [count, setCount] = useState(0) const fn = () =&gt; console.log(&#x27;is fn&#x27;) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/&gt; )&#125; 我们不想让 fn 函数的 内存地址 发生变化，怎么办呢？使用 useCallback 钩子将其包裹起来即可。 注意：useMemo 也可以这样用，缓存 fn，从而使得 Child 组件不会重复 render。 1234567// 省略...const fn = useCallback(() =&gt; &#123; console.log(&#x27;is fn&#x27;)&#125;, [])// 省略... 这样 fn 函数就是一个缓存函数了，即使 count 不停的发生变化，也不会造成 Child 组件重复 render。 总结: 当 Demo 组件内部 state 发生了改变引起 Demo 和 Child 组件重新 render 并且 Child 组件接受了一个来自 Demo 组件自定义的方法（fn） 如果不希望 Child 组件重新 render，那么就需要用 useCallback 钩子将自定义方法 fn 包裹起来 因为 Child 组件 props 里面的 fn 和 useCallback 返回的 fn 指向的是内存中的同一个地址，那么 Child 组件就不会更新 useCallback 返回新函数的条件是：依赖项（第二个参数）发生了改变。 如果说我们的 Child 组件，本身就是需要根据 count 变化而变化，那么就不需要加这个缓存 API了，反而增加其计算负担。 设计组件不要为了使用钩子，过渡的使用钩子，好的页面设计，也许用不上这些钩子。 把不变的组件和变化的组件抽离出来！ 比如可以把 count 相关部分抽离成一个 Count 组件，使其和 Child 组件同层级排列，Count 组件和 Child 组件分开了，也不会引起 Child 组件做多余的 render。 12&lt;Count /&gt;&lt;Child prop=&#123;fn&#125; /&gt; 或者是通过 props.children 渲染 Child，也不会造成 Child 重新 render。 12345678910111213141516171819202122const Count = (props: any) =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; setCount(count =&gt; count + 1)&#125;&gt;+&lt;/button&gt; &#123;/* children 不会重新 render */&#125; &#123;props.children&#125; &lt;/&gt; )&#125;const Demo = () =&gt; &#123; // fn 永远不会变化 const fn = () =&gt; &#123;&#125; return ( &lt;&gt; &lt;Count&gt; &lt;Child fn=&#123;fn&#125; /&gt; &lt;/Count&gt; &lt;/&gt; )&#125; useRef / createRef 访问 DOM 节点 123456const inputEle = useRef(null)const inputEle = React.createRef()inputEle.current.focus() 测量 DOM节点？1234567891011121314151617const getHeight = useMemo(() =&gt; &#123; return (node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125; &#125;&#125;, [])// 或者const getHeight = useCallback((node: HTMLObjectElement) =&gt; &#123; if (node) &#123; setHeight(node.getBoundingClientRect().height) &#125;&#125;, []) 将 ref 逻辑抽离成一个 Hook 1234567891011121314151617181920// hookconst useClientRect = () =&gt; &#123; const [rect, setRect] = useState(null) const ref = useCallback(node =&gt; &#123; if (node) &#123; setRect(node.getBoundingClientRect()) &#125; &#125;, []) return [rect, ref]&#125;// 使用const [rect, ref] = useClientRect()&lt;h1 ref=&#123;ref&#125;&gt;是 H1 标签 &#123;count&#125;&lt;/h1&gt;&#123; rect &amp;&amp; &lt;span&gt;&#123;rect.height&#125;&lt;/span&gt;&#125; React.forwardRef React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。 123456789const FancyInput = forwardRef((props, ref) =&gt; ( &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;))// 这样可以拿到 input 元素了const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt; useImperativeHandle useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 12345678910111213141516171819202122232425const FancyInput = forwardRef((props, ref) =&gt; &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125;, alert () &#123; alert(1) &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;;&#125;)const inputEle = React.createRef()&lt;FancyInput ref=&#123;inputEle&#125; /&gt;// 通过 inputEle 获取到 useImperativeHandle 定义的方法inputEle.current.focus()inputEle.current.alert() 参考资料ahooks 官网 ↩","categories":[],"tags":[{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"}]},{"title":"Hello_AlexCc","slug":"first-article","date":"2019-07-29T15:37:50.000Z","updated":"2022-04-07T10:04:40.419Z","comments":true,"path":"/post/first-article.html","link":"","permalink":"http://yoursite.com/post/first-article.html","excerpt":"First Article","text":"What This is my first Blog. No.212345if (true) &#123; console.log(&quot;Hello_AlexCc!&quot;)&#125;return &quot;ヾ(◍°∇°◍)ﾉﾞ&quot;","categories":[],"tags":[{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}],"categories":[],"tags":[{"name":"工程化,Vue3,通用功能","slug":"工程化-Vue3-通用功能","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3-%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"name":"工程化,Vue3","slug":"工程化-Vue3","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3/"},{"name":"工程化,Vue3,Config","slug":"工程化-Vue3-Config","permalink":"http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-Vue3-Config/"},{"name":"Reactive,Vue3","slug":"Reactive-Vue3","permalink":"http://yoursite.com/tags/Reactive-Vue3/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"},{"name":"JS,Vue-Router,Vue3,","slug":"JS-Vue-Router-Vue3","permalink":"http://yoursite.com/tags/JS-Vue-Router-Vue3/"},{"name":"JS,Vue3","slug":"JS-Vue3","permalink":"http://yoursite.com/tags/JS-Vue3/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"ESM ESModule ESBuild","slug":"ESM-ESModule-ESBuild","permalink":"http://yoursite.com/tags/ESM-ESModule-ESBuild/"},{"name":"TypeScript TS","slug":"TypeScript-TS","permalink":"http://yoursite.com/tags/TypeScript-TS/"},{"name":"RN H5","slug":"RN-H5","permalink":"http://yoursite.com/tags/RN-H5/"},{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"},{"name":"React，Hooks","slug":"React，Hooks","permalink":"http://yoursite.com/tags/React%EF%BC%8CHooks/"},{"name":"One","slug":"One","permalink":"http://yoursite.com/tags/One/"}]}